declare namespace com {
    namespace sun {
        namespace crypto {
            namespace provider {
                abstract class AESCipher extends javax.crypto.CipherSpi {
                    protected constructor(arg0: int)
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    protected engineUpdateAAD(arg0: byte[], arg1: int, arg2: int): void
                    protected engineUpdateAAD(arg0: java.nio.ByteBuffer): void
                    public static class: java.lang.Class<any>
                }
                interface AESConstants {
                    AES_BLOCK_SIZE: int
                    AES_KEYSIZES: int[]
                }
                class AESCrypt extends com.sun.crypto.provider.SymmetricCipher implements com.sun.crypto.provider.AESConstants {
                    public static class: java.lang.Class<any>
                }
                class AESKeyGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class AESParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                abstract class AESWrapCipher extends javax.crypto.CipherSpi {
                    public constructor(arg0: int)
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class ARCFOURCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    protected engineGetKeySize(arg0: java.security.Key): int
                    public static class: java.lang.Class<any>
                }
                class BlockCipherParamsCore {
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class BlowfishCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                interface BlowfishConstants {
                    BLOWFISH_BLOCK_SIZE: int
                    BLOWFISH_MAX_KEYSIZE: int
                }
                class BlowfishCrypt extends com.sun.crypto.provider.SymmetricCipher implements com.sun.crypto.provider.BlowfishConstants {
                    public static class: java.lang.Class<any>
                }
                class BlowfishKeyGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class BlowfishParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class CipherBlockChaining extends com.sun.crypto.provider.FeedbackCipher {
                    protected r: byte[]
                    public static class: java.lang.Class<any>
                }
                class CipherCore {
                    public static class: java.lang.Class<any>
                }
                class CipherFeedback extends com.sun.crypto.provider.FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                class CipherTextStealing extends com.sun.crypto.provider.CipherBlockChaining {
                    public static class: java.lang.Class<any>
                }
                abstract class CipherWithWrappingSpi extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class ConstructKeys {
                    public static class: java.lang.Class<any>
                }
                class CounterMode extends com.sun.crypto.provider.FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                class DESCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                interface DESConstants {
                    DES_BLOCK_SIZE: int
                }
                class DESCrypt extends com.sun.crypto.provider.SymmetricCipher implements com.sun.crypto.provider.DESConstants {
                    public static class: java.lang.Class<any>
                }
                class DESKey implements javax.crypto.SecretKey {
                    public getEncoded(): byte[]
                    public getAlgorithm(): string
                    public getFormat(): string
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                    protected finalize(): void
                    public static class: java.lang.Class<any>
                }
                class DESKeyFactory extends javax.crypto.SecretKeyFactorySpi {
                    public constructor()
                    protected engineGenerateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
                    protected engineGetKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
                    protected engineTranslateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class DESKeyGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class DESParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class DESedeCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class DESedeCrypt extends com.sun.crypto.provider.DESCrypt implements com.sun.crypto.provider.DESConstants {
                    public static class: java.lang.Class<any>
                }
                class DESedeKey implements javax.crypto.SecretKey {
                    public getEncoded(): byte[]
                    public getAlgorithm(): string
                    public getFormat(): string
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                    protected finalize(): void
                    public static class: java.lang.Class<any>
                }
                class DESedeKeyFactory extends javax.crypto.SecretKeyFactorySpi {
                    public constructor()
                    protected engineGenerateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
                    protected engineGetKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
                    protected engineTranslateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class DESedeKeyGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class DESedeParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class DESedeWrapCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class DHKeyAgreement extends javax.crypto.KeyAgreementSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.Key, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec, arg2: java.security.SecureRandom): void
                    protected engineDoPhase(arg0: java.security.Key, arg1: boolean): java.security.Key
                    protected engineGenerateSecret(): byte[]
                    protected engineGenerateSecret(arg0: byte[], arg1: int): int
                    protected engineGenerateSecret(arg0: java.lang.String | string): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class DHKeyFactory extends java.security.KeyFactorySpi {
                    public constructor()
                    protected engineGeneratePublic(arg0: java.security.spec.KeySpec): java.security.PublicKey
                    protected engineGeneratePrivate(arg0: java.security.spec.KeySpec): java.security.PrivateKey
                    protected engineGetKeySpec<T extends java.security.spec.KeySpec>(arg0: java.security.Key, arg1: java.lang.Class<T>): T
                    protected engineTranslateKey<T extends java.security.spec.KeySpec>(arg0: java.security.Key): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class DHKeyPairGenerator extends java.security.KeyPairGeneratorSpi {
                    public constructor()
                    public initialize(arg0: int, arg1: java.security.SecureRandom): void
                    public initialize(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    public generateKeyPair(): java.security.KeyPair
                    public static class: java.lang.Class<any>
                }
                class DHParameterGenerator extends java.security.AlgorithmParameterGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineGenerateParameters(): java.security.AlgorithmParameters
                    public static class: java.lang.Class<any>
                }
                class DHParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class DHPrivateKey implements java.security.PrivateKey , javax.crypto.interfaces.DHPrivateKey , java.io.Serializable {
                    public getFormat(): string
                    public getAlgorithm(): string
                    public getEncoded(): byte[]
                    public getX(): java.math.BigInteger
                    public getParams(): javax.crypto.spec.DHParameterSpec
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                }
                class DHPublicKey implements java.security.PublicKey , javax.crypto.interfaces.DHPublicKey , java.io.Serializable {
                    public getFormat(): string
                    public getAlgorithm(): string
                    public getEncoded(): byte[]
                    public getY(): java.math.BigInteger
                    public getParams(): javax.crypto.spec.DHParameterSpec
                    public toString(): string
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                }
                class ElectronicCodeBook extends com.sun.crypto.provider.FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                class EncryptedPrivateKeyInfo {
                    public static class: java.lang.Class<any>
                }
                abstract class FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                class GCMParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class GCTR {
                    protected doFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    public static class: java.lang.Class<any>
                }
                class GHASH {
                    public static class: java.lang.Class<any>
                }
                class GaloisCounterMode extends com.sun.crypto.provider.FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                abstract class HmacCore extends javax.crypto.MacSpi implements java.lang.Cloneable {
                    protected engineGetMacLength(): int
                    protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
                    protected engineUpdate(arg0: byte): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
                    protected engineUpdate(arg0: java.nio.ByteBuffer): void
                    protected engineDoFinal(): byte[]
                    protected engineReset(): void
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                class HmacMD5 extends com.sun.crypto.provider.HmacCore {
                    public constructor()
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                class HmacMD5KeyGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class HmacPKCS12PBESHA1 extends com.sun.crypto.provider.HmacCore {
                    public constructor()
                    protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                class HmacSHA1 extends com.sun.crypto.provider.HmacCore {
                    public constructor()
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                class HmacSHA1KeyGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class ISO10126Padding implements com.sun.crypto.provider.Padding {
                    public padWithLen(arg0: byte[], arg1: int, arg2: int): void
                    public unpad(arg0: byte[], arg1: int, arg2: int): int
                    public padLength(arg0: int): int
                    public static class: java.lang.Class<any>
                }
                class JceKeyStore extends java.security.KeyStoreSpi {
                    public constructor()
                    public engineGetKey(arg0: java.lang.String | string, arg1: char[]): java.security.Key
                    public engineGetCertificateChain(arg0: java.lang.String | string): java.security.cert.Certificate[]
                    public engineGetCertificate(arg0: java.lang.String | string): java.security.cert.Certificate
                    public engineGetCreationDate(arg0: java.lang.String | string): java.util.Date
                    public engineSetKeyEntry(arg0: java.lang.String | string, arg1: java.security.Key, arg2: char[], arg3: java.security.cert.Certificate[]): void
                    public engineSetKeyEntry(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.cert.Certificate[]): void
                    public engineSetCertificateEntry(arg0: java.lang.String | string, arg1: java.security.cert.Certificate): void
                    public engineDeleteEntry(arg0: java.lang.String | string): void
                    public engineAliases(): java.util.Enumeration<java.lang.String>
                    public engineContainsAlias(arg0: java.lang.String | string): boolean
                    public engineSize(): int
                    public engineIsKeyEntry(arg0: java.lang.String | string): boolean
                    public engineIsCertificateEntry(arg0: java.lang.String | string): boolean
                    public engineGetCertificateAlias(arg0: java.security.cert.Certificate): string
                    public engineStore(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: char[]): void
                    public engineLoad(arg0: java.io.InputStream, arg1: char[]): void
                    public static class: java.lang.Class<any>
                }
                class KeyGeneratorCore {
                    public static class: java.lang.Class<any>
                }
                class KeyProtector {
                    public static class: java.lang.Class<any>
                }
                class OAEPParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class OutputFeedback extends com.sun.crypto.provider.FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                class PBEKey implements javax.crypto.SecretKey {
                    public getEncoded(): byte[]
                    public getAlgorithm(): string
                    public getFormat(): string
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                    protected finalize(): void
                    public static class: java.lang.Class<any>
                }
                abstract class PBEKeyFactory extends javax.crypto.SecretKeyFactorySpi {
                    protected engineGenerateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
                    protected engineGetKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
                    protected engineTranslateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class PBEParameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class PBES1Core {
                    public static class: java.lang.Class<any>
                }
                abstract class PBES2Core extends javax.crypto.CipherSpi {
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                abstract class PBES2Parameters extends java.security.AlgorithmParametersSpi {
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class PBEWithMD5AndDESCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class PBEWithMD5AndTripleDESCipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                abstract class PBKDF2Core extends javax.crypto.SecretKeyFactorySpi {
                    protected engineGenerateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
                    protected engineGetKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
                    protected engineTranslateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class PBKDF2HmacSHA1Factory extends javax.crypto.SecretKeyFactorySpi {
                    public constructor()
                    protected engineGenerateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
                    protected engineGetKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
                    protected engineTranslateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {
                    public getEncoded(): byte[]
                    public getAlgorithm(): string
                    public getIterationCount(): int
                    public getPassword(): char[]
                    public getSalt(): byte[]
                    public getFormat(): string
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                    protected finalize(): void
                }
                abstract class PBMAC1Core extends com.sun.crypto.provider.HmacCore {
                    protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
                    public static class: java.lang.Class<any>
                }
                class PCBC extends com.sun.crypto.provider.FeedbackCipher {
                    public static class: java.lang.Class<any>
                }
                class PKCS12PBECipherCore {
                    public static class: java.lang.Class<any>
                }
                class PKCS5Padding implements com.sun.crypto.provider.Padding {
                    public padWithLen(arg0: byte[], arg1: int, arg2: int): void
                    public unpad(arg0: byte[], arg1: int, arg2: int): int
                    public padLength(arg0: int): int
                    public static class: java.lang.Class<any>
                }
                interface Padding {
                    padWithLen(arg0: byte[], arg1: int, arg2: int): void
                    unpad(arg0: byte[], arg1: int, arg2: int): int
                    padLength(arg0: int): int
                }
                class PrivateKeyInfo {
                    public static class: java.lang.Class<any>
                }
                class RC2Cipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineGetKeySize(arg0: java.security.Key): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    public static class: java.lang.Class<any>
                }
                class RC2Crypt extends com.sun.crypto.provider.SymmetricCipher {
                    public static class: java.lang.Class<any>
                }
                class RC2Parameters extends java.security.AlgorithmParametersSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                    protected engineInit(arg0: byte[]): void
                    protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                    protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                    protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                    protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                    public static class: java.lang.Class<any>
                }
                class RSACipher extends javax.crypto.CipherSpi {
                    public constructor()
                    protected engineSetMode(arg0: java.lang.String | string): void
                    protected engineSetPadding(arg0: java.lang.String | string): void
                    protected engineGetBlockSize(): int
                    protected engineGetOutputSize(arg0: int): int
                    protected engineGetIV(): byte[]
                    protected engineGetParameters(): java.security.AlgorithmParameters
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
                    protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
                    protected engineWrap(arg0: java.security.Key): byte[]
                    protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
                    protected engineGetKeySize(arg0: java.security.Key): int
                    public static class: java.lang.Class<any>
                }
                class SealedObjectForKeyProtector extends javax.crypto.SealedObject {
                    public static class: java.lang.Class<any>
                }
                class SslMacCore {
                    public static class: java.lang.Class<any>
                }
                class SunJCE extends java.security.Provider {
                    public constructor()
                    public static class: java.lang.Class<any>
                }
                abstract class SymmetricCipher {
                    public static class: java.lang.Class<any>
                }
                class TlsKeyMaterialGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                class TlsMasterSecretGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
                abstract class TlsPrfGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    public static class: java.lang.Class<any>
                }
                class TlsRsaPremasterSecretGenerator extends javax.crypto.KeyGeneratorSpi {
                    public constructor()
                    protected engineInit(arg0: java.security.SecureRandom): void
                    protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                    protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                    protected engineGenerateKey(): javax.crypto.SecretKey
                    public static class: java.lang.Class<any>
                }
            }
        }
        namespace java {
            namespace util {
                namespace jar {
                    namespace pack {
                        class AdaptiveCoding implements com.sun.java.util.jar.pack.CodingMethod {
                            public static KX_MIN: int
                            public static KX_MAX: int
                            public static KX_LG2BASE: int
                            public static KX_BASE: int
                            public static KB_MIN: int
                            public static KB_MAX: int
                            public static KB_OFFSET: int
                            public static KB_DEFAULT: int
                            public constructor(arg0: int, arg1: com.sun.java.util.jar.pack.CodingMethod, arg2: com.sun.java.util.jar.pack.CodingMethod)
                            public setHeadCoding(arg0: com.sun.java.util.jar.pack.CodingMethod): void
                            public setHeadLength(arg0: int): void
                            public setTailCoding(arg0: com.sun.java.util.jar.pack.CodingMethod): void
                            public isTrivial(): boolean
                            public writeArrayTo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int[], arg2: int, arg3: int): void
                            public readArrayFrom(arg0: java.io.InputStream, arg1: int[], arg2: int, arg3: int): void
                            public static isCodableLength(arg0: int): boolean
                            public getMetaCoding(arg0: com.sun.java.util.jar.pack.Coding): byte[]
                            public static parseMetaCoding(arg0: byte[], arg1: int, arg2: com.sun.java.util.jar.pack.Coding, arg3: com.sun.java.util.jar.pack.CodingMethod[]): int
                            public toString(): string
                            public static class: java.lang.Class<any>
                        }
                        class Attribute implements java.lang.Comparable<com.sun.java.util.jar.pack.Attribute> {
                            public name(): string
                            public layout(): com.sun.java.util.jar.pack.Attribute$Layout
                            public bytes(): byte[]
                            public size(): int
                            public getNameRef(): com.sun.java.util.jar.pack.ConstantPool$Entry
                            public constructor(arg0: com.sun.java.util.jar.pack.Attribute$Layout, arg1: byte[], arg2: java.lang.Object)
                            public constructor(arg0: com.sun.java.util.jar.pack.Attribute$Layout, arg1: byte[])
                            public addContent(arg0: byte[], arg1: java.lang.Object): com.sun.java.util.jar.pack.Attribute
                            public addContent(arg0: byte[]): com.sun.java.util.jar.pack.Attribute
                            public finishRefs(arg0: com.sun.java.util.jar.pack.ConstantPool$Index): void
                            public isCanonical(): boolean
                            public compareTo(arg0: com.sun.java.util.jar.pack.Attribute): int
                            public static getCanonList(arg0: java.util.List<com.sun.java.util.jar.pack.Attribute>): java.util.List<com.sun.java.util.jar.pack.Attribute>
                            public static find(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string): com.sun.java.util.jar.pack.Attribute
                            public static keyForLookup(arg0: int, arg1: java.lang.String | string): com.sun.java.util.jar.pack.Attribute$Layout
                            public static lookup(arg0: java.util.Map<com.sun.java.util.jar.pack.Attribute$Layout, com.sun.java.util.jar.pack.Attribute>, arg1: int, arg2: java.lang.String | string): com.sun.java.util.jar.pack.Attribute
                            public static define(arg0: java.util.Map<com.sun.java.util.jar.pack.Attribute$Layout, com.sun.java.util.jar.pack.Attribute>, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string): com.sun.java.util.jar.pack.Attribute
                            public static contextName(arg0: int): string
                            public parse(arg0: com.sun.java.util.jar.pack.Attribute$Holder, arg1: byte[], arg2: int, arg3: int, arg4: com.sun.java.util.jar.pack.Attribute$ValueStream): void
                            public unparse(arg0: com.sun.java.util.jar.pack.Attribute$ValueStream, arg1: java.io.ByteArrayOutputStream): java.lang.Object
                            public toString(): string
                            public static normalizeLayoutString(arg0: java.lang.String | string): string
                            public compareTo(arg0: java.lang.Object): int
                            public static class: java.lang.Class<any>
                        }
                        abstract class BandStructure {
                            protected bandHeaderBytes: byte[]
                            protected bandHeaderBytePos: int
                            protected bandHeaderBytePos0: int
                            public static NO_PHASE: int
                            public static COLLECT_PHASE: int
                            public static FROZEN_PHASE: int
                            public static WRITE_PHASE: int
                            public static EXPECT_PHASE: int
                            public static READ_PHASE: int
                            public static DISBURSE_PHASE: int
                            public static DONE_PHASE: int
                            protected archiveOptions: int
                            protected archiveSize0: long
                            protected archiveSize1: long
                            protected archiveNextCount: int
                            protected metadataBands: com.sun.java.util.jar.pack.BandStructure$MultiBand[]
                            protected typeMetadataBands: com.sun.java.util.jar.pack.BandStructure$MultiBand[]
                            public static ADH_CONTEXT_MASK: int
                            public static ADH_BIT_SHIFT: int
                            public static ADH_BIT_IS_LSB: int
                            public static ATTR_INDEX_OVERFLOW: int
                            public attrIndexLimit: int[]
                            protected attrFlagMask: long[]
                            protected attrDefSeen: long[]
                            protected attrOverflowMask: int[]
                            protected attrClassFileVersionMask: int
                            protected attrBandTable: java.util.Map<com.sun.java.util.jar.pack.Attribute$Layout, com.sun.java.util.jar.pack.BandStructure$Band[]>
                            protected attrCodeEmpty: com.sun.java.util.jar.pack.Attribute$Layout
                            protected attrInnerClassesEmpty: com.sun.java.util.jar.pack.Attribute$Layout
                            protected attrClassFileVersion: com.sun.java.util.jar.pack.Attribute$Layout
                            protected attrConstantValue: com.sun.java.util.jar.pack.Attribute$Layout
                            protected attrDefs: java.util.List<java.util.List<com.sun.java.util.jar.pack.Attribute$Layout>>
                            protected attrBands: com.sun.java.util.jar.pack.BandStructure$MultiBand[]
                            public shortCodeHeader_h_limit: int
                            protected getCPIndex(arg0: byte): com.sun.java.util.jar.pack.ConstantPool$Index
                            public initHighestClassVersion(arg0: com.sun.java.util.jar.pack.Package$Version): void
                            public getHighestClassVersion(): com.sun.java.util.jar.pack.Package$Version
                            protected constructor()
                            public static codingForIndex(arg0: int): com.sun.java.util.jar.pack.Coding
                            public static indexOf(arg0: com.sun.java.util.jar.pack.Coding): int
                            public static getBasicCodings(): com.sun.java.util.jar.pack.Coding[]
                            protected getBandHeader(arg0: int, arg1: com.sun.java.util.jar.pack.Coding): com.sun.java.util.jar.pack.CodingMethod
                            public static parseMetaCoding(arg0: byte[], arg1: int, arg2: com.sun.java.util.jar.pack.Coding, arg3: com.sun.java.util.jar.pack.CodingMethod[]): int
                            protected getCodingChooser(): com.sun.java.util.jar.pack.CodingChooser
                            public chooseCoding(arg0: int[], arg1: int, arg2: int, arg3: com.sun.java.util.jar.pack.Coding, arg4: java.lang.String | string, arg5: int[]): com.sun.java.util.jar.pack.CodingMethod
                            protected static decodeEscapeValue(arg0: int, arg1: com.sun.java.util.jar.pack.Coding): int
                            protected static encodeEscapeValue(arg0: int, arg1: com.sun.java.util.jar.pack.Coding): int
                            protected setBandIndexes(): void
                            protected setBandIndex(arg0: com.sun.java.util.jar.pack.BandStructure$CPRefBand, arg1: byte): void
                            protected setConstantValueIndex(arg0: com.sun.java.util.jar.pack.Package$Class$Field): void
                            protected initAttrIndexLimit(): void
                            protected haveFlagsHi(arg0: int): boolean
                            protected getPredefinedAttrs(arg0: int): java.util.List<com.sun.java.util.jar.pack.Attribute$Layout>
                            protected isPredefinedAttr(arg0: int, arg1: int): boolean
                            protected adjustSpecialAttrMasks(): void
                            protected makeClassFileVersionAttr(arg0: com.sun.java.util.jar.pack.Package$Version): com.sun.java.util.jar.pack.Attribute
                            protected parseClassFileVersionAttr(arg0: com.sun.java.util.jar.pack.Attribute): com.sun.java.util.jar.pack.Package$Version
                            protected setAttributeLayoutIndex(arg0: com.sun.java.util.jar.pack.Attribute$Layout, arg1: int): int
                            protected putLabel(arg0: com.sun.java.util.jar.pack.BandStructure$IntBand, arg1: com.sun.java.util.jar.pack.Code, arg2: int, arg3: int): void
                            protected getLabel(arg0: com.sun.java.util.jar.pack.BandStructure$IntBand, arg1: com.sun.java.util.jar.pack.Code, arg2: int): int
                            protected getCPRefOpBand(arg0: int): com.sun.java.util.jar.pack.BandStructure$CPRefBand
                            protected selfOpRefBand(arg0: int): com.sun.java.util.jar.pack.BandStructure$CPRefBand
                            protected static testBit(arg0: int, arg1: int): boolean
                            protected static setBit(arg0: int, arg1: int, arg2: boolean): int
                            protected static testBit(arg0: long, arg1: long): boolean
                            protected static setBit(arg0: long, arg1: long, arg2: boolean): long
                            protected static realloc(arg0: java.lang.Object[], arg1: int): java.lang.Object[]
                            protected static realloc(arg0: java.lang.Object[]): java.lang.Object[]
                            protected static realloc(arg0: int[], arg1: int): int[]
                            protected static realloc(arg0: int[]): int[]
                            protected static realloc(arg0: byte[], arg1: int): byte[]
                            protected static realloc(arg0: byte[]): byte[]
                            public static class: java.lang.Class<any>
                        }
                        class ClassReader {
                            public setAttrDefs(arg0: java.util.Map<com.sun.java.util.jar.pack.Attribute$Layout, com.sun.java.util.jar.pack.Attribute>): void
                            public setAttrCommands(arg0: java.util.Map<com.sun.java.util.jar.pack.Attribute$Layout, java.lang.String>): void
                            public static class: java.lang.Class<any>
                        }
                        class ClassWriter {
                            public static class: java.lang.Class<any>
                        }
                        class Code extends com.sun.java.util.jar.pack.Attribute$Holder {
                            public constructor(arg0: com.sun.java.util.jar.pack.Package$Class$Method)
                            public getMethod(): com.sun.java.util.jar.pack.Package$Class$Method
                            public thisClass(): com.sun.java.util.jar.pack.Package$Class
                            public getPackage(): com.sun.java.util.jar.pack.Package
                            public getCPMap(): com.sun.java.util.jar.pack.ConstantPool$Entry[]
                            public trimToSize(): void
                            protected visitRefs(arg0: int, arg1: java.util.Collection<com.sun.java.util.jar.pack.ConstantPool$Entry>): void
                            public encodeBCI(arg0: int): int
                            public decodeBCI(arg0: int): int
                            public finishRefs(arg0: com.sun.java.util.jar.pack.ConstantPool$Index): void
                            public toString(): string
                            public getInt(arg0: int): int
                            public getShort(arg0: int): int
                            public getByte(arg0: int): int
                            public static class: java.lang.Class<any>
                        }
                        class Coding implements java.lang.Comparable<com.sun.java.util.jar.pack.Coding> , com.sun.java.util.jar.pack.CodingMethod , com.sun.java.util.jar.pack.Histogram$BitMetric {
                            public static B_MAX: int
                            public static H_MAX: int
                            public static S_MAX: int
                            public static codeMax(arg0: int, arg1: int, arg2: int, arg3: int): int
                            public static codeMin(arg0: int, arg1: int, arg2: int, arg3: int): int
                            public static writeInt(arg0: byte[], arg1: int[], arg2: int, arg3: int, arg4: int, arg5: int): void
                            public static readInt(arg0: byte[], arg1: int[], arg2: int, arg3: int, arg4: int): int
                            public static readIntFrom(arg0: java.io.InputStream, arg1: int, arg2: int, arg3: int): int
                            public equals(arg0: java.lang.Object): boolean
                            public hashCode(): int
                            public static of(arg0: int, arg1: int): com.sun.java.util.jar.pack.Coding
                            public static of(arg0: int, arg1: int, arg2: int): com.sun.java.util.jar.pack.Coding
                            public canRepresentValue(arg0: int): boolean
                            public canRepresentSigned(arg0: int): boolean
                            public canRepresentUnsigned(arg0: int): boolean
                            public readFrom(arg0: byte[], arg1: int[]): int
                            public writeTo(arg0: byte[], arg1: int[], arg2: int): void
                            public readFrom(arg0: java.io.InputStream): int
                            public writeTo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int): void
                            public readArrayFrom(arg0: java.io.InputStream, arg1: int[], arg2: int, arg3: int): void
                            public writeArrayTo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int[], arg2: int, arg3: int): void
                            public B(): int
                            public H(): int
                            public L(): int
                            public S(): int
                            public del(): int
                            public min(): int
                            public max(): int
                            public umin(): int
                            public umax(): int
                            public byteMin(arg0: int): int
                            public byteMax(arg0: int): int
                            public compareTo(arg0: com.sun.java.util.jar.pack.Coding): int
                            public distanceFrom(arg0: com.sun.java.util.jar.pack.Coding): int
                            public getBitLength(arg0: int): double
                            public getLength(arg0: int): int
                            public getLength(arg0: int[], arg1: int, arg2: int): int
                            public getMetaCoding(arg0: com.sun.java.util.jar.pack.Coding): byte[]
                            public static parseMetaCoding(arg0: byte[], arg1: int, arg2: com.sun.java.util.jar.pack.Coding, arg3: com.sun.java.util.jar.pack.CodingMethod[]): int
                            public keyString(): string
                            public toString(): string
                            public compareTo(arg0: java.lang.Object): int
                            public static class: java.lang.Class<any>
                        }
                        class CodingChooser {
                            public static MIN_EFFORT: int
                            public static MID_EFFORT: int
                            public static MAX_EFFORT: int
                            public static POP_EFFORT: int
                            public static RUN_EFFORT: int
                            public static BYTE_SIZE: int
                            public static ZIP_SIZE: int
                            public computeSize(arg0: com.sun.java.util.jar.pack.CodingMethod, arg1: int[], arg2: int, arg3: int, arg4: int[]): void
                            public computeSize(arg0: com.sun.java.util.jar.pack.CodingMethod, arg1: int[], arg2: int[]): void
                            public computeSize(arg0: com.sun.java.util.jar.pack.CodingMethod, arg1: int[], arg2: int, arg3: int): int[]
                            public computeSize(arg0: com.sun.java.util.jar.pack.CodingMethod, arg1: int[]): int[]
                            public computeByteSize(arg0: com.sun.java.util.jar.pack.CodingMethod, arg1: int[], arg2: int, arg3: int): int
                            public static class: java.lang.Class<any>
                        }
                        interface CodingMethod {
                            readArrayFrom(arg0: java.io.InputStream, arg1: int[], arg2: int, arg3: int): void
                            writeArrayTo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int[], arg2: int, arg3: int): void
                            getMetaCoding(arg0: com.sun.java.util.jar.pack.Coding): byte[]
                        }
                        abstract class ConstantPool {
                            protected static noRefs: com.sun.java.util.jar.pack.ConstantPool$Entry[]
                            protected static noClassRefs: com.sun.java.util.jar.pack.ConstantPool$ClassEntry[]
                            public static getUtf8Entry(arg0: java.lang.String | string): com.sun.java.util.jar.pack.ConstantPool$Utf8Entry
                            public static getClassEntry(arg0: java.lang.String | string): com.sun.java.util.jar.pack.ConstantPool$ClassEntry
                            public static getLiteralEntry(arg0: java.lang.Comparable<any> | java.lang.Comparable$$Lambda<any>): com.sun.java.util.jar.pack.ConstantPool$LiteralEntry
                            public static getStringEntry(arg0: java.lang.String | string): com.sun.java.util.jar.pack.ConstantPool$StringEntry
                            public static getSignatureEntry(arg0: java.lang.String | string): com.sun.java.util.jar.pack.ConstantPool$SignatureEntry
                            public static getSignatureEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$Utf8Entry, arg1: com.sun.java.util.jar.pack.ConstantPool$ClassEntry[]): com.sun.java.util.jar.pack.ConstantPool$SignatureEntry
                            public static getDescriptorEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$Utf8Entry, arg1: com.sun.java.util.jar.pack.ConstantPool$SignatureEntry): com.sun.java.util.jar.pack.ConstantPool$DescriptorEntry
                            public static getDescriptorEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$Utf8Entry, arg1: com.sun.java.util.jar.pack.ConstantPool$Utf8Entry): com.sun.java.util.jar.pack.ConstantPool$DescriptorEntry
                            public static getMemberEntry(arg0: byte, arg1: com.sun.java.util.jar.pack.ConstantPool$ClassEntry, arg2: com.sun.java.util.jar.pack.ConstantPool$DescriptorEntry): com.sun.java.util.jar.pack.ConstantPool$MemberEntry
                            public static getMethodHandleEntry(arg0: byte, arg1: com.sun.java.util.jar.pack.ConstantPool$MemberEntry): com.sun.java.util.jar.pack.ConstantPool$MethodHandleEntry
                            public static getMethodTypeEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$SignatureEntry): com.sun.java.util.jar.pack.ConstantPool$MethodTypeEntry
                            public static getMethodTypeEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$Utf8Entry): com.sun.java.util.jar.pack.ConstantPool$MethodTypeEntry
                            public static getInvokeDynamicEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$BootstrapMethodEntry, arg1: com.sun.java.util.jar.pack.ConstantPool$DescriptorEntry): com.sun.java.util.jar.pack.ConstantPool$InvokeDynamicEntry
                            public static getBootstrapMethodEntry(arg0: com.sun.java.util.jar.pack.ConstantPool$MethodHandleEntry, arg1: com.sun.java.util.jar.pack.ConstantPool$Entry[]): com.sun.java.util.jar.pack.ConstantPool$BootstrapMethodEntry
                            public static makeIndex(arg0: java.lang.String | string, arg1: com.sun.java.util.jar.pack.ConstantPool$Entry[]): com.sun.java.util.jar.pack.ConstantPool$Index
                            public static makeIndex(arg0: java.lang.String | string, arg1: java.util.Collection<com.sun.java.util.jar.pack.ConstantPool$Entry>): com.sun.java.util.jar.pack.ConstantPool$Index
                            public static sort(arg0: com.sun.java.util.jar.pack.ConstantPool$Index): void
                            public static partition(arg0: com.sun.java.util.jar.pack.ConstantPool$Index, arg1: int[]): com.sun.java.util.jar.pack.ConstantPool$Index[]
                            public static partitionByTag(arg0: com.sun.java.util.jar.pack.ConstantPool$Index): com.sun.java.util.jar.pack.ConstantPool$Index[]
                            public static completeReferencesIn(arg0: java.util.Set<com.sun.java.util.jar.pack.ConstantPool$Entry>, arg1: boolean): void
                            public static completeReferencesIn(arg0: java.util.Set<com.sun.java.util.jar.pack.ConstantPool$Entry>, arg1: boolean, arg2: java.util.List<com.sun.java.util.jar.pack.ConstantPool$BootstrapMethodEntry>): void
                            public static tagName(arg0: int): string
                            public static refKindName(arg0: int): string
                            public static class: java.lang.Class<any>
                        }
                        class Constants {
                            public static JAVA_MAGIC: int
                            public static JAVA_MIN_CLASS_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA5_MAX_CLASS_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA6_MAX_CLASS_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA7_MAX_CLASS_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA8_MAX_CLASS_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA_PACKAGE_MAGIC: int
                            public static JAVA5_PACKAGE_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA6_PACKAGE_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA7_PACKAGE_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA8_PACKAGE_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static JAVA_MAX_CLASS_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static MAX_PACKAGE_VERSION: com.sun.java.util.jar.pack.Package$Version
                            public static CONSTANT_POOL_INDEX_LIMIT: int
                            public static CONSTANT_POOL_NARROW_LIMIT: int
                            public static JAVA_SIGNATURE_CHARS: string
                            public static CONSTANT_Utf8: byte
                            public static CONSTANT_unused2: byte
                            public static CONSTANT_Integer: byte
                            public static CONSTANT_Float: byte
                            public static CONSTANT_Long: byte
                            public static CONSTANT_Double: byte
                            public static CONSTANT_Class: byte
                            public static CONSTANT_String: byte
                            public static CONSTANT_Fieldref: byte
                            public static CONSTANT_Methodref: byte
                            public static CONSTANT_InterfaceMethodref: byte
                            public static CONSTANT_NameandType: byte
                            public static CONSTANT_unused13: byte
                            public static CONSTANT_unused14: byte
                            public static CONSTANT_MethodHandle: byte
                            public static CONSTANT_MethodType: byte
                            public static CONSTANT_unused17: byte
                            public static CONSTANT_InvokeDynamic: byte
                            public static CONSTANT_None: byte
                            public static CONSTANT_Signature: byte
                            public static CONSTANT_BootstrapMethod: byte
                            public static CONSTANT_Limit: byte
                            public static CONSTANT_All: byte
                            public static CONSTANT_LoadableValue: byte
                            public static CONSTANT_AnyMember: byte
                            public static CONSTANT_FieldSpecific: byte
                            public static CONSTANT_GroupFirst: byte
                            public static CONSTANT_GroupLimit: byte
                            public static REF_getField: byte
                            public static REF_getStatic: byte
                            public static REF_putField: byte
                            public static REF_putStatic: byte
                            public static REF_invokeVirtual: byte
                            public static REF_invokeStatic: byte
                            public static REF_invokeSpecial: byte
                            public static REF_newInvokeSpecial: byte
                            public static REF_invokeInterface: byte
                            public static ACC_IC_LONG_FORM: int
                            public static ATTR_CONTEXT_CLASS: int
                            public static ATTR_CONTEXT_FIELD: int
                            public static ATTR_CONTEXT_METHOD: int
                            public static ATTR_CONTEXT_CODE: int
                            public static ATTR_CONTEXT_LIMIT: int
                            public static ATTR_CONTEXT_NAME: java.lang.String[]
                            public static X_ATTR_OVERFLOW: int
                            public static CLASS_ATTR_SourceFile: int
                            public static METHOD_ATTR_Code: int
                            public static FIELD_ATTR_ConstantValue: int
                            public static CLASS_ATTR_EnclosingMethod: int
                            public static METHOD_ATTR_Exceptions: int
                            public static X_ATTR_Signature: int
                            public static X_ATTR_Deprecated: int
                            public static X_ATTR_RuntimeVisibleAnnotations: int
                            public static X_ATTR_RuntimeInvisibleAnnotations: int
                            public static METHOD_ATTR_RuntimeVisibleParameterAnnotations: int
                            public static CLASS_ATTR_InnerClasses: int
                            public static METHOD_ATTR_RuntimeInvisibleParameterAnnotations: int
                            public static CLASS_ATTR_ClassFile_version: int
                            public static METHOD_ATTR_AnnotationDefault: int
                            public static METHOD_ATTR_MethodParameters: int
                            public static X_ATTR_RuntimeVisibleTypeAnnotations: int
                            public static X_ATTR_RuntimeInvisibleTypeAnnotations: int
                            public static CODE_ATTR_StackMapTable: int
                            public static CODE_ATTR_LineNumberTable: int
                            public static CODE_ATTR_LocalVariableTable: int
                            public static CODE_ATTR_LocalVariableTypeTable: int
                            public static FO_DEFLATE_HINT: int
                            public static FO_IS_CLASS_STUB: int
                            public static AO_HAVE_SPECIAL_FORMATS: int
                            public static AO_HAVE_CP_NUMBERS: int
                            public static AO_HAVE_ALL_CODE_FLAGS: int
                            public static AO_HAVE_CP_EXTRAS: int
                            public static AO_HAVE_FILE_HEADERS: int
                            public static AO_DEFLATE_HINT: int
                            public static AO_HAVE_FILE_MODTIME: int
                            public static AO_HAVE_FILE_OPTIONS: int
                            public static AO_HAVE_FILE_SIZE_HI: int
                            public static AO_HAVE_CLASS_FLAGS_HI: int
                            public static AO_HAVE_FIELD_FLAGS_HI: int
                            public static AO_HAVE_METHOD_FLAGS_HI: int
                            public static AO_HAVE_CODE_FLAGS_HI: int
                            public static AO_UNUSED_MBZ: int
                            public static LG_AO_HAVE_XXX_FLAGS_HI: int
                            public static NO_MODTIME: int
                            public static noInts: int[]
                            public static noBytes: byte[]
                            public static noValues: java.lang.Object[]
                            public static noStrings: java.lang.String[]
                            public static emptyList: java.util.List<java.lang.Object>
                            public static _meta_default: int
                            public static _meta_canon_min: int
                            public static _meta_canon_max: int
                            public static _meta_arb: int
                            public static _meta_run: int
                            public static _meta_pop: int
                            public static _meta_limit: int
                            public static _nop: int
                            public static _aconst_null: int
                            public static _iconst_m1: int
                            public static _iconst_0: int
                            public static _iconst_1: int
                            public static _iconst_2: int
                            public static _iconst_3: int
                            public static _iconst_4: int
                            public static _iconst_5: int
                            public static _lconst_0: int
                            public static _lconst_1: int
                            public static _fconst_0: int
                            public static _fconst_1: int
                            public static _fconst_2: int
                            public static _dconst_0: int
                            public static _dconst_1: int
                            public static _bipush: int
                            public static _sipush: int
                            public static _ldc: int
                            public static _ldc_w: int
                            public static _ldc2_w: int
                            public static _iload: int
                            public static _lload: int
                            public static _fload: int
                            public static _dload: int
                            public static _aload: int
                            public static _iload_0: int
                            public static _iload_1: int
                            public static _iload_2: int
                            public static _iload_3: int
                            public static _lload_0: int
                            public static _lload_1: int
                            public static _lload_2: int
                            public static _lload_3: int
                            public static _fload_0: int
                            public static _fload_1: int
                            public static _fload_2: int
                            public static _fload_3: int
                            public static _dload_0: int
                            public static _dload_1: int
                            public static _dload_2: int
                            public static _dload_3: int
                            public static _aload_0: int
                            public static _aload_1: int
                            public static _aload_2: int
                            public static _aload_3: int
                            public static _iaload: int
                            public static _laload: int
                            public static _faload: int
                            public static _daload: int
                            public static _aaload: int
                            public static _baload: int
                            public static _caload: int
                            public static _saload: int
                            public static _istore: int
                            public static _lstore: int
                            public static _fstore: int
                            public static _dstore: int
                            public static _astore: int
                            public static _istore_0: int
                            public static _istore_1: int
                            public static _istore_2: int
                            public static _istore_3: int
                            public static _lstore_0: int
                            public static _lstore_1: int
                            public static _lstore_2: int
                            public static _lstore_3: int
                            public static _fstore_0: int
                            public static _fstore_1: int
                            public static _fstore_2: int
                            public static _fstore_3: int
                            public static _dstore_0: int
                            public static _dstore_1: int
                            public static _dstore_2: int
                            public static _dstore_3: int
                            public static _astore_0: int
                            public static _astore_1: int
                            public static _astore_2: int
                            public static _astore_3: int
                            public static _iastore: int
                            public static _lastore: int
                            public static _fastore: int
                            public static _dastore: int
                            public static _aastore: int
                            public static _bastore: int
                            public static _castore: int
                            public static _sastore: int
                            public static _pop: int
                            public static _pop2: int
                            public static _dup: int
                            public static _dup_x1: int
                            public static _dup_x2: int
                            public static _dup2: int
                            public static _dup2_x1: int
                            public static _dup2_x2: int
                            public static _swap: int
                            public static _iadd: int
                            public static _ladd: int
                            public static _fadd: int
                            public static _dadd: int
                            public static _isub: int
                            public static _lsub: int
                            public static _fsub: int
                            public static _dsub: int
                            public static _imul: int
                            public static _lmul: int
                            public static _fmul: int
                            public static _dmul: int
                            public static _idiv: int
                            public static _ldiv: int
                            public static _fdiv: int
                            public static _ddiv: int
                            public static _irem: int
                            public static _lrem: int
                            public static _frem: int
                            public static _drem: int
                            public static _ineg: int
                            public static _lneg: int
                            public static _fneg: int
                            public static _dneg: int
                            public static _ishl: int
                            public static _lshl: int
                            public static _ishr: int
                            public static _lshr: int
                            public static _iushr: int
                            public static _lushr: int
                            public static _iand: int
                            public static _land: int
                            public static _ior: int
                            public static _lor: int
                            public static _ixor: int
                            public static _lxor: int
                            public static _iinc: int
                            public static _i2l: int
                            public static _i2f: int
                            public static _i2d: int
                            public static _l2i: int
                            public static _l2f: int
                            public static _l2d: int
                            public static _f2i: int
                            public static _f2l: int
                            public static _f2d: int
                            public static _d2i: int
                            public static _d2l: int
                            public static _d2f: int
                            public static _i2b: int
                            public static _i2c: int
                            public static _i2s: int
                            public static _lcmp: int
                            public static _fcmpl: int
                            public static _fcmpg: int
                            public static _dcmpl: int
                            public static _dcmpg: int
                            public static _ifeq: int
                            public static _ifne: int
                            public static _iflt: int
                            public static _ifge: int
                            public static _ifgt: int
                            public static _ifle: int
                            public static _if_icmpeq: int
                            public static _if_icmpne: int
                            public static _if_icmplt: int
                            public static _if_icmpge: int
                            public static _if_icmpgt: int
                            public static _if_icmple: int
                            public static _if_acmpeq: int
                            public static _if_acmpne: int
                            public static _goto: int
                            public static _jsr: int
                            public static _ret: int
                            public static _tableswitch: int
                            public static _lookupswitch: int
                            public static _ireturn: int
                            public static _lreturn: int
                            public static _freturn: int
                            public static _dreturn: int
                            public static _areturn: int
                            public static _return: int
                            public static _getstatic: int
                            public static _putstatic: int
                            public static _getfield: int
                            public static _putfield: int
                            public static _invokevirtual: int
                            public static _invokespecial: int
                            public static _invokestatic: int
                            public static _invokeinterface: int
                            public static _invokedynamic: int
                            public static _new: int
                            public static _newarray: int
                            public static _anewarray: int
                            public static _arraylength: int
                            public static _athrow: int
                            public static _checkcast: int
                            public static _instanceof: int
                            public static _monitorenter: int
                            public static _monitorexit: int
                            public static _wide: int
                            public static _multianewarray: int
                            public static _ifnull: int
                            public static _ifnonnull: int
                            public static _goto_w: int
                            public static _jsr_w: int
                            public static _bytecode_limit: int
                            public static _end_marker: int
                            public static _byte_escape: int
                            public static _ref_escape: int
                            public static _first_linker_op: int
                            public static _last_linker_op: int
                            public static _num_linker_ops: int
                            public static _self_linker_op: int
                            public static _self_linker_aload_flag: int
                            public static _self_linker_super_flag: int
                            public static _self_linker_limit: int
                            public static _invokeinit_op: int
                            public static _invokeinit_self_option: int
                            public static _invokeinit_super_option: int
                            public static _invokeinit_new_option: int
                            public static _invokeinit_limit: int
                            public static _pseudo_instruction_limit: int
                            public static _xldc_op: int
                            public static _sldc: int
                            public static _cldc: int
                            public static _ildc: int
                            public static _fldc: int
                            public static _sldc_w: int
                            public static _cldc_w: int
                            public static _ildc_w: int
                            public static _fldc_w: int
                            public static _lldc2_w: int
                            public static _dldc2_w: int
                            public static _qldc: int
                            public static _qldc_w: int
                            public static _xldc_limit: int
                            public static _invoke_int_op: int
                            public static _invokespecial_int: int
                            public static _invokestatic_int: int
                            public static _invoke_int_limit: int
                            public static class: java.lang.Class<any>
                        }
                        class Driver {
                            public static main(arg0: java.lang.String[]): void
                            public static class: java.lang.Class<any>
                        }
                        class DriverResource extends java.util.ListResourceBundle {
                            public static VERSION: string
                            public static BAD_ARGUMENT: string
                            public static BAD_OPTION: string
                            public static BAD_REPACK_OUTPUT: string
                            public static DETECTED_ZIP_COMMENT: string
                            public static SKIP_FOR_REPACKED: string
                            public static WRITE_PACK_FILE: string
                            public static WRITE_PACKGZ_FILE: string
                            public static SKIP_FOR_MOVE_FAILED: string
                            public static PACK_HELP: string
                            public static UNPACK_HELP: string
                            public static MORE_INFO: string
                            public static DUPLICATE_OPTION: string
                            public static BAD_SPEC: string
                            public constructor()
                            protected getContents(): java.lang.Object[][]
                            public static class: java.lang.Class<any>
                        }
                        class DriverResource_ja extends java.util.ListResourceBundle {
                            public static VERSION: string
                            public static BAD_ARGUMENT: string
                            public static BAD_OPTION: string
                            public static BAD_REPACK_OUTPUT: string
                            public static DETECTED_ZIP_COMMENT: string
                            public static SKIP_FOR_REPACKED: string
                            public static WRITE_PACK_FILE: string
                            public static WRITE_PACKGZ_FILE: string
                            public static SKIP_FOR_MOVE_FAILED: string
                            public static PACK_HELP: string
                            public static UNPACK_HELP: string
                            public static MORE_INFO: string
                            public static DUPLICATE_OPTION: string
                            public static BAD_SPEC: string
                            public constructor()
                            protected getContents(): java.lang.Object[][]
                            public static class: java.lang.Class<any>
                        }
                        class DriverResource_zh_CN extends java.util.ListResourceBundle {
                            public static VERSION: string
                            public static BAD_ARGUMENT: string
                            public static BAD_OPTION: string
                            public static BAD_REPACK_OUTPUT: string
                            public static DETECTED_ZIP_COMMENT: string
                            public static SKIP_FOR_REPACKED: string
                            public static WRITE_PACK_FILE: string
                            public static WRITE_PACKGZ_FILE: string
                            public static SKIP_FOR_MOVE_FAILED: string
                            public static PACK_HELP: string
                            public static UNPACK_HELP: string
                            public static MORE_INFO: string
                            public static DUPLICATE_OPTION: string
                            public static BAD_SPEC: string
                            public constructor()
                            protected getContents(): java.lang.Object[][]
                            public static class: java.lang.Class<any>
                        }
                        class FixedList<E> implements java.util.List<E> {
                            protected constructor(arg0: int)
                            public size(): int
                            public isEmpty(): boolean
                            public contains(arg0: java.lang.Object): boolean
                            public iterator(): java.util.Iterator<E>
                            public toArray(): java.lang.Object[]
                            public toArray<T>(arg0: T[]): T[]
                            public add<T>(arg0: E): boolean
                            public remove<T>(arg0: java.lang.Object): boolean
                            public containsAll<T>(arg0: java.util.Collection<any>): boolean
                            public addAll<T>(arg0: java.util.Collection<E>): boolean
                            public addAll<T>(arg0: int, arg1: java.util.Collection<E>): boolean
                            public removeAll<T>(arg0: java.util.Collection<any>): boolean
                            public retainAll<T>(arg0: java.util.Collection<any>): boolean
                            public clear<T>(): void
                            public get<T>(arg0: int): E
                            public set<T>(arg0: int, arg1: E): E
                            public add<T>(arg0: int, arg1: E): void
                            public remove<T>(arg0: int): E
                            public indexOf<T>(arg0: java.lang.Object): int
                            public lastIndexOf<T>(arg0: java.lang.Object): int
                            public listIterator<T>(): java.util.ListIterator<E>
                            public listIterator<T>(arg0: int): java.util.ListIterator<E>
                            public subList<T>(arg0: int, arg1: int): java.util.List<E>
                            public toString<T>(): string
                            public static class: java.lang.Class<any>
                        }
                        class Fixups extends java.util.AbstractCollection<com.sun.java.util.jar.pack.Fixups$Fixup> {
                            public size(): int
                            public trimToSize(): void
                            public visitRefs(arg0: java.util.Collection<com.sun.java.util.jar.pack.ConstantPool$Entry>): void
                            public clear(): void
                            public getBytes(): byte[]
                            public setBytes(arg0: byte[]): void
                            public iterator(): java.util.Iterator<com.sun.java.util.jar.pack.Fixups$Fixup>
                            public add(arg0: int, arg1: int, arg2: com.sun.java.util.jar.pack.ConstantPool$Entry): void
                            public add(arg0: com.sun.java.util.jar.pack.Fixups$Fixup): boolean
                            public addAll(arg0: java.util.Collection<com.sun.java.util.jar.pack.Fixups$Fixup>): boolean
                            public static setBytes(arg0: java.lang.Object, arg1: byte[]): void
                            public static trimToSize(arg0: java.lang.Object): java.lang.Object
                            public static visitRefs(arg0: java.lang.Object, arg1: java.util.Collection<com.sun.java.util.jar.pack.ConstantPool$Entry>): void
                            public static finishRefs(arg0: java.lang.Object, arg1: byte[], arg2: com.sun.java.util.jar.pack.ConstantPool$Index): void
                            public add(arg0: java.lang.Object): boolean
                            public static class: java.lang.Class<any>
                        }
                        class Histogram {
                            protected matrix: int[][]
                            protected totalWeight: int
                            protected values: int[]
                            protected counts: int[]
                            public constructor(arg0: int[])
                            public constructor(arg0: int[], arg1: int, arg2: int)
                            public constructor(arg0: int[][])
                            public getMatrix(): int[][]
                            public getRowCount(): int
                            public getRowFrequency(arg0: int): int
                            public getRowLength(arg0: int): int
                            public getRowValue(arg0: int, arg1: int): int
                            public getRowWeight(arg0: int): int
                            public getTotalWeight(): int
                            public getTotalLength(): int
                            public getAllValues(): int[]
                            public getAllFrequencies(): int[]
                            public getFrequency(arg0: int): int
                            public getBitLength(arg0: int): double
                            public getRowBitLength(arg0: int): double
                            public getBitMetric(): com.sun.java.util.jar.pack.Histogram$BitMetric
                            public getBitLength(): double
                            public getBitLength(arg0: com.sun.java.util.jar.pack.Histogram$BitMetric): double
                            public normalizeMatrix(arg0: int[][]): int[][]
                            public getRowTitles(arg0: java.lang.String | string): java.lang.String[]
                            public print(arg0: java.io.PrintStream): void
                            public print(arg0: java.lang.String | string, arg1: java.io.PrintStream): void
                            public print(arg0: java.lang.String | string, arg1: java.lang.String[], arg2: java.io.PrintStream): void
                            public static makeByteHistogram(arg0: java.io.InputStream): com.sun.java.util.jar.pack.Histogram
                            public static class: java.lang.Class<any>
                        }
                        class Instruction {
                            protected bytes: byte[]
                            protected pc: int
                            protected bc: int
                            protected w: int
                            protected length: int
                            protected special: boolean
                            protected constructor(arg0: byte[], arg1: int, arg2: int, arg3: int, arg4: int)
                            public getBC(): int
                            public isWide(): boolean
                            public getBytes(): byte[]
                            public getPC(): int
                            public getLength(): int
                            public getNextPC(): int
                            public next(): com.sun.java.util.jar.pack.Instruction
                            public isNonstandard(): boolean
                            public setNonstandardLength(arg0: int): void
                            public forceNextPC(arg0: int): com.sun.java.util.jar.pack.Instruction
                            public static at(arg0: byte[], arg1: int): com.sun.java.util.jar.pack.Instruction
                            public static at(arg0: byte[], arg1: int, arg2: com.sun.java.util.jar.pack.Instruction): com.sun.java.util.jar.pack.Instruction
                            public getCPTag(): byte
                            public getCPIndex(): int
                            public setCPIndex(arg0: int): void
                            public getCPRef(arg0: com.sun.java.util.jar.pack.ConstantPool$Entry[]): com.sun.java.util.jar.pack.ConstantPool$Entry
                            public getLocalSlot(): int
                            public getBranchLabel(): int
                            public setBranchLabel(arg0: int): void
                            public getConstant(): int
                            public setConstant(arg0: int): void
                            public equals(arg0: java.lang.Object): boolean
                            public hashCode(): int
                            public equals(arg0: com.sun.java.util.jar.pack.Instruction): boolean
                            public toString(): string
                            public toString(arg0: com.sun.java.util.jar.pack.ConstantPool$Entry[]): string
                            public getIntAt(arg0: int): int
                            public getShortAt(arg0: int): int
                            public getByteAt(arg0: int): int
                            public static getInt(arg0: byte[], arg1: int): int
                            public static getShort(arg0: byte[], arg1: int): int
                            public static getByte(arg0: byte[], arg1: int): int
                            public static setInt(arg0: byte[], arg1: int, arg2: int): void
                            public static setShort(arg0: byte[], arg1: int, arg2: int): void
                            public static setByte(arg0: byte[], arg1: int, arg2: int): void
                            public static isNonstandard(arg0: int): boolean
                            public static opLength(arg0: int): int
                            public static opWideLength(arg0: int): int
                            public static isLocalSlotOp(arg0: int): boolean
                            public static isBranchOp(arg0: int): boolean
                            public static isCPRefOp(arg0: int): boolean
                            public static getCPRefOpTag(arg0: int): byte
                            public static isFieldOp(arg0: int): boolean
                            public static isInvokeInitOp(arg0: int): boolean
                            public static isSelfLinkerOp(arg0: int): boolean
                            public static byteName(arg0: int): string
                            public static opcodeChecker(arg0: byte[], arg1: com.sun.java.util.jar.pack.ConstantPool$Entry[], arg2: com.sun.java.util.jar.pack.Package$Version): void
                            public static class: java.lang.Class<any>
                        }
                        class NativeUnpack {
                            protected setOption(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
                            protected getOption(arg0: java.lang.String | string): string
                            public static class: java.lang.Class<any>
                        }
                        class Package {
                            public static attrCodeEmpty: com.sun.java.util.jar.pack.Attribute$Layout
                            public static attrBootstrapMethodsEmpty: com.sun.java.util.jar.pack.Attribute$Layout
                            public static attrInnerClassesEmpty: com.sun.java.util.jar.pack.Attribute$Layout
                            public static attrSourceFileSpecial: com.sun.java.util.jar.pack.Attribute$Layout
                            public static attrDefs: java.util.Map<com.sun.java.util.jar.pack.Attribute$Layout, com.sun.java.util.jar.pack.Attribute>
                            public constructor()
                            public constructor(arg0: com.sun.java.util.jar.pack.Package$Version, arg1: com.sun.java.util.jar.pack.Package$Version, arg2: com.sun.java.util.jar.pack.Package$Version)
                            public reset(): void
                            public getClasses(): java.util.List<com.sun.java.util.jar.pack.Package$Class>
                            public getFiles(): java.util.List<com.sun.java.util.jar.pack.Package$File>
                            public getClassStubs(): java.util.List<com.sun.java.util.jar.pack.Package$File>
                            public getAllInnerClasses(): java.util.List<com.sun.java.util.jar.pack.Package$InnerClass>
                            public setAllInnerClasses(arg0: java.util.Collection<com.sun.java.util.jar.pack.Package$InnerClass>): void
                            public getGlobalInnerClass(arg0: com.sun.java.util.jar.pack.ConstantPool$Entry): com.sun.java.util.jar.pack.Package$InnerClass
                            public trimToSize(): void
                            public strip(arg0: java.lang.String | string): void
                            public stripConstantFields(): void
                            protected visitRefs(arg0: int, arg1: java.util.Collection<com.sun.java.util.jar.pack.ConstantPool$Entry>): void
                            public static class: java.lang.Class<any>
                        }
                        class PackageReader extends com.sun.java.util.jar.pack.BandStructure {
                            protected getCPIndex(arg0: byte): com.sun.java.util.jar.pack.ConstantPool$Index
                            public static class: java.lang.Class<any>
                        }
                        class PackageWriter extends com.sun.java.util.jar.pack.BandStructure {
                            protected getCPIndex(arg0: byte): com.sun.java.util.jar.pack.ConstantPool$Index
                            public static class: java.lang.Class<any>
                        }
                        class PackerImpl extends com.sun.java.util.jar.pack.TLGlobals implements java.util.jar.Pack200$Packer {
                            public constructor()
                            public properties(): java.util.SortedMap<java.lang.String, java.lang.String>
                            public pack(arg0: java.util.jar.JarFile, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                            public pack(arg0: java.util.jar.JarInputStream, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                            public addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void
                            public removePropertyChangeListener(arg0: java.beans.PropertyChangeListener): void
                            public static class: java.lang.Class<any>
                        }
                        class PopulationCoding implements com.sun.java.util.jar.pack.CodingMethod {
                            public setFavoredValues(arg0: int[], arg1: int): void
                            public setFavoredValues(arg0: int[]): void
                            public setHistogram(arg0: com.sun.java.util.jar.pack.Histogram): void
                            public setL(arg0: int): void
                            public static fitTokenCoding(arg0: int, arg1: int): com.sun.java.util.jar.pack.Coding
                            public setFavoredCoding(arg0: com.sun.java.util.jar.pack.CodingMethod): void
                            public setTokenCoding(arg0: com.sun.java.util.jar.pack.CodingMethod): void
                            public setUnfavoredCoding(arg0: com.sun.java.util.jar.pack.CodingMethod): void
                            public favoredValueMaxLength(): int
                            public resortFavoredValues(): void
                            public getToken(arg0: int): int
                            public encodeValues(arg0: int[], arg1: int, arg2: int): int[][]
                            public writeArrayTo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int[], arg2: int, arg3: int): void
                            public readArrayFrom(arg0: java.io.InputStream, arg1: int[], arg2: int, arg3: int): void
                            public getMetaCoding(arg0: com.sun.java.util.jar.pack.Coding): byte[]
                            public static parseMetaCoding(arg0: byte[], arg1: int, arg2: com.sun.java.util.jar.pack.Coding, arg3: com.sun.java.util.jar.pack.CodingMethod[]): int
                            public toString(): string
                            public static class: java.lang.Class<any>
                        }
                        class PropMap implements java.util.SortedMap<java.lang.String, java.lang.String> {
                            public put(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                            public size(): int
                            public isEmpty(): boolean
                            public containsKey(arg0: java.lang.Object): boolean
                            public containsValue(arg0: java.lang.Object): boolean
                            public get(arg0: java.lang.Object): string
                            public remove(arg0: java.lang.Object): string
                            public putAll(arg0: java.util.Map<java.lang.String, java.lang.String>): void
                            public clear(): void
                            public keySet(): java.util.Set<java.lang.String>
                            public values(): java.util.Collection<java.lang.String>
                            public entrySet(): java.util.Set<java.util.Map$Entry<java.lang.String, java.lang.String>>
                            public comparator(): java.util.Comparator<java.lang.String>
                            public subMap(arg0: java.lang.String | string, arg1: java.lang.String | string): java.util.SortedMap<java.lang.String, java.lang.String>
                            public headMap(arg0: java.lang.String | string): java.util.SortedMap<java.lang.String, java.lang.String>
                            public tailMap(arg0: java.lang.String | string): java.util.SortedMap<java.lang.String, java.lang.String>
                            public firstKey(): string
                            public lastKey(): string
                            public lastKey(): java.lang.Object
                            public firstKey(): java.lang.Object
                            public tailMap(arg0: java.lang.Object): java.util.SortedMap
                            public headMap(arg0: java.lang.Object): java.util.SortedMap
                            public subMap(arg0: java.lang.Object, arg1: java.lang.Object): java.util.SortedMap
                            public remove(arg0: java.lang.Object): java.lang.Object
                            public put(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
                            public get(arg0: java.lang.Object): java.lang.Object
                            public static class: java.lang.Class<any>
                        }
                        class TLGlobals {
                            public static class: java.lang.Class<any>
                        }
                        class UnpackerImpl extends com.sun.java.util.jar.pack.TLGlobals implements java.util.jar.Pack200$Unpacker {
                            public addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void
                            public removePropertyChangeListener(arg0: java.beans.PropertyChangeListener): void
                            public constructor()
                            public properties(): java.util.SortedMap<java.lang.String, java.lang.String>
                            public toString(): string
                            public unpack(arg0: java.io.InputStream, arg1: java.util.jar.JarOutputStream): void
                            public unpack(arg0: java.io.File, arg1: java.util.jar.JarOutputStream): void
                            public static class: java.lang.Class<any>
                        }
                        class Utils {
                            public static class: java.lang.Class<any>
                        }
                    }
                }
            }
        }
        namespace net {
            namespace ssl {
                namespace internal {
                    namespace ssl {
                        class Provider extends sun.security.ssl.SunJSSE {
                            public constructor()
                            public constructor(arg0: java.security.Provider)
                            public constructor(arg0: java.lang.String | string)
                            public static isFIPS(): boolean
                            public static install(): void
                            public static class: java.lang.Class<any>
                        }
                        abstract class X509ExtendedTrustManager implements javax.net.ssl.X509TrustManager {
                            protected constructor()
                            public checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public static class: java.lang.Class<any>
                        }
                    }
                    namespace www {
                        namespace protocol {
                            namespace https {
                                class DelegateHttpsURLConnection extends sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection {
                                    public httpsURLConnection: com.sun.net.ssl.HttpsURLConnection
                                    protected getSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                                    protected getHostnameVerifier(): javax.net.ssl.HostnameVerifier
                                    protected dispose(): void
                                    public static class: java.lang.Class<any>
                                }
                                class Handler extends sun.net.www.protocol.https.Handler {
                                    public constructor()
                                    public constructor(arg0: java.lang.String | string, arg1: int)
                                    protected openConnection(arg0: java.net.URL): java.net.URLConnection
                                    protected openConnection(arg0: java.net.URL, arg1: java.net.Proxy): java.net.URLConnection
                                    public static class: java.lang.Class<any>
                                }
                                class HttpsURLConnectionOldImpl extends com.sun.net.ssl.HttpsURLConnection {
                                    protected setNewClient(arg0: java.net.URL): void
                                    protected setNewClient(arg0: java.net.URL, arg1: boolean): void
                                    protected setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int): void
                                    protected setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): void
                                    public connect(): void
                                    protected isConnected(): boolean
                                    protected setConnected(arg0: boolean): void
                                    public getCipherSuite(): string
                                    public getLocalCertificates(): java.security.cert.Certificate[]
                                    public getServerCertificates(): java.security.cert.Certificate[]
                                    public getServerCertificateChain(): javax.security.cert.X509Certificate[]
                                    public getOutputStream(): java.io.OutputStream
                                    public getInputStream(): java.io.InputStream
                                    public getErrorStream(): java.io.InputStream
                                    public disconnect(): void
                                    public usingProxy(): boolean
                                    public getHeaderFields(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                                    public getHeaderField(arg0: java.lang.String | string): string
                                    public getHeaderField(arg0: int): string
                                    public getHeaderFieldKey(arg0: int): string
                                    public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                                    public addRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                                    public getResponseCode(): int
                                    public getRequestProperty(arg0: java.lang.String | string): string
                                    public getRequestProperties(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                                    public setInstanceFollowRedirects(arg0: boolean): void
                                    public getInstanceFollowRedirects(): boolean
                                    public setRequestMethod(arg0: java.lang.String | string): void
                                    public getRequestMethod(): string
                                    public getResponseMessage(): string
                                    public getHeaderFieldDate(arg0: java.lang.String | string, arg1: long): long
                                    public getPermission(): java.security.Permission
                                    public getURL(): java.net.URL
                                    public getContentLength(): int
                                    public getContentLengthLong(): long
                                    public getContentType(): string
                                    public getContentEncoding(): string
                                    public getExpiration(): long
                                    public getDate(): long
                                    public getLastModified(): long
                                    public getHeaderFieldInt(arg0: java.lang.String | string, arg1: int): int
                                    public getHeaderFieldLong(arg0: java.lang.String | string, arg1: long): long
                                    public getContent(): java.lang.Object
                                    public getContent(arg0: java.lang.Class[]): java.lang.Object
                                    public toString(): string
                                    public setDoInput(arg0: boolean): void
                                    public getDoInput(): boolean
                                    public setDoOutput(arg0: boolean): void
                                    public getDoOutput(): boolean
                                    public setAllowUserInteraction(arg0: boolean): void
                                    public getAllowUserInteraction(): boolean
                                    public setUseCaches(arg0: boolean): void
                                    public getUseCaches(): boolean
                                    public setIfModifiedSince(arg0: long): void
                                    public getIfModifiedSince(): long
                                    public getDefaultUseCaches(): boolean
                                    public setDefaultUseCaches(arg0: boolean): void
                                    protected finalize(): void
                                    public equals(arg0: java.lang.Object): boolean
                                    public hashCode(): int
                                    public setConnectTimeout(arg0: int): void
                                    public getConnectTimeout(): int
                                    public setReadTimeout(arg0: int): void
                                    public getReadTimeout(): int
                                    public setFixedLengthStreamingMode(arg0: int): void
                                    public setFixedLengthStreamingMode(arg0: long): void
                                    public setChunkedStreamingMode(arg0: int): void
                                    public static class: java.lang.Class<any>
                                }
                            }
                        }
                    }
                }
                interface HostnameVerifier {
                    verify(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
                }
                interface HostnameVerifier$$Lambda {
                    (arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
                }
                abstract class HttpsURLConnection extends java.net.HttpURLConnection {
                    protected hostnameVerifier: com.sun.net.ssl.HostnameVerifier
                    public constructor(arg0: java.net.URL)
                    public getCipherSuite(): string
                    public getServerCertificateChain(): javax.security.cert.X509Certificate[]
                    public static setDefaultHostnameVerifier(arg0: com.sun.net.ssl.HostnameVerifier | com.sun.net.ssl.HostnameVerifier$$Lambda): void
                    public static getDefaultHostnameVerifier(): com.sun.net.ssl.HostnameVerifier
                    public setHostnameVerifier(arg0: com.sun.net.ssl.HostnameVerifier | com.sun.net.ssl.HostnameVerifier$$Lambda): void
                    public getHostnameVerifier(): com.sun.net.ssl.HostnameVerifier
                    public static setDefaultSSLSocketFactory(arg0: javax.net.ssl.SSLSocketFactory): void
                    public static getDefaultSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                    public setSSLSocketFactory(arg0: javax.net.ssl.SSLSocketFactory): void
                    public getSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                    public static class: java.lang.Class<any>
                }
                interface KeyManager {
                }
                class KeyManagerFactory {
                    public static getDefaultAlgorithm(): string
                    protected constructor(arg0: com.sun.net.ssl.KeyManagerFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                    public getAlgorithm(): string
                    public static getInstance(arg0: java.lang.String | string): com.sun.net.ssl.KeyManagerFactory
                    public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): com.sun.net.ssl.KeyManagerFactory
                    public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): com.sun.net.ssl.KeyManagerFactory
                    public getProvider(): java.security.Provider
                    public init(arg0: java.security.KeyStore, arg1: char[]): void
                    public getKeyManagers(): com.sun.net.ssl.KeyManager[]
                    public static class: java.lang.Class<any>
                }
                abstract class KeyManagerFactorySpi {
                    public constructor()
                    protected engineInit(arg0: java.security.KeyStore, arg1: char[]): void
                    protected engineGetKeyManagers(): com.sun.net.ssl.KeyManager[]
                    public static class: java.lang.Class<any>
                }
                class SSLContext {
                    protected constructor(arg0: com.sun.net.ssl.SSLContextSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                    public static getInstance(arg0: java.lang.String | string): com.sun.net.ssl.SSLContext
                    public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): com.sun.net.ssl.SSLContext
                    public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): com.sun.net.ssl.SSLContext
                    public getProtocol(): string
                    public getProvider(): java.security.Provider
                    public init(arg0: com.sun.net.ssl.KeyManager[], arg1: com.sun.net.ssl.TrustManager[], arg2: java.security.SecureRandom): void
                    public getSocketFactory(): javax.net.ssl.SSLSocketFactory
                    public getServerSocketFactory(): javax.net.ssl.SSLServerSocketFactory
                    public static class: java.lang.Class<any>
                }
                abstract class SSLContextSpi {
                    public constructor()
                    protected engineInit(arg0: com.sun.net.ssl.KeyManager[], arg1: com.sun.net.ssl.TrustManager[], arg2: java.security.SecureRandom): void
                    protected engineGetSocketFactory(): javax.net.ssl.SSLSocketFactory
                    protected engineGetServerSocketFactory(): javax.net.ssl.SSLServerSocketFactory
                    public static class: java.lang.Class<any>
                }
                class SSLPermission extends java.security.BasicPermission {
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class SSLSecurity {
                    public static class: java.lang.Class<any>
                }
                interface TrustManager {
                }
                class TrustManagerFactory {
                    public static getDefaultAlgorithm(): string
                    protected constructor(arg0: com.sun.net.ssl.TrustManagerFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                    public getAlgorithm(): string
                    public static getInstance(arg0: java.lang.String | string): com.sun.net.ssl.TrustManagerFactory
                    public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): com.sun.net.ssl.TrustManagerFactory
                    public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): com.sun.net.ssl.TrustManagerFactory
                    public getProvider(): java.security.Provider
                    public init(arg0: java.security.KeyStore): void
                    public getTrustManagers(): com.sun.net.ssl.TrustManager[]
                    public static class: java.lang.Class<any>
                }
                abstract class TrustManagerFactorySpi {
                    public constructor()
                    protected engineInit(arg0: java.security.KeyStore): void
                    protected engineGetTrustManagers(): com.sun.net.ssl.TrustManager[]
                    public static class: java.lang.Class<any>
                }
                interface X509KeyManager extends com.sun.net.ssl.KeyManager {
                    getClientAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                    chooseClientAlias(arg0: java.lang.String | string, arg1: java.security.Principal[]): string
                    getServerAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                    chooseServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[]): string
                    getCertificateChain(arg0: java.lang.String | string): java.security.cert.X509Certificate[]
                    getPrivateKey(arg0: java.lang.String | string): java.security.PrivateKey
                }
                interface X509TrustManager extends com.sun.net.ssl.TrustManager {
                    isClientTrusted(arg0: java.security.cert.X509Certificate[]): boolean
                    isServerTrusted(arg0: java.security.cert.X509Certificate[]): boolean
                    getAcceptedIssuers(): java.security.cert.X509Certificate[]
                }
            }
        }
        namespace security {
            namespace cert {
                namespace internal {
                    namespace x509 {
                        class X509V1CertImpl extends javax.security.cert.X509Certificate implements java.io.Serializable {
                            public constructor()
                            public constructor(arg0: byte[])
                            public constructor(arg0: java.io.InputStream)
                            public getEncoded(): byte[]
                            public verify(arg0: java.security.PublicKey): void
                            public verify(arg0: java.security.PublicKey, arg1: java.lang.String | string): void
                            public checkValidity(): void
                            public checkValidity(arg0: java.util.Date): void
                            public toString(): string
                            public getPublicKey(): java.security.PublicKey
                            public getVersion(): int
                            public getSerialNumber(): java.math.BigInteger
                            public getSubjectDN(): java.security.Principal
                            public getIssuerDN(): java.security.Principal
                            public getNotBefore(): java.util.Date
                            public getNotAfter(): java.util.Date
                            public getSigAlgName(): string
                            public getSigAlgOID(): string
                            public getSigAlgParams(): byte[]
                            public getX509Certificate(): java.security.cert.X509Certificate
                            public static class: java.lang.Class<any>
                        }
                    }
                }
            }
            namespace ntlm {
                class Client extends com.sun.security.ntlm.NTLM {
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: char[])
                    public type1(): byte[]
                    public type3(arg0: byte[], arg1: byte[]): byte[]
                    public getDomain(): string
                    public dispose(): void
                    public debug(arg0: byte[]): void
                    public debug(arg0: java.lang.String | string, arg1: java.lang.Object[]): void
                    public static class: java.lang.Class<any>
                }
                class NTLM {
                    protected constructor(arg0: java.lang.String | string)
                    public debug(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                    public debug(arg0: byte[]): void
                    public static class: java.lang.Class<any>
                }
                class NTLMException extends java.security.GeneralSecurityException {
                    public static PACKET_READ_ERROR: int
                    public static NO_DOMAIN_INFO: int
                    public static USER_UNKNOWN: int
                    public static AUTH_FAILED: int
                    public static BAD_VERSION: int
                    public static PROTOCOL: int
                    public constructor(arg0: int, arg1: java.lang.String | string)
                    public errorCode(): int
                    public static class: java.lang.Class<any>
                }
                abstract class Server extends com.sun.security.ntlm.NTLM {
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                    public type2(arg0: byte[], arg1: byte[]): byte[]
                    public verify(arg0: byte[], arg1: byte[]): java.lang.String[]
                    public getPassword(arg0: java.lang.String | string, arg1: java.lang.String | string): char[]
                    public debug(arg0: byte[]): void
                    public debug(arg0: java.lang.String | string, arg1: java.lang.Object[]): void
                    public static class: java.lang.Class<any>
                }
                class Version extends java.lang.Enum<com.sun.security.ntlm.Version> {
                    public static NTLM: com.sun.security.ntlm.Version
                    public static NTLM2: com.sun.security.ntlm.Version
                    public static NTLMv2: com.sun.security.ntlm.Version
                    public static values(): com.sun.security.ntlm.Version[]
                    public static valueOf(arg0: java.lang.String | string): com.sun.security.ntlm.Version
                    public static class: java.lang.Class<any>
                }
            }
        }
    }
}
declare namespace java {
    namespace io {
        class Bits {
            public static class: java.lang.Class<any>
        }
        class BufferedInputStream extends java.io.FilterInputStream {
            protected buf: byte[]
            protected count: int
            protected pos: int
            protected markpos: int
            protected marklimit: int
            public constructor(arg0: java.io.InputStream)
            public constructor(arg0: java.io.InputStream, arg1: int)
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public mark(arg0: int): void
            public reset(): void
            public markSupported(): boolean
            public close(): void
            public static class: java.lang.Class<any>
        }
        class BufferedOutputStream extends java.io.FilterOutputStream {
            protected buf: byte[]
            protected count: int
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int)
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            public static class: java.lang.Class<any>
        }
        class BufferedReader extends java.io.Reader {
            public constructor(arg0: java.io.Reader, arg1: int)
            public constructor(arg0: java.io.Reader)
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public readLine(): string
            public skip(arg0: long): long
            public ready(): boolean
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public lines(): java.util.stream.Stream<java.lang.String>
            public static class: java.lang.Class<any>
        }
        class BufferedWriter extends java.io.Writer {
            public constructor(arg0: java.io.Writer | java.io.Writer$$Lambda)
            public constructor(arg0: java.io.Writer | java.io.Writer$$Lambda, arg1: int)
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public newLine(): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class ByteArrayInputStream extends java.io.InputStream {
            protected buf: byte[]
            protected pos: int
            protected mark: int
            protected count: int
            public constructor(arg0: byte[])
            public constructor(arg0: byte[], arg1: int, arg2: int)
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class ByteArrayOutputStream extends java.io.OutputStream {
            protected buf: byte[]
            protected count: int
            public constructor()
            public constructor(arg0: int)
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public writeTo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
            public reset(): void
            public toByteArray(): byte[]
            public size(): int
            public toString(): string
            public toString(arg0: java.lang.String | string): string
            public toString(arg0: int): string
            public close(): void
            public static class: java.lang.Class<any>
        }
        class CharArrayReader extends java.io.Reader {
            protected buf: char[]
            protected pos: int
            protected markedPos: int
            protected count: int
            public constructor(arg0: char[])
            public constructor(arg0: char[], arg1: int, arg2: int)
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public ready(): boolean
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class CharArrayWriter extends java.io.Writer {
            protected buf: char[]
            protected count: int
            public constructor()
            public constructor(arg0: int)
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public writeTo(arg0: java.io.Writer | java.io.Writer$$Lambda): void
            public append(arg0: java.lang.CharSequence): java.io.CharArrayWriter
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.CharArrayWriter
            public append(arg0: char): java.io.CharArrayWriter
            public reset(): void
            public toCharArray(): char[]
            public size(): int
            public toString(): string
            public flush(): void
            public close(): void
            public append(arg0: char): java.io.Writer
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.Writer
            public append(arg0: java.lang.CharSequence): java.io.Writer
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        class CharConversionException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface Closeable extends java.lang.AutoCloseable {
            close(): void
        }
        class Console implements java.io.Flushable {
            public writer(): java.io.PrintWriter
            public reader(): java.io.Reader
            public format(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.io.Console
            public printf(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.io.Console
            public readLine(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): string
            public readLine(): string
            public readPassword(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): char[]
            public readPassword(): char[]
            public flush(): void
            public static class: java.lang.Class<any>
        }
        class Console$$Lambda implements java.io.Flushable {
            public (): java.io.PrintWriter
        }
        interface DataInput {
            readFully(arg0: byte[]): void
            readFully(arg0: byte[], arg1: int, arg2: int): void
            skipBytes(arg0: int): int
            readBoolean(): boolean
            readByte(): byte
            readUnsignedByte(): int
            readShort(): short
            readUnsignedShort(): int
            readChar(): char
            readInt(): int
            readLong(): long
            readFloat(): float
            readDouble(): double
            readLine(): string
            readUTF(): string
        }
        class DataInputStream extends java.io.FilterInputStream implements java.io.DataInput {
            public constructor(arg0: java.io.InputStream)
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public readFully(arg0: byte[]): void
            public readFully(arg0: byte[], arg1: int, arg2: int): void
            public skipBytes(arg0: int): int
            public readBoolean(): boolean
            public readByte(): byte
            public readUnsignedByte(): int
            public readShort(): short
            public readUnsignedShort(): int
            public readChar(): char
            public readInt(): int
            public readLong(): long
            public readFloat(): float
            public readDouble(): double
            public readLine(): string
            public readUTF(): string
            public static readUTF(arg0: java.io.DataInput): string
            public static class: java.lang.Class<any>
        }
        interface DataOutput {
            write(arg0: int): void
            write(arg0: byte[]): void
            write(arg0: byte[], arg1: int, arg2: int): void
            writeBoolean(arg0: boolean): void
            writeByte(arg0: int): void
            writeShort(arg0: int): void
            writeChar(arg0: int): void
            writeInt(arg0: int): void
            writeLong(arg0: long): void
            writeFloat(arg0: float): void
            writeDouble(arg0: double): void
            writeBytes(arg0: java.lang.String | string): void
            writeChars(arg0: java.lang.String | string): void
            writeUTF(arg0: java.lang.String | string): void
        }
        class DataOutputStream extends java.io.FilterOutputStream implements java.io.DataOutput {
            protected written: int
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            public writeBoolean(arg0: boolean): void
            public writeByte(arg0: int): void
            public writeShort(arg0: int): void
            public writeChar(arg0: int): void
            public writeInt(arg0: int): void
            public writeLong(arg0: long): void
            public writeFloat(arg0: float): void
            public writeDouble(arg0: double): void
            public writeBytes(arg0: java.lang.String | string): void
            public writeChars(arg0: java.lang.String | string): void
            public writeUTF(arg0: java.lang.String | string): void
            public size(): int
            public static class: java.lang.Class<any>
        }
        class DeleteOnExitHook {
            public static class: java.lang.Class<any>
        }
        class EOFException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class ExpiringCache {
            public static class: java.lang.Class<any>
        }
        interface Externalizable extends java.io.Serializable {
            writeExternal(arg0: java.io.ObjectOutput): void
            readExternal(arg0: java.io.ObjectInput): void
        }
        class File implements java.io.Serializable , java.lang.Comparable<java.io.File> {
            public static separatorChar: char
            public static separator: string
            public static pathSeparatorChar: char
            public static pathSeparator: string
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string)
            public constructor(arg0: java.net.URI)
            public getName(): string
            public getParent(): string
            public getParentFile(): java.io.File
            public getPath(): string
            public isAbsolute(): boolean
            public getAbsolutePath(): string
            public getAbsoluteFile(): java.io.File
            public getCanonicalPath(): string
            public getCanonicalFile(): java.io.File
            public toURL(): java.net.URL
            public toURI(): java.net.URI
            public canRead(): boolean
            public canWrite(): boolean
            public exists(): boolean
            public isDirectory(): boolean
            public isFile(): boolean
            public isHidden(): boolean
            public lastModified(): long
            public length(): long
            public createNewFile(): boolean
            public delete(): boolean
            public deleteOnExit(): void
            public list(): java.lang.String[]
            public list(arg0: java.io.FilenameFilter | java.io.FilenameFilter$$Lambda): java.lang.String[]
            public listFiles(): java.io.File[]
            public listFiles(arg0: java.io.FilenameFilter | java.io.FilenameFilter$$Lambda): java.io.File[]
            public listFiles(arg0: java.io.FileFilter | java.io.FileFilter$$Lambda): java.io.File[]
            public mkdir(): boolean
            public mkdirs(): boolean
            public renameTo(arg0: java.io.File): boolean
            public setLastModified(arg0: long): boolean
            public setReadOnly(): boolean
            public setWritable(arg0: boolean, arg1: boolean): boolean
            public setWritable(arg0: boolean): boolean
            public setReadable(arg0: boolean, arg1: boolean): boolean
            public setReadable(arg0: boolean): boolean
            public setExecutable(arg0: boolean, arg1: boolean): boolean
            public setExecutable(arg0: boolean): boolean
            public canExecute(): boolean
            public static listRoots(): java.io.File[]
            public getTotalSpace(): long
            public getFreeSpace(): long
            public getUsableSpace(): long
            public static createTempFile(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.io.File): java.io.File
            public static createTempFile(arg0: java.lang.String | string, arg1: java.lang.String | string): java.io.File
            public compareTo(arg0: java.io.File): int
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public toPath(): java.nio.file.Path
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class FileDescriptor {
            public static in: java.io.FileDescriptor
            public static out: java.io.FileDescriptor
            public static err: java.io.FileDescriptor
            public constructor()
            public valid(): boolean
            public sync(): void
            public static class: java.lang.Class<any>
        }
        interface FileFilter {
            accept(arg0: java.io.File): boolean
        }
        interface FileFilter$$Lambda {
            (arg0: java.io.File): boolean
        }
        class FileInputStream extends java.io.InputStream {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.FileDescriptor)
            public read(): int
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public close(): void
            public getFD(): java.io.FileDescriptor
            public getChannel(): java.nio.channels.FileChannel
            protected finalize(): void
            public static class: java.lang.Class<any>
        }
        class FileNotFoundException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class FileOutputStream extends java.io.OutputStream {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: boolean)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.File, arg1: boolean)
            public constructor(arg0: java.io.FileDescriptor)
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public close(): void
            public getFD(): java.io.FileDescriptor
            public getChannel(): java.nio.channels.FileChannel
            protected finalize(): void
            public static class: java.lang.Class<any>
        }
        class FilePermission extends java.security.Permission implements java.io.Serializable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        class FileReader extends java.io.InputStreamReader {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.FileDescriptor)
            public static class: java.lang.Class<any>
        }
        abstract class FileSystem {
            public static BA_EXISTS: int
            public static BA_REGULAR: int
            public static BA_DIRECTORY: int
            public static BA_HIDDEN: int
            public static ACCESS_READ: int
            public static ACCESS_WRITE: int
            public static ACCESS_EXECUTE: int
            public static SPACE_TOTAL: int
            public static SPACE_FREE: int
            public static SPACE_USABLE: int
            public getSeparator(): char
            public getPathSeparator(): char
            public normalize(arg0: java.lang.String | string): string
            public prefixLength(arg0: java.lang.String | string): int
            public resolve(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public getDefaultParent(): string
            public fromURIPath(arg0: java.lang.String | string): string
            public isAbsolute(arg0: java.io.File): boolean
            public resolve(arg0: java.io.File): string
            public canonicalize(arg0: java.lang.String | string): string
            public getBooleanAttributes(arg0: java.io.File): int
            public checkAccess(arg0: java.io.File, arg1: int): boolean
            public setPermission(arg0: java.io.File, arg1: int, arg2: boolean, arg3: boolean): boolean
            public getLastModifiedTime(arg0: java.io.File): long
            public getLength(arg0: java.io.File): long
            public createFileExclusively(arg0: java.lang.String | string): boolean
            public delete(arg0: java.io.File): boolean
            public list(arg0: java.io.File): java.lang.String[]
            public createDirectory(arg0: java.io.File): boolean
            public rename(arg0: java.io.File, arg1: java.io.File): boolean
            public setLastModifiedTime(arg0: java.io.File, arg1: long): boolean
            public setReadOnly(arg0: java.io.File): boolean
            public listRoots(): java.io.File[]
            public getSpace(arg0: java.io.File, arg1: int): long
            public compare(arg0: java.io.File, arg1: java.io.File): int
            public hashCode(arg0: java.io.File): int
            public static class: java.lang.Class<any>
        }
        class FileWriter extends java.io.OutputStreamWriter {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: boolean)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.File, arg1: boolean)
            public constructor(arg0: java.io.FileDescriptor)
            public static class: java.lang.Class<any>
        }
        interface FilenameFilter {
            accept(arg0: java.io.File, arg1: java.lang.String | string): boolean
        }
        interface FilenameFilter$$Lambda {
            (arg0: java.io.File, arg1: java.lang.String | string): boolean
        }
        class FilterInputStream extends java.io.InputStream {
            protected in: java.io.InputStream
            protected constructor(arg0: java.io.InputStream)
            public read(): int
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public close(): void
            public mark(arg0: int): void
            public reset(): void
            public markSupported(): boolean
            public static class: java.lang.Class<any>
        }
        class FilterOutputStream extends java.io.OutputStream {
            protected out: java.io.OutputStream
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        abstract class FilterReader extends java.io.Reader {
            protected in: java.io.Reader
            protected constructor(arg0: java.io.Reader)
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public ready(): boolean
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        abstract class FilterWriter extends java.io.Writer {
            protected out: java.io.Writer
            protected constructor(arg0: java.io.Writer | java.io.Writer$$Lambda)
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        interface Flushable {
            flush(): void
        }
        interface Flushable$$Lambda {
            (): void
        }
        class IOError extends java.lang.Error {
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class IOException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        abstract class InputStream implements java.io.Closeable {
            public constructor()
            public read(): int
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public close(): void
            public mark(arg0: int): void
            public reset(): void
            public markSupported(): boolean
            public static class: java.lang.Class<any>
        }
        class InputStreamReader extends java.io.Reader {
            public constructor(arg0: java.io.InputStream)
            public constructor(arg0: java.io.InputStream, arg1: java.lang.String | string)
            public constructor(arg0: java.io.InputStream, arg1: java.nio.charset.Charset)
            public constructor(arg0: java.io.InputStream, arg1: java.nio.charset.CharsetDecoder)
            public getEncoding(): string
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public ready(): boolean
            public close(): void
            public static class: java.lang.Class<any>
        }
        class InterruptedIOException extends java.io.IOException {
            public bytesTransferred: int
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class InvalidClassException extends java.io.ObjectStreamException {
            public classname: string
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class InvalidObjectException extends java.io.ObjectStreamException {
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class LineNumberInputStream extends java.io.FilterInputStream {
            public constructor(arg0: java.io.InputStream)
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public setLineNumber(arg0: int): void
            public getLineNumber(): int
            public available(): int
            public mark(arg0: int): void
            public reset(): void
            public static class: java.lang.Class<any>
        }
        class LineNumberReader extends java.io.BufferedReader {
            public constructor(arg0: java.io.Reader)
            public constructor(arg0: java.io.Reader, arg1: int)
            public setLineNumber(arg0: int): void
            public getLineNumber(): int
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public readLine(): string
            public skip(arg0: long): long
            public mark(arg0: int): void
            public reset(): void
            public static class: java.lang.Class<any>
        }
        class NotActiveException extends java.io.ObjectStreamException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        class NotSerializableException extends java.io.ObjectStreamException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        interface ObjectInput extends java.io.DataInput , java.lang.AutoCloseable {
            readObject(): java.lang.Object
            read(): int
            read(arg0: byte[]): int
            read(arg0: byte[], arg1: int, arg2: int): int
            skip(arg0: long): long
            available(): int
            close(): void
        }
        class ObjectInputStream extends java.io.InputStream implements java.io.ObjectInput , java.io.ObjectStreamConstants {
            public constructor(arg0: java.io.InputStream)
            protected constructor()
            public readObject(): java.lang.Object
            protected readObjectOverride(): java.lang.Object
            public readUnshared(): java.lang.Object
            public defaultReadObject(): void
            public readFields(): java.io.ObjectInputStream$GetField
            public registerValidation(arg0: java.io.ObjectInputValidation | java.io.ObjectInputValidation$$Lambda, arg1: int): void
            protected resolveClass(arg0: java.io.ObjectStreamClass): java.lang.Class<any>
            protected resolveProxyClass(arg0: java.lang.String[]): java.lang.Class<any>
            protected resolveObject(arg0: java.lang.Object): java.lang.Object
            protected enableResolveObject(arg0: boolean): boolean
            protected readStreamHeader(): void
            protected readClassDescriptor(): java.io.ObjectStreamClass
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public available(): int
            public close(): void
            public readBoolean(): boolean
            public readByte(): byte
            public readUnsignedByte(): int
            public readChar(): char
            public readShort(): short
            public readUnsignedShort(): int
            public readInt(): int
            public readLong(): long
            public readFloat(): float
            public readDouble(): double
            public readFully(arg0: byte[]): void
            public readFully(arg0: byte[], arg1: int, arg2: int): void
            public skipBytes(arg0: int): int
            public readLine(): string
            public readUTF(): string
            public static class: java.lang.Class<any>
        }
        interface ObjectInputValidation {
            validateObject(): void
        }
        interface ObjectInputValidation$$Lambda {
            (): void
        }
        interface ObjectOutput extends java.io.DataOutput , java.lang.AutoCloseable {
            writeObject(arg0: java.lang.Object): void
            write(arg0: int): void
            write(arg0: byte[]): void
            write(arg0: byte[], arg1: int, arg2: int): void
            flush(): void
            close(): void
        }
        class ObjectOutputStream extends java.io.OutputStream implements java.io.ObjectOutput , java.io.ObjectStreamConstants {
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            protected constructor()
            public useProtocolVersion(arg0: int): void
            public writeObject(arg0: java.lang.Object): void
            protected writeObjectOverride(arg0: java.lang.Object): void
            public writeUnshared(arg0: java.lang.Object): void
            public defaultWriteObject(): void
            public putFields(): java.io.ObjectOutputStream$PutField
            public writeFields(): void
            public reset(): void
            protected annotateClass(arg0: java.lang.Class<any>): void
            protected annotateProxyClass(arg0: java.lang.Class<any>): void
            protected replaceObject(arg0: java.lang.Object): java.lang.Object
            protected enableReplaceObject(arg0: boolean): boolean
            protected writeStreamHeader(): void
            protected writeClassDescriptor(arg0: java.io.ObjectStreamClass): void
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            protected drain(): void
            public close(): void
            public writeBoolean(arg0: boolean): void
            public writeByte(arg0: int): void
            public writeShort(arg0: int): void
            public writeChar(arg0: int): void
            public writeInt(arg0: int): void
            public writeLong(arg0: long): void
            public writeFloat(arg0: float): void
            public writeDouble(arg0: double): void
            public writeBytes(arg0: java.lang.String | string): void
            public writeChars(arg0: java.lang.String | string): void
            public writeUTF(arg0: java.lang.String | string): void
            public static class: java.lang.Class<any>
        }
        class ObjectStreamClass implements java.io.Serializable {
            public static NO_FIELDS: java.io.ObjectStreamField[]
            public static lookup(arg0: java.lang.Class<any>): java.io.ObjectStreamClass
            public static lookupAny(arg0: java.lang.Class<any>): java.io.ObjectStreamClass
            public getName(): string
            public getSerialVersionUID(): long
            public forClass(): java.lang.Class<any>
            public getFields(): java.io.ObjectStreamField[]
            public getField(arg0: java.lang.String | string): java.io.ObjectStreamField
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface ObjectStreamConstants {
            STREAM_MAGIC: short
            STREAM_VERSION: short
            TC_BASE: byte
            TC_NULL: byte
            TC_REFERENCE: byte
            TC_CLASSDESC: byte
            TC_OBJECT: byte
            TC_STRING: byte
            TC_ARRAY: byte
            TC_CLASS: byte
            TC_BLOCKDATA: byte
            TC_ENDBLOCKDATA: byte
            TC_RESET: byte
            TC_BLOCKDATALONG: byte
            TC_EXCEPTION: byte
            TC_LONGSTRING: byte
            TC_PROXYCLASSDESC: byte
            TC_ENUM: byte
            TC_MAX: byte
            baseWireHandle: int
            SC_WRITE_METHOD: byte
            SC_BLOCK_DATA: byte
            SC_SERIALIZABLE: byte
            SC_EXTERNALIZABLE: byte
            SC_ENUM: byte
            SUBSTITUTION_PERMISSION: java.io.SerializablePermission
            SUBCLASS_IMPLEMENTATION_PERMISSION: java.io.SerializablePermission
            PROTOCOL_VERSION_1: int
            PROTOCOL_VERSION_2: int
        }
        abstract class ObjectStreamException extends java.io.IOException {
            protected constructor(arg0: java.lang.String | string)
            protected constructor()
            public static class: java.lang.Class<any>
        }
        class ObjectStreamField implements java.lang.Comparable<java.lang.Object> {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Class<any>)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: boolean)
            public getName(): string
            public getType(): java.lang.Class<any>
            public getTypeCode(): char
            public getTypeString(): string
            public getOffset(): int
            protected setOffset(arg0: int): void
            public isPrimitive(): boolean
            public isUnshared(): boolean
            public compareTo(arg0: java.lang.Object): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class OptionalDataException extends java.io.ObjectStreamException {
            public length: int
            public eof: boolean
            public static class: java.lang.Class<any>
        }
        abstract class OutputStream implements java.io.Closeable , java.io.Flushable {
            public constructor()
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        abstract class OutputStream$$Lambda implements java.io.Closeable , java.io.Flushable {
            public constructor()
        }
        class OutputStreamWriter extends java.io.Writer {
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.nio.charset.Charset)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.nio.charset.CharsetEncoder)
            public getEncoding(): string
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class PipedInputStream extends java.io.InputStream {
            protected static PIPE_SIZE: int
            protected buffer: byte[]
            protected in: int
            protected out: int
            public constructor(arg0: java.io.PipedOutputStream)
            public constructor(arg0: java.io.PipedOutputStream, arg1: int)
            public constructor()
            public constructor(arg0: int)
            public connect(arg0: java.io.PipedOutputStream): void
            protected receive(arg0: int): void
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public available(): int
            public close(): void
            public static class: java.lang.Class<any>
        }
        class PipedOutputStream extends java.io.OutputStream {
            public constructor(arg0: java.io.PipedInputStream)
            public constructor()
            public connect(arg0: java.io.PipedInputStream): void
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class PipedReader extends java.io.Reader {
            public constructor(arg0: java.io.PipedWriter)
            public constructor(arg0: java.io.PipedWriter, arg1: int)
            public constructor()
            public constructor(arg0: int)
            public connect(arg0: java.io.PipedWriter): void
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public ready(): boolean
            public close(): void
            public static class: java.lang.Class<any>
        }
        class PipedWriter extends java.io.Writer {
            public constructor(arg0: java.io.PipedReader)
            public constructor()
            public connect(arg0: java.io.PipedReader): void
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class PrintStream extends java.io.FilterOutputStream implements java.lang.Appendable , java.io.Closeable {
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean, arg2: java.lang.String | string)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string)
            public flush(): void
            public close(): void
            public checkError(): boolean
            protected setError(): void
            protected clearError(): void
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public print(arg0: boolean): void
            public print(arg0: char): void
            public print(arg0: int): void
            public print(arg0: long): void
            public print(arg0: float): void
            public print(arg0: double): void
            public print(arg0: char[]): void
            public print(arg0: java.lang.String | string): void
            public print(arg0: java.lang.Object): void
            public println(): void
            public println(arg0: boolean): void
            public println(arg0: char): void
            public println(arg0: int): void
            public println(arg0: long): void
            public println(arg0: float): void
            public println(arg0: double): void
            public println(arg0: char[]): void
            public println(arg0: java.lang.String | string): void
            public println(arg0: java.lang.Object): void
            public printf(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.io.PrintStream
            public printf(arg0: java.util.Locale, arg1: java.lang.String | string, ...arg2: java.lang.Object[]): java.io.PrintStream
            public format(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.io.PrintStream
            public format(arg0: java.util.Locale, arg1: java.lang.String | string, ...arg2: java.lang.Object[]): java.io.PrintStream
            public append(arg0: java.lang.CharSequence): java.io.PrintStream
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.PrintStream
            public append(arg0: char): java.io.PrintStream
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        class PrintWriter extends java.io.Writer {
            protected out: java.io.Writer
            public constructor(arg0: java.io.Writer | java.io.Writer$$Lambda)
            public constructor(arg0: java.io.Writer | java.io.Writer$$Lambda, arg1: boolean)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string)
            public flush(): void
            public close(): void
            public checkError(): boolean
            protected setError(): void
            protected clearError(): void
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: char[]): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string): void
            public print(arg0: boolean): void
            public print(arg0: char): void
            public print(arg0: int): void
            public print(arg0: long): void
            public print(arg0: float): void
            public print(arg0: double): void
            public print(arg0: char[]): void
            public print(arg0: java.lang.String | string): void
            public print(arg0: java.lang.Object): void
            public println(): void
            public println(arg0: boolean): void
            public println(arg0: char): void
            public println(arg0: int): void
            public println(arg0: long): void
            public println(arg0: float): void
            public println(arg0: double): void
            public println(arg0: char[]): void
            public println(arg0: java.lang.String | string): void
            public println(arg0: java.lang.Object): void
            public printf(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.io.PrintWriter
            public printf(arg0: java.util.Locale, arg1: java.lang.String | string, ...arg2: java.lang.Object[]): java.io.PrintWriter
            public format(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.io.PrintWriter
            public format(arg0: java.util.Locale, arg1: java.lang.String | string, ...arg2: java.lang.Object[]): java.io.PrintWriter
            public append(arg0: java.lang.CharSequence): java.io.PrintWriter
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.PrintWriter
            public append(arg0: char): java.io.PrintWriter
            public append(arg0: char): java.io.Writer
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.Writer
            public append(arg0: java.lang.CharSequence): java.io.Writer
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        class PushbackInputStream extends java.io.FilterInputStream {
            protected buf: byte[]
            protected pos: int
            public constructor(arg0: java.io.InputStream, arg1: int)
            public constructor(arg0: java.io.InputStream)
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public unread(arg0: int): void
            public unread(arg0: byte[], arg1: int, arg2: int): void
            public unread(arg0: byte[]): void
            public available(): int
            public skip(arg0: long): long
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class PushbackReader extends java.io.FilterReader {
            public constructor(arg0: java.io.Reader, arg1: int)
            public constructor(arg0: java.io.Reader)
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public unread(arg0: int): void
            public unread(arg0: char[], arg1: int, arg2: int): void
            public unread(arg0: char[]): void
            public ready(): boolean
            public mark(arg0: int): void
            public reset(): void
            public markSupported(): boolean
            public close(): void
            public skip(arg0: long): long
            public static class: java.lang.Class<any>
        }
        class RandomAccessFile implements java.io.DataOutput , java.io.DataInput , java.io.Closeable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string)
            public getFD(): java.io.FileDescriptor
            public getChannel(): java.nio.channels.FileChannel
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public read(arg0: byte[]): int
            public readFully(arg0: byte[]): void
            public readFully(arg0: byte[], arg1: int, arg2: int): void
            public skipBytes(arg0: int): int
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public getFilePointer(): long
            public seek(arg0: long): void
            public length(): long
            public setLength(arg0: long): void
            public close(): void
            public readBoolean(): boolean
            public readByte(): byte
            public readUnsignedByte(): int
            public readShort(): short
            public readUnsignedShort(): int
            public readChar(): char
            public readInt(): int
            public readLong(): long
            public readFloat(): float
            public readDouble(): double
            public readLine(): string
            public readUTF(): string
            public writeBoolean(arg0: boolean): void
            public writeByte(arg0: int): void
            public writeShort(arg0: int): void
            public writeChar(arg0: int): void
            public writeInt(arg0: int): void
            public writeLong(arg0: long): void
            public writeFloat(arg0: float): void
            public writeDouble(arg0: double): void
            public writeBytes(arg0: java.lang.String | string): void
            public writeChars(arg0: java.lang.String | string): void
            public writeUTF(arg0: java.lang.String | string): void
            public static class: java.lang.Class<any>
        }
        abstract class Reader implements java.lang.Readable , java.io.Closeable {
            protected lock: java.lang.Object
            protected constructor()
            protected constructor(arg0: java.lang.Object)
            public read(arg0: java.nio.CharBuffer): int
            public read(): int
            public read(arg0: char[]): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public ready(): boolean
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class SequenceInputStream extends java.io.InputStream {
            public constructor(arg0: java.util.Enumeration<java.io.InputStream>)
            public constructor(arg0: java.io.InputStream, arg1: java.io.InputStream)
            public available(): int
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public close(): void
            public static class: java.lang.Class<any>
        }
        class SerialCallbackContext {
            public constructor(arg0: java.lang.Object, arg1: java.io.ObjectStreamClass)
            public getObj(): java.lang.Object
            public getDesc(): java.io.ObjectStreamClass
            public check(): void
            public setUsed(): void
            public static class: java.lang.Class<any>
        }
        interface Serializable {
        }
        class SerializablePermission extends java.security.BasicPermission {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class StreamCorruptedException extends java.io.ObjectStreamException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        class StreamTokenizer {
            public ttype: int
            public static TT_EOF: int
            public static TT_EOL: int
            public static TT_NUMBER: int
            public static TT_WORD: int
            public sval: string
            public nval: double
            public constructor(arg0: java.io.InputStream)
            public constructor(arg0: java.io.Reader)
            public resetSyntax(): void
            public wordChars(arg0: int, arg1: int): void
            public whitespaceChars(arg0: int, arg1: int): void
            public ordinaryChars(arg0: int, arg1: int): void
            public ordinaryChar(arg0: int): void
            public commentChar(arg0: int): void
            public quoteChar(arg0: int): void
            public parseNumbers(): void
            public eolIsSignificant(arg0: boolean): void
            public slashStarComments(arg0: boolean): void
            public slashSlashComments(arg0: boolean): void
            public lowerCaseMode(arg0: boolean): void
            public nextToken(): int
            public pushBack(): void
            public lineno(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class StringBufferInputStream extends java.io.InputStream {
            protected buffer: string
            protected pos: int
            protected count: int
            public constructor(arg0: java.lang.String | string)
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public reset(): void
            public static class: java.lang.Class<any>
        }
        class StringReader extends java.io.Reader {
            public constructor(arg0: java.lang.String | string)
            public read(): int
            public read(arg0: char[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public ready(): boolean
            public markSupported(): boolean
            public mark(arg0: int): void
            public reset(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        class StringWriter extends java.io.Writer {
            public constructor()
            public constructor(arg0: int)
            public write(arg0: int): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public append(arg0: java.lang.CharSequence): java.io.StringWriter
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.StringWriter
            public append(arg0: char): java.io.StringWriter
            public toString(): string
            public getBuffer(): java.lang.StringBuffer
            public flush(): void
            public close(): void
            public append(arg0: char): java.io.Writer
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.Writer
            public append(arg0: java.lang.CharSequence): java.io.Writer
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        class SyncFailedException extends java.io.IOException {
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UTFDataFormatException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UncheckedIOException extends java.lang.RuntimeException {
            public constructor(arg0: java.lang.String | string, arg1: java.io.IOException)
            public constructor(arg0: java.io.IOException)
            public getCause(): java.io.IOException
            public getCause(): java.lang.Throwable
            public static class: java.lang.Class<any>
        }
        class UnsupportedEncodingException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class WriteAbortedException extends java.io.ObjectStreamException {
            public detail: java.lang.Exception
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Exception)
            public getMessage(): string
            public getCause(): java.lang.Throwable
            public static class: java.lang.Class<any>
        }
        abstract class Writer implements java.lang.Appendable , java.io.Closeable , java.io.Flushable {
            protected lock: java.lang.Object
            protected constructor()
            protected constructor(arg0: java.lang.Object)
            public write(arg0: int): void
            public write(arg0: char[]): void
            public write(arg0: char[], arg1: int, arg2: int): void
            public write(arg0: java.lang.String | string): void
            public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
            public append(arg0: java.lang.CharSequence): java.io.Writer
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.io.Writer
            public append(arg0: char): java.io.Writer
            public flush(): void
            public close(): void
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        abstract class Writer$$Lambda implements java.lang.Appendable , java.io.Closeable , java.io.Flushable {
            protected lock: java.lang.Object
        }
    }
    namespace lang {
        namespace annotation {
            interface Annotation {
                equals(arg0: java.lang.Object): boolean
                hashCode(): int
                toString(): string
                annotationType(): java.lang.Class<java.lang.annotation.Annotation>
            }
            class AnnotationFormatError extends java.lang.Error {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class AnnotationTypeMismatchException extends java.lang.RuntimeException {
                public constructor(arg0: java.lang.reflect.Method, arg1: java.lang.String | string)
                public element(): java.lang.reflect.Method
                public foundType(): string
                public static class: java.lang.Class<any>
            }
            interface Documented extends java.lang.annotation.Annotation {
            }
            class ElementType extends java.lang.Enum<java.lang.annotation.ElementType> {
                public static TYPE: java.lang.annotation.ElementType
                public static FIELD: java.lang.annotation.ElementType
                public static METHOD: java.lang.annotation.ElementType
                public static PARAMETER: java.lang.annotation.ElementType
                public static CONSTRUCTOR: java.lang.annotation.ElementType
                public static LOCAL_VARIABLE: java.lang.annotation.ElementType
                public static ANNOTATION_TYPE: java.lang.annotation.ElementType
                public static PACKAGE: java.lang.annotation.ElementType
                public static TYPE_PARAMETER: java.lang.annotation.ElementType
                public static TYPE_USE: java.lang.annotation.ElementType
                public static values(): java.lang.annotation.ElementType[]
                public static valueOf(arg0: java.lang.String | string): java.lang.annotation.ElementType
                public static class: java.lang.Class<any>
            }
            class IncompleteAnnotationException extends java.lang.RuntimeException {
                public constructor(arg0: java.lang.Class<java.lang.annotation.Annotation>, arg1: java.lang.String | string)
                public annotationType(): java.lang.Class<java.lang.annotation.Annotation>
                public elementName(): string
                public static class: java.lang.Class<any>
            }
            interface Inherited extends java.lang.annotation.Annotation {
            }
            interface Native extends java.lang.annotation.Annotation {
            }
            interface Repeatable extends java.lang.annotation.Annotation {
                value(): java.lang.Class<java.lang.annotation.Annotation>
            }
            interface Retention extends java.lang.annotation.Annotation {
                value(): java.lang.annotation.RetentionPolicy
            }
            class RetentionPolicy extends java.lang.Enum<java.lang.annotation.RetentionPolicy> {
                public static SOURCE: java.lang.annotation.RetentionPolicy
                public static CLASS: java.lang.annotation.RetentionPolicy
                public static RUNTIME: java.lang.annotation.RetentionPolicy
                public static values(): java.lang.annotation.RetentionPolicy[]
                public static valueOf(arg0: java.lang.String | string): java.lang.annotation.RetentionPolicy
                public static class: java.lang.Class<any>
            }
            interface Target extends java.lang.annotation.Annotation {
                value(): java.lang.annotation.ElementType[]
            }
        }
        namespace invoke {
            abstract class AbstractValidatingLambdaMetafactory {
                public static class: java.lang.Class<any>
            }
            abstract class BoundMethodHandle extends java.lang.invoke.MethodHandle {
                public static class: java.lang.Class<any>
            }
            abstract class CallSite {
                public type(): java.lang.invoke.MethodType
                public getTarget(): java.lang.invoke.MethodHandle
                public setTarget(arg0: java.lang.invoke.MethodHandle): void
                public dynamicInvoker(): java.lang.invoke.MethodHandle
                public static class: java.lang.Class<any>
            }
            class ConstantCallSite extends java.lang.invoke.CallSite {
                public constructor(arg0: java.lang.invoke.MethodHandle)
                protected constructor(arg0: java.lang.invoke.MethodType, arg1: java.lang.invoke.MethodHandle)
                public dynamicInvoker(): java.lang.invoke.MethodHandle
                public getTarget(): java.lang.invoke.MethodHandle
                public setTarget(arg0: java.lang.invoke.MethodHandle): void
                public static class: java.lang.Class<any>
            }
            abstract class DelegatingMethodHandle extends java.lang.invoke.MethodHandle {
                protected constructor(arg0: java.lang.invoke.MethodHandle)
                protected constructor(arg0: java.lang.invoke.MethodType, arg1: java.lang.invoke.MethodHandle)
                protected constructor(arg0: java.lang.invoke.MethodType, arg1: java.lang.invoke.LambdaForm)
                public static class: java.lang.Class<any>
            }
            interface InjectedProfile extends java.lang.annotation.Annotation {
            }
            class InnerClassLambdaMetafactory extends java.lang.invoke.AbstractValidatingLambdaMetafactory {
                public constructor(arg0: java.lang.invoke.MethodHandles$Lookup, arg1: java.lang.invoke.MethodType, arg2: java.lang.String | string, arg3: java.lang.invoke.MethodType, arg4: java.lang.invoke.MethodHandle, arg5: java.lang.invoke.MethodType, arg6: boolean, arg7: java.lang.Class<any>[], arg8: java.lang.invoke.MethodType[])
                public static class: java.lang.Class<any>
            }
            class InvokeDynamic {
                public static class: java.lang.Class<any>
            }
            class InvokerBytecodeGenerator {
                public static class: java.lang.Class<any>
            }
            class LambdaConversionException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: boolean, arg3: boolean)
                public static class: java.lang.Class<any>
            }
            class LambdaForm {
                public static class: java.lang.Class<any>
            }
            class LambdaFormEditor {
                public static class: java.lang.Class<any>
            }
            class LambdaMetafactory {
                public static FLAG_SERIALIZABLE: int
                public static FLAG_MARKERS: int
                public static FLAG_BRIDGES: int
                public constructor()
                public static metafactory(arg0: java.lang.invoke.MethodHandles$Lookup, arg1: java.lang.String | string, arg2: java.lang.invoke.MethodType, arg3: java.lang.invoke.MethodType, arg4: java.lang.invoke.MethodHandle, arg5: java.lang.invoke.MethodType): java.lang.invoke.CallSite
                public static altMetafactory(arg0: java.lang.invoke.MethodHandles$Lookup, arg1: java.lang.String | string, arg2: java.lang.invoke.MethodType, ...arg3: java.lang.Object[]): java.lang.invoke.CallSite
                public static class: java.lang.Class<any>
            }
            class MemberName {
                public isVarargs(): boolean
                public isMethodHandleInvoke(): boolean
                public getName(): string
                public getInvocationType(): java.lang.invoke.MethodType
                public getReturnType(): java.lang.Class<any>
                public isNative(): boolean
                public static class: java.lang.Class<any>
            }
            abstract class MethodHandle {
                public invokeExact(...arg0: java.lang.Object[]): java.lang.Object
                public invoke(...arg0: java.lang.Object[]): java.lang.Object
                public type(): java.lang.invoke.MethodType
                public asSpreader(arg0: java.lang.Class<any>, arg1: int): java.lang.invoke.MethodHandle
                public asCollector(arg0: java.lang.Class<any>, arg1: int): java.lang.invoke.MethodHandle
                public asType(arg0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle
                public invokeWithArguments(...arg0: java.lang.Object[]): java.lang.Object
                public invokeWithArguments(arg0: java.util.List<any>): java.lang.Object
                public asVarargsCollector(arg0: java.lang.Class<any>): java.lang.invoke.MethodHandle
                public isVarargsCollector(): boolean
                public asFixedArity(): java.lang.invoke.MethodHandle
                public bindTo(arg0: java.lang.Object): java.lang.invoke.MethodHandle
                public toString(): string
                public static class: java.lang.Class<any>
            }
            abstract class MethodHandleImpl {
                public static class: java.lang.Class<any>
            }
            interface MethodHandleInfo {
                REF_getField: int
                REF_getStatic: int
                REF_putField: int
                REF_putStatic: int
                REF_invokeVirtual: int
                REF_invokeStatic: int
                REF_invokeSpecial: int
                REF_newInvokeSpecial: int
                REF_invokeInterface: int
                getDeclaringClass(): java.lang.Class<any>
                getName(): string
                getMethodType(): java.lang.invoke.MethodType
                getModifiers(): int
                getReferenceKind(): int
                isVarArgs(): boolean
                reflectAs<T extends java.lang.reflect.Member>(arg0: java.lang.Class<T>, arg1: java.lang.invoke.MethodHandles$Lookup): T
                referenceKindToString(arg0: int): string
                toString(arg0: int, arg1: java.lang.Class<any>, arg2: java.lang.String | string, arg3: java.lang.invoke.MethodType): string
            }
            class MethodHandleProxies {
                public static asInterfaceInstance<T>(arg0: java.lang.Class<T>, arg1: java.lang.invoke.MethodHandle): T
                public static isWrapperInstance(arg0: java.lang.Object): boolean
                public static wrapperInstanceTarget(arg0: java.lang.Object): java.lang.invoke.MethodHandle
                public static wrapperInstanceType(arg0: java.lang.Object): java.lang.Class<any>
                public static class: java.lang.Class<any>
            }
            class MethodHandleStatics {
                public static class: java.lang.Class<any>
            }
            class MethodHandles {
                public static lookup(): java.lang.invoke.MethodHandles$Lookup
                public static publicLookup(): java.lang.invoke.MethodHandles$Lookup
                public static reflectAs<T extends java.lang.reflect.Member>(arg0: java.lang.Class<T>, arg1: java.lang.invoke.MethodHandle): T
                public static exactInvoker(arg0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle
                public static invoker(arg0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle
                public static spreadInvoker(arg0: java.lang.invoke.MethodType, arg1: int): java.lang.invoke.MethodHandle
                public static guardWithTest(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.invoke.MethodHandle, arg2: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle
                public static catchException(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.Class<java.lang.Throwable>, arg2: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle
                public static identity(arg0: java.lang.Class<any>): java.lang.invoke.MethodHandle
                public static constant(arg0: java.lang.Class<any>, arg1: java.lang.Object): java.lang.invoke.MethodHandle
                public static arrayElementGetter(arg0: java.lang.Class<any>): java.lang.invoke.MethodHandle
                public static arrayElementSetter(arg0: java.lang.Class<any>): java.lang.invoke.MethodHandle
                public static throwException(arg0: java.lang.Class<any>, arg1: java.lang.Class<java.lang.Throwable>): java.lang.invoke.MethodHandle
                public static filterReturnValue(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle
                public static filterArguments(arg0: java.lang.invoke.MethodHandle, arg1: int, ...arg2: java.lang.invoke.MethodHandle[]): java.lang.invoke.MethodHandle
                public static foldArguments(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle
                public static permuteArguments(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.invoke.MethodType, ...arg2: int[]): java.lang.invoke.MethodHandle
                public static collectArguments(arg0: java.lang.invoke.MethodHandle, arg1: int, arg2: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle
                public static dropArguments(arg0: java.lang.invoke.MethodHandle, arg1: int, ...arg2: java.lang.Class<any>[]): java.lang.invoke.MethodHandle
                public static dropArguments(arg0: java.lang.invoke.MethodHandle, arg1: int, arg2: java.util.List<java.lang.Class<any>>): java.lang.invoke.MethodHandle
                public static explicitCastArguments(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle
                public static insertArguments(arg0: java.lang.invoke.MethodHandle, arg1: int, ...arg2: java.lang.Object[]): java.lang.invoke.MethodHandle
                public static class: java.lang.Class<any>
            }
            class MethodType implements java.io.Serializable {
                public changeParameterType(arg0: int, arg1: java.lang.Class<any>): java.lang.invoke.MethodType
                public changeReturnType(arg0: java.lang.Class<any>): java.lang.invoke.MethodType
                public dropParameterTypes(arg0: int, arg1: int): java.lang.invoke.MethodType
                public equals(arg0: java.lang.Object): boolean
                public erase(): java.lang.invoke.MethodType
                public static fromMethodDescriptorString(arg0: java.lang.String | string, arg1: java.lang.ClassLoader): java.lang.invoke.MethodType
                public generic(): java.lang.invoke.MethodType
                public hashCode(): int
                public hasPrimitives(): boolean
                public hasWrappers(): boolean
                public insertParameterTypes(arg0: int, ...arg1: java.lang.Class<any>[]): java.lang.invoke.MethodType
                public insertParameterTypes(arg0: int, arg1: java.util.List<java.lang.Class<any>>): java.lang.invoke.MethodType
                public static methodType(arg0: java.lang.Class<any>): java.lang.invoke.MethodType
                public static methodType(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): java.lang.invoke.MethodType
                public static methodType(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>[]): java.lang.invoke.MethodType
                public static methodType(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>, ...arg2: java.lang.Class<any>[]): java.lang.invoke.MethodType
                public static methodType(arg0: java.lang.Class<any>, arg1: java.util.List<java.lang.Class<any>>): java.lang.invoke.MethodType
                public static methodType(arg0: java.lang.Class<any>, arg1: java.lang.invoke.MethodType): java.lang.invoke.MethodType
                public static genericMethodType(arg0: int): java.lang.invoke.MethodType
                public static genericMethodType(arg0: int, arg1: boolean): java.lang.invoke.MethodType
                public parameterArray(): java.lang.Class<any>[]
                public parameterCount(): int
                public parameterList(): java.util.List<java.lang.Class<any>>
                public parameterType(arg0: int): java.lang.Class<any>
                public returnType(): java.lang.Class<any>
                public toMethodDescriptorString(): string
                public toString(): string
                public unwrap(): java.lang.invoke.MethodType
                public wrap(): java.lang.invoke.MethodType
                public appendParameterTypes(...arg0: java.lang.Class<any>[]): java.lang.invoke.MethodType
                public appendParameterTypes(arg0: java.util.List<java.lang.Class<any>>): java.lang.invoke.MethodType
                public static class: java.lang.Class<any>
            }
            class MethodTypeForm {
                public cachedLambdaForm(arg0: int): java.lang.invoke.LambdaForm
                public setCachedLambdaForm(arg0: int, arg1: java.lang.invoke.LambdaForm): java.lang.invoke.LambdaForm
                public static class: java.lang.Class<any>
            }
            class MutableCallSite extends java.lang.invoke.CallSite {
                public constructor(arg0: java.lang.invoke.MethodHandle)
                public constructor(arg0: java.lang.invoke.MethodType)
                public dynamicInvoker(): java.lang.invoke.MethodHandle
                public getTarget(): java.lang.invoke.MethodHandle
                public setTarget(arg0: java.lang.invoke.MethodHandle): void
                public static syncAll(arg0: java.lang.invoke.MutableCallSite[]): void
                public static class: java.lang.Class<any>
            }
            class ProxyClassesDumper {
                public static getInstance(arg0: java.lang.String | string): java.lang.invoke.ProxyClassesDumper
                public static encodeForFilename(arg0: java.lang.String | string): string
                public dumpClass(arg0: java.lang.String | string, arg1: byte[]): void
                public static class: java.lang.Class<any>
            }
            class SerializedLambda implements java.io.Serializable {
                public constructor(arg0: java.lang.Class<any>, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: int, arg5: java.lang.String | string, arg6: java.lang.String | string, arg7: java.lang.String | string, arg8: java.lang.String | string, arg9: java.lang.Object[])
                public getCapturingClass(): string
                public getFunctionalInterfaceClass(): string
                public getFunctionalInterfaceMethodName(): string
                public getFunctionalInterfaceMethodSignature(): string
                public getImplClass(): string
                public getImplMethodName(): string
                public getImplMethodSignature(): string
                public getImplMethodKind(): int
                public getInstantiatedMethodType(): string
                public getCapturedArgCount(): int
                public getCapturedArg(arg0: int): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SimpleMethodHandle extends java.lang.invoke.BoundMethodHandle {
                public static class: java.lang.Class<any>
            }
            class SwitchPoint {
                public constructor()
                public hasBeenInvalidated(): boolean
                public guardWithTest(arg0: java.lang.invoke.MethodHandle, arg1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle
                public static invalidateAll(arg0: java.lang.invoke.SwitchPoint[]): void
                public static class: java.lang.Class<any>
            }
            class TypeConvertingMethodAdapter extends jdk.internal.org.objectweb.asm.MethodVisitor {
                public static class: java.lang.Class<any>
            }
            class VolatileCallSite extends java.lang.invoke.CallSite {
                public constructor(arg0: java.lang.invoke.MethodHandle)
                public constructor(arg0: java.lang.invoke.MethodType)
                public dynamicInvoker(): java.lang.invoke.MethodHandle
                public getTarget(): java.lang.invoke.MethodHandle
                public setTarget(arg0: java.lang.invoke.MethodHandle): void
                public static class: java.lang.Class<any>
            }
            class WrongMethodTypeException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
        }
        namespace ref {
            class FinalReference<T> extends java.lang.ref.Reference<T> {
                public constructor(arg0: T, arg1: java.lang.ref.ReferenceQueue<T>)
                public static class: java.lang.Class<any>
            }
            class Finalizer {
                public static class: java.lang.Class<any>
            }
            class PhantomReference<T> extends java.lang.ref.Reference<T> {
                public get(): T
                public constructor(arg0: T, arg1: java.lang.ref.ReferenceQueue<T>)
                public static class: java.lang.Class<any>
            }
            abstract class Reference<T> {
                public clear(): void
                public enqueue(): boolean
                public get(): T
                public isEnqueued(): boolean
                public static class: java.lang.Class<any>
            }
            class ReferenceQueue<T> {
                public poll(): java.lang.ref.Reference<T>
                public remove(): java.lang.ref.Reference<T>
                public remove(arg0: long): java.lang.ref.Reference<T>
                public constructor()
                public static class: java.lang.Class<any>
            }
            class SoftReference<T> extends java.lang.ref.Reference<T> {
                public constructor(arg0: T, arg1: java.lang.ref.ReferenceQueue<T>)
                public constructor(arg0: T)
                public get(): T
                public static class: java.lang.Class<any>
            }
            class WeakReference<T> extends java.lang.ref.Reference<T> {
                public constructor(arg0: T, arg1: java.lang.ref.ReferenceQueue<T>)
                public constructor(arg0: T)
                public static class: java.lang.Class<any>
            }
        }
        namespace reflect {
            class AccessibleObject implements java.lang.reflect.AnnotatedElement {
                public static setAccessible(arg0: java.lang.reflect.AccessibleObject[], arg1: boolean): void
                public setAccessible(arg0: boolean): void
                public isAccessible(): boolean
                protected constructor()
                public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public isAnnotationPresent<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<java.lang.annotation.Annotation>): boolean
                public getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                public getAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public static class: java.lang.Class<any>
            }
            interface AnnotatedArrayType extends java.lang.reflect.AnnotatedType {
                getAnnotatedGenericComponentType(): java.lang.reflect.AnnotatedType
            }
            interface AnnotatedElement {
                isAnnotationPresent(arg0: java.lang.Class<java.lang.annotation.Annotation>): boolean
                getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                getAnnotations(): java.lang.annotation.Annotation[]
                getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
            }
            interface AnnotatedParameterizedType extends java.lang.reflect.AnnotatedType {
                getAnnotatedActualTypeArguments(): java.lang.reflect.AnnotatedType[]
            }
            interface AnnotatedType extends java.lang.reflect.AnnotatedElement {
                getType(): java.lang.reflect.Type
            }
            interface AnnotatedTypeVariable extends java.lang.reflect.AnnotatedType {
                getAnnotatedBounds(): java.lang.reflect.AnnotatedType[]
            }
            interface AnnotatedWildcardType extends java.lang.reflect.AnnotatedType {
                getAnnotatedLowerBounds(): java.lang.reflect.AnnotatedType[]
                getAnnotatedUpperBounds(): java.lang.reflect.AnnotatedType[]
            }
            class Array {
                public static get(arg0: java.lang.Object, arg1: int): java.lang.Object
                public static getBoolean(arg0: java.lang.Object, arg1: int): boolean
                public static getByte(arg0: java.lang.Object, arg1: int): byte
                public static getChar(arg0: java.lang.Object, arg1: int): char
                public static getDouble(arg0: java.lang.Object, arg1: int): double
                public static getFloat(arg0: java.lang.Object, arg1: int): float
                public static getInt(arg0: java.lang.Object, arg1: int): int
                public static getLength(arg0: java.lang.Object): int
                public static getLong(arg0: java.lang.Object, arg1: int): long
                public static getShort(arg0: java.lang.Object, arg1: int): short
                public static newInstance(arg0: java.lang.Class<any>, ...arg1: int[]): java.lang.Object
                public static newInstance(arg0: java.lang.Class<any>, arg1: int): java.lang.Object
                public static set(arg0: java.lang.Object, arg1: int, arg2: java.lang.Object): void
                public static setBoolean(arg0: java.lang.Object, arg1: int, arg2: boolean): void
                public static setByte(arg0: java.lang.Object, arg1: int, arg2: byte): void
                public static setChar(arg0: java.lang.Object, arg1: int, arg2: char): void
                public static setDouble(arg0: java.lang.Object, arg1: int, arg2: double): void
                public static setFloat(arg0: java.lang.Object, arg1: int, arg2: float): void
                public static setInt(arg0: java.lang.Object, arg1: int, arg2: int): void
                public static setLong(arg0: java.lang.Object, arg1: int, arg2: long): void
                public static setShort(arg0: java.lang.Object, arg1: int, arg2: short): void
                public static class: java.lang.Class<any>
            }
            class Constructor<T> extends java.lang.reflect.Executable {
                public getDeclaringClass(): java.lang.Class<T>
                public getName(): string
                public getModifiers(): int
                public getTypeParameters(): java.lang.reflect.TypeVariable<java.lang.reflect.Constructor<T>>[]
                public getParameterTypes(): java.lang.Class<any>[]
                public getParameterCount(): int
                public getGenericParameterTypes(): java.lang.reflect.Type[]
                public getExceptionTypes(): java.lang.Class<any>[]
                public getGenericExceptionTypes(): java.lang.reflect.Type[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public toGenericString(): string
                public newInstance(...arg0: java.lang.Object[]): T
                public isVarArgs(): boolean
                public isSynthetic(): boolean
                public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public getParameterAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[][]
                public getAnnotatedReturnType<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
                public getAnnotatedReceiverType<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
                public static class: java.lang.Class<any>
            }
            abstract class Executable extends java.lang.reflect.AccessibleObject implements java.lang.reflect.Member , java.lang.reflect.GenericDeclaration {
                public getDeclaringClass(): java.lang.Class<any>
                public getName(): string
                public getModifiers(): int
                public getTypeParameters(): java.lang.reflect.TypeVariable<any>[]
                public getParameterTypes(): java.lang.Class<any>[]
                public getParameterCount(): int
                public getGenericParameterTypes(): java.lang.reflect.Type[]
                public getParameters(): java.lang.reflect.Parameter[]
                public getExceptionTypes(): java.lang.Class<any>[]
                public getGenericExceptionTypes(): java.lang.reflect.Type[]
                public toGenericString(): string
                public isVarArgs(): boolean
                public isSynthetic(): boolean
                public getParameterAnnotations(): java.lang.annotation.Annotation[][]
                public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public getAnnotatedReturnType<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
                public getAnnotatedReceiverType<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
                public getAnnotatedParameterTypes<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType[]
                public getAnnotatedExceptionTypes<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType[]
                public static class: java.lang.Class<any>
            }
            class Field extends java.lang.reflect.AccessibleObject implements java.lang.reflect.Member {
                public getDeclaringClass(): java.lang.Class<any>
                public getName(): string
                public getModifiers(): int
                public isEnumConstant(): boolean
                public isSynthetic(): boolean
                public getType(): java.lang.Class<any>
                public getGenericType(): java.lang.reflect.Type
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public toGenericString(): string
                public get(arg0: java.lang.Object): java.lang.Object
                public getBoolean(arg0: java.lang.Object): boolean
                public getByte(arg0: java.lang.Object): byte
                public getChar(arg0: java.lang.Object): char
                public getShort(arg0: java.lang.Object): short
                public getInt(arg0: java.lang.Object): int
                public getLong(arg0: java.lang.Object): long
                public getFloat(arg0: java.lang.Object): float
                public getDouble(arg0: java.lang.Object): double
                public set(arg0: java.lang.Object, arg1: java.lang.Object): void
                public setBoolean(arg0: java.lang.Object, arg1: boolean): void
                public setByte(arg0: java.lang.Object, arg1: byte): void
                public setChar(arg0: java.lang.Object, arg1: char): void
                public setShort(arg0: java.lang.Object, arg1: short): void
                public setInt(arg0: java.lang.Object, arg1: int): void
                public setLong(arg0: java.lang.Object, arg1: long): void
                public setFloat(arg0: java.lang.Object, arg1: float): void
                public setDouble(arg0: java.lang.Object, arg1: double): void
                public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public getAnnotatedType<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
                public static class: java.lang.Class<any>
            }
            interface GenericArrayType extends java.lang.reflect.Type {
                getGenericComponentType(): java.lang.reflect.Type
            }
            interface GenericDeclaration extends java.lang.reflect.AnnotatedElement {
                getTypeParameters(): java.lang.reflect.TypeVariable<any>[]
            }
            class GenericSignatureFormatError extends java.lang.ClassFormatError {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface InvocationHandler {
                invoke(arg0: java.lang.Object, arg1: java.lang.reflect.Method, arg2: java.lang.Object[]): java.lang.Object
            }
            interface InvocationHandler$$Lambda {
                (arg0: java.lang.Object, arg1: java.lang.reflect.Method, arg2: java.lang.Object[]): java.lang.Object
            }
            class InvocationTargetException extends java.lang.ReflectiveOperationException {
                protected constructor()
                public constructor(arg0: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable, arg1: java.lang.String | string)
                public getTargetException(): java.lang.Throwable
                public getCause(): java.lang.Throwable
                public static class: java.lang.Class<any>
            }
            class MalformedParameterizedTypeException extends java.lang.RuntimeException {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class MalformedParametersException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface Member {
                PUBLIC: int
                DECLARED: int
                getDeclaringClass(): java.lang.Class<any>
                getName(): string
                getModifiers(): int
                isSynthetic(): boolean
            }
            class Method extends java.lang.reflect.Executable {
                public getDeclaringClass(): java.lang.Class<any>
                public getName(): string
                public getModifiers(): int
                public getTypeParameters(): java.lang.reflect.TypeVariable<java.lang.reflect.Method>[]
                public getReturnType(): java.lang.Class<any>
                public getGenericReturnType(): java.lang.reflect.Type
                public getParameterTypes(): java.lang.Class<any>[]
                public getParameterCount(): int
                public getGenericParameterTypes(): java.lang.reflect.Type[]
                public getExceptionTypes(): java.lang.Class<any>[]
                public getGenericExceptionTypes(): java.lang.reflect.Type[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public toGenericString(): string
                public invoke(arg0: java.lang.Object, ...arg1: java.lang.Object[]): java.lang.Object
                public isBridge(): boolean
                public isVarArgs(): boolean
                public isSynthetic(): boolean
                public isDefault(): boolean
                public getDefaultValue(): java.lang.Object
                public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public getParameterAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[][]
                public getAnnotatedReturnType<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
                public static class: java.lang.Class<any>
            }
            class Modifier {
                public static PUBLIC: int
                public static PRIVATE: int
                public static PROTECTED: int
                public static STATIC: int
                public static FINAL: int
                public static SYNCHRONIZED: int
                public static VOLATILE: int
                public static TRANSIENT: int
                public static NATIVE: int
                public static INTERFACE: int
                public static ABSTRACT: int
                public static STRICT: int
                public constructor()
                public static isPublic(arg0: int): boolean
                public static isPrivate(arg0: int): boolean
                public static isProtected(arg0: int): boolean
                public static isStatic(arg0: int): boolean
                public static isFinal(arg0: int): boolean
                public static isSynchronized(arg0: int): boolean
                public static isVolatile(arg0: int): boolean
                public static isTransient(arg0: int): boolean
                public static isNative(arg0: int): boolean
                public static isInterface(arg0: int): boolean
                public static isAbstract(arg0: int): boolean
                public static isStrict(arg0: int): boolean
                public static toString(arg0: int): string
                public static classModifiers(): int
                public static interfaceModifiers(): int
                public static constructorModifiers(): int
                public static methodModifiers(): int
                public static fieldModifiers(): int
                public static parameterModifiers(): int
                public static class: java.lang.Class<any>
            }
            class Parameter implements java.lang.reflect.AnnotatedElement {
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public isNamePresent(): boolean
                public toString(): string
                public getDeclaringExecutable(): java.lang.reflect.Executable
                public getModifiers(): int
                public getName(): string
                public getParameterizedType(): java.lang.reflect.Type
                public getType(): java.lang.Class<any>
                public getAnnotatedType(): java.lang.reflect.AnnotatedType
                public isImplicit(): boolean
                public isSynthetic(): boolean
                public isVarArgs(): boolean
                public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                public getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                public getAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                public static class: java.lang.Class<any>
            }
            interface ParameterizedType extends java.lang.reflect.Type {
                getActualTypeArguments(): java.lang.reflect.Type[]
                getRawType(): java.lang.reflect.Type
                getOwnerType(): java.lang.reflect.Type
            }
            class Proxy implements java.io.Serializable {
                protected h: java.lang.reflect.InvocationHandler
                protected constructor(arg0: java.lang.reflect.InvocationHandler | java.lang.reflect.InvocationHandler$$Lambda)
                public static getProxyClass(arg0: java.lang.ClassLoader, ...arg1: java.lang.Class<any>[]): java.lang.Class<any>
                public static newProxyInstance(arg0: java.lang.ClassLoader, arg1: java.lang.Class<any>[], arg2: java.lang.reflect.InvocationHandler | java.lang.reflect.InvocationHandler$$Lambda): java.lang.Object
                public static isProxyClass(arg0: java.lang.Class<any>): boolean
                public static getInvocationHandler(arg0: java.lang.Object): java.lang.reflect.InvocationHandler
                public static class: java.lang.Class<any>
            }
            class ReflectAccess implements sun.reflect.LangReflectAccess {
                public newField(arg0: java.lang.Class<any>, arg1: java.lang.String | string, arg2: java.lang.Class<any>, arg3: int, arg4: int, arg5: java.lang.String | string, arg6: byte[]): java.lang.reflect.Field
                public newMethod(arg0: java.lang.Class<any>, arg1: java.lang.String | string, arg2: java.lang.Class<any>[], arg3: java.lang.Class<any>, arg4: java.lang.Class<any>[], arg5: int, arg6: int, arg7: java.lang.String | string, arg8: byte[], arg9: byte[], arg10: byte[]): java.lang.reflect.Method
                public newConstructor<T>(arg0: java.lang.Class<T>, arg1: java.lang.Class<any>[], arg2: java.lang.Class<any>[], arg3: int, arg4: int, arg5: java.lang.String | string, arg6: byte[], arg7: byte[]): java.lang.reflect.Constructor<T>
                public getMethodAccessor<T>(arg0: java.lang.reflect.Method): sun.reflect.MethodAccessor
                public setMethodAccessor<T>(arg0: java.lang.reflect.Method, arg1: sun.reflect.MethodAccessor): void
                public getConstructorAccessor<T>(arg0: java.lang.reflect.Constructor<any>): sun.reflect.ConstructorAccessor
                public setConstructorAccessor<T>(arg0: java.lang.reflect.Constructor<any>, arg1: sun.reflect.ConstructorAccessor): void
                public getConstructorSlot<T>(arg0: java.lang.reflect.Constructor<any>): int
                public getConstructorSignature<T>(arg0: java.lang.reflect.Constructor<any>): string
                public getConstructorAnnotations<T>(arg0: java.lang.reflect.Constructor<any>): byte[]
                public getConstructorParameterAnnotations<T>(arg0: java.lang.reflect.Constructor<any>): byte[]
                public getExecutableTypeAnnotationBytes<T>(arg0: java.lang.reflect.Executable): byte[]
                public copyMethod<T>(arg0: java.lang.reflect.Method): java.lang.reflect.Method
                public copyField<T>(arg0: java.lang.reflect.Field): java.lang.reflect.Field
                public copyConstructor<T>(arg0: java.lang.reflect.Constructor<T>): java.lang.reflect.Constructor<T>
                public static class: java.lang.Class<any>
            }
            class ReflectPermission extends java.security.BasicPermission {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface Type {
                getTypeName(): string
            }
            interface Type$$Lambda {
                (): string
            }
            interface TypeVariable<D extends java.lang.reflect.GenericDeclaration> extends java.lang.reflect.Type , java.lang.reflect.AnnotatedElement {
                getBounds(): java.lang.reflect.Type[]
                getGenericDeclaration(): D
                getName(): string
                getAnnotatedBounds(): java.lang.reflect.AnnotatedType[]
            }
            class UndeclaredThrowableException extends java.lang.RuntimeException {
                public constructor(arg0: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable, arg1: java.lang.String | string)
                public getUndeclaredThrowable(): java.lang.Throwable
                public getCause(): java.lang.Throwable
                public static class: java.lang.Class<any>
            }
            interface WildcardType extends java.lang.reflect.Type {
                getUpperBounds(): java.lang.reflect.Type[]
                getLowerBounds(): java.lang.reflect.Type[]
            }
        }
        class AbstractMethodError extends java.lang.IncompatibleClassChangeError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        abstract class AbstractStringBuilder {
            public static class: java.lang.Class<any>
        }
        interface Appendable {
            append(arg0: java.lang.CharSequence): java.lang.Appendable
            append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            append(arg0: char): java.lang.Appendable
        }
        class ApplicationShutdownHooks {
            public static class: java.lang.Class<any>
        }
        class ArithmeticException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class ArrayIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class ArrayStoreException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class AssertionError extends java.lang.Error {
            public constructor()
            public constructor(arg0: java.lang.Object)
            public constructor(arg0: boolean)
            public constructor(arg0: char)
            public constructor(arg0: int)
            public constructor(arg0: long)
            public constructor(arg0: float)
            public constructor(arg0: double)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class AssertionStatusDirectives {
            public static class: java.lang.Class<any>
        }
        interface AutoCloseable {
            close(): void
        }
        interface AutoCloseable$$Lambda {
            (): void
        }
        class Boolean implements java.io.Serializable , java.lang.Comparable<java.lang.Boolean> {
            public static TRUE: boolean
            public static FALSE: boolean
            public static TYPE: java.lang.Class<java.lang.Boolean>
            public constructor(arg0: boolean)
            public constructor(arg0: java.lang.String | string)
            public static parseBoolean(arg0: java.lang.String | string): boolean
            public booleanValue(): boolean
            public static valueOf(arg0: boolean): boolean
            public static valueOf(arg0: java.lang.String | string): boolean
            public static toString(arg0: boolean): string
            public toString(): string
            public hashCode(): int
            public static hashCode(arg0: boolean): int
            public equals(arg0: java.lang.Object): boolean
            public static getBoolean(arg0: java.lang.String | string): boolean
            public compareTo(arg0: java.lang.Boolean | boolean): int
            public static compare(arg0: boolean, arg1: boolean): int
            public static logicalAnd(arg0: boolean, arg1: boolean): boolean
            public static logicalOr(arg0: boolean, arg1: boolean): boolean
            public static logicalXor(arg0: boolean, arg1: boolean): boolean
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class BootstrapMethodError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class Byte extends java.lang.Number implements java.lang.Comparable<java.lang.Byte> {
            public static MIN_VALUE: byte
            public static MAX_VALUE: byte
            public static TYPE: java.lang.Class<java.lang.Byte>
            public static SIZE: int
            public static BYTES: int
            public static toString(arg0: byte): string
            public static valueOf(arg0: byte): java.lang.Byte
            public static parseByte(arg0: java.lang.String | string, arg1: int): byte
            public static parseByte(arg0: java.lang.String | string): byte
            public static valueOf(arg0: java.lang.String | string, arg1: int): java.lang.Byte
            public static valueOf(arg0: java.lang.String | string): java.lang.Byte
            public static decode(arg0: java.lang.String | string): java.lang.Byte
            public constructor(arg0: byte)
            public constructor(arg0: java.lang.String | string)
            public byteValue(): byte
            public shortValue(): short
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public toString(): string
            public hashCode(): int
            public static hashCode(arg0: byte): int
            public equals(arg0: java.lang.Object): boolean
            public compareTo(arg0: java.lang.Byte): int
            public static compare(arg0: byte, arg1: byte): int
            public static toUnsignedInt(arg0: byte): int
            public static toUnsignedLong(arg0: byte): long
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        interface CharSequence {
            length(): int
            charAt(arg0: int): char
            subSequence(arg0: int, arg1: int): java.lang.CharSequence
            toString(): string
            chars(): java.util.stream.IntStream
            codePoints(): java.util.stream.IntStream
        }
        class Character implements java.io.Serializable , java.lang.Comparable<java.lang.Character> {
            public static MIN_RADIX: int
            public static MAX_RADIX: int
            public static MIN_VALUE: char
            public static MAX_VALUE: char
            public static TYPE: java.lang.Class<java.lang.Character>
            public static UNASSIGNED: byte
            public static UPPERCASE_LETTER: byte
            public static LOWERCASE_LETTER: byte
            public static TITLECASE_LETTER: byte
            public static MODIFIER_LETTER: byte
            public static OTHER_LETTER: byte
            public static NON_SPACING_MARK: byte
            public static ENCLOSING_MARK: byte
            public static COMBINING_SPACING_MARK: byte
            public static DECIMAL_DIGIT_NUMBER: byte
            public static LETTER_NUMBER: byte
            public static OTHER_NUMBER: byte
            public static SPACE_SEPARATOR: byte
            public static LINE_SEPARATOR: byte
            public static PARAGRAPH_SEPARATOR: byte
            public static CONTROL: byte
            public static FORMAT: byte
            public static PRIVATE_USE: byte
            public static SURROGATE: byte
            public static DASH_PUNCTUATION: byte
            public static START_PUNCTUATION: byte
            public static END_PUNCTUATION: byte
            public static CONNECTOR_PUNCTUATION: byte
            public static OTHER_PUNCTUATION: byte
            public static MATH_SYMBOL: byte
            public static CURRENCY_SYMBOL: byte
            public static MODIFIER_SYMBOL: byte
            public static OTHER_SYMBOL: byte
            public static INITIAL_QUOTE_PUNCTUATION: byte
            public static FINAL_QUOTE_PUNCTUATION: byte
            public static DIRECTIONALITY_UNDEFINED: byte
            public static DIRECTIONALITY_LEFT_TO_RIGHT: byte
            public static DIRECTIONALITY_RIGHT_TO_LEFT: byte
            public static DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC: byte
            public static DIRECTIONALITY_EUROPEAN_NUMBER: byte
            public static DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR: byte
            public static DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR: byte
            public static DIRECTIONALITY_ARABIC_NUMBER: byte
            public static DIRECTIONALITY_COMMON_NUMBER_SEPARATOR: byte
            public static DIRECTIONALITY_NONSPACING_MARK: byte
            public static DIRECTIONALITY_BOUNDARY_NEUTRAL: byte
            public static DIRECTIONALITY_PARAGRAPH_SEPARATOR: byte
            public static DIRECTIONALITY_SEGMENT_SEPARATOR: byte
            public static DIRECTIONALITY_WHITESPACE: byte
            public static DIRECTIONALITY_OTHER_NEUTRALS: byte
            public static DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING: byte
            public static DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE: byte
            public static DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING: byte
            public static DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE: byte
            public static DIRECTIONALITY_POP_DIRECTIONAL_FORMAT: byte
            public static MIN_HIGH_SURROGATE: char
            public static MAX_HIGH_SURROGATE: char
            public static MIN_LOW_SURROGATE: char
            public static MAX_LOW_SURROGATE: char
            public static MIN_SURROGATE: char
            public static MAX_SURROGATE: char
            public static MIN_SUPPLEMENTARY_CODE_POINT: int
            public static MIN_CODE_POINT: int
            public static MAX_CODE_POINT: int
            public static SIZE: int
            public static BYTES: int
            public constructor(arg0: char)
            public static valueOf(arg0: char): java.lang.Character
            public charValue(): char
            public hashCode(): int
            public static hashCode(arg0: char): int
            public equals(arg0: java.lang.Object): boolean
            public toString(): string
            public static toString(arg0: char): string
            public static isValidCodePoint(arg0: int): boolean
            public static isBmpCodePoint(arg0: int): boolean
            public static isSupplementaryCodePoint(arg0: int): boolean
            public static isHighSurrogate(arg0: char): boolean
            public static isLowSurrogate(arg0: char): boolean
            public static isSurrogate(arg0: char): boolean
            public static isSurrogatePair(arg0: char, arg1: char): boolean
            public static charCount(arg0: int): int
            public static toCodePoint(arg0: char, arg1: char): int
            public static codePointAt(arg0: java.lang.CharSequence, arg1: int): int
            public static codePointAt(arg0: char[], arg1: int): int
            public static codePointAt(arg0: char[], arg1: int, arg2: int): int
            public static codePointBefore(arg0: java.lang.CharSequence, arg1: int): int
            public static codePointBefore(arg0: char[], arg1: int): int
            public static codePointBefore(arg0: char[], arg1: int, arg2: int): int
            public static highSurrogate(arg0: int): char
            public static lowSurrogate(arg0: int): char
            public static toChars(arg0: int, arg1: char[], arg2: int): int
            public static toChars(arg0: int): char[]
            public static codePointCount(arg0: java.lang.CharSequence, arg1: int, arg2: int): int
            public static codePointCount(arg0: char[], arg1: int, arg2: int): int
            public static offsetByCodePoints(arg0: java.lang.CharSequence, arg1: int, arg2: int): int
            public static offsetByCodePoints(arg0: char[], arg1: int, arg2: int, arg3: int, arg4: int): int
            public static isLowerCase(arg0: char): boolean
            public static isLowerCase(arg0: int): boolean
            public static isUpperCase(arg0: char): boolean
            public static isUpperCase(arg0: int): boolean
            public static isTitleCase(arg0: char): boolean
            public static isTitleCase(arg0: int): boolean
            public static isDigit(arg0: char): boolean
            public static isDigit(arg0: int): boolean
            public static isDefined(arg0: char): boolean
            public static isDefined(arg0: int): boolean
            public static isLetter(arg0: char): boolean
            public static isLetter(arg0: int): boolean
            public static isLetterOrDigit(arg0: char): boolean
            public static isLetterOrDigit(arg0: int): boolean
            public static isJavaLetter(arg0: char): boolean
            public static isJavaLetterOrDigit(arg0: char): boolean
            public static isAlphabetic(arg0: int): boolean
            public static isIdeographic(arg0: int): boolean
            public static isJavaIdentifierStart(arg0: char): boolean
            public static isJavaIdentifierStart(arg0: int): boolean
            public static isJavaIdentifierPart(arg0: char): boolean
            public static isJavaIdentifierPart(arg0: int): boolean
            public static isUnicodeIdentifierStart(arg0: char): boolean
            public static isUnicodeIdentifierStart(arg0: int): boolean
            public static isUnicodeIdentifierPart(arg0: char): boolean
            public static isUnicodeIdentifierPart(arg0: int): boolean
            public static isIdentifierIgnorable(arg0: char): boolean
            public static isIdentifierIgnorable(arg0: int): boolean
            public static toLowerCase(arg0: char): char
            public static toLowerCase(arg0: int): int
            public static toUpperCase(arg0: char): char
            public static toUpperCase(arg0: int): int
            public static toTitleCase(arg0: char): char
            public static toTitleCase(arg0: int): int
            public static digit(arg0: char, arg1: int): int
            public static digit(arg0: int, arg1: int): int
            public static getNumericValue(arg0: char): int
            public static getNumericValue(arg0: int): int
            public static isSpace(arg0: char): boolean
            public static isSpaceChar(arg0: char): boolean
            public static isSpaceChar(arg0: int): boolean
            public static isWhitespace(arg0: char): boolean
            public static isWhitespace(arg0: int): boolean
            public static isISOControl(arg0: char): boolean
            public static isISOControl(arg0: int): boolean
            public static getType(arg0: char): int
            public static getType(arg0: int): int
            public static forDigit(arg0: int, arg1: int): char
            public static getDirectionality(arg0: char): byte
            public static getDirectionality(arg0: int): byte
            public static isMirrored(arg0: char): boolean
            public static isMirrored(arg0: int): boolean
            public compareTo(arg0: java.lang.Character): int
            public static compare(arg0: char, arg1: char): int
            public static reverseBytes(arg0: char): char
            public static getName(arg0: int): string
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        abstract class CharacterData {
            public static class: java.lang.Class<any>
        }
        class CharacterName {
            public static get(arg0: int): string
            public static class: java.lang.Class<any>
        }
        class Class<T> implements java.io.Serializable , java.lang.reflect.GenericDeclaration , java.lang.reflect.Type {
            public static forName(arg0: java.lang.String | string): java.lang.Class<any>
            public static forName(arg0: java.lang.String | string, arg1: boolean, arg2: java.lang.ClassLoader): java.lang.Class<any>
            public getClasses(): java.lang.Class<any>[]
            public getClassLoader(): java.lang.ClassLoader
            public getComponentType(): java.lang.Class<any>
            public getConstructor(...arg0: java.lang.Class<any>[]): java.lang.reflect.Constructor<T>
            public getConstructors(): java.lang.reflect.Constructor<any>[]
            public getDeclaredClasses(): java.lang.Class<any>[]
            public getDeclaredConstructor(...arg0: java.lang.Class<any>[]): java.lang.reflect.Constructor<T>
            public getDeclaredConstructors(): java.lang.reflect.Constructor<any>[]
            public getDeclaredField(arg0: java.lang.String | string): java.lang.reflect.Field
            public getDeclaredFields(): java.lang.reflect.Field[]
            public getDeclaredMethod(arg0: java.lang.String | string, ...arg1: java.lang.Class<any>[]): java.lang.reflect.Method
            public getDeclaredMethods(): java.lang.reflect.Method[]
            public getDeclaringClass(): java.lang.Class<any>
            public getField(arg0: java.lang.String | string): java.lang.reflect.Field
            public getFields(): java.lang.reflect.Field[]
            public getInterfaces(): java.lang.Class<any>[]
            public getMethod(arg0: java.lang.String | string, ...arg1: java.lang.Class<any>[]): java.lang.reflect.Method
            public getMethods(): java.lang.reflect.Method[]
            public getModifiers(): int
            public getName(): string
            public getProtectionDomain(): java.security.ProtectionDomain
            public getResource(arg0: java.lang.String | string): java.net.URL
            public getResourceAsStream(arg0: java.lang.String | string): java.io.InputStream
            public getSigners(): java.lang.Object[]
            public getSuperclass(): java.lang.Class<T>
            public isArray(): boolean
            public isAssignableFrom(arg0: java.lang.Class<any>): boolean
            public isInstance(arg0: java.lang.Object): boolean
            public isInterface(): boolean
            public isPrimitive(): boolean
            public newInstance(): T
            public toString(): string
            public toGenericString(): string
            public getPackage(): java.lang.Package
            public desiredAssertionStatus(): boolean
            public getAnnotation<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A
            public getAnnotations<A extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
            public getDeclaredAnnotation<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A
            public getAnnotatedInterfaces<A extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType[]
            public getAnnotatedSuperclass<A extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType
            public getTypeName<A extends java.lang.annotation.Annotation>(): string
            public getDeclaredAnnotations<A extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
            public getDeclaredAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A[]
            public getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A[]
            public isAnnotation<A extends java.lang.annotation.Annotation>(): boolean
            public isAnnotationPresent<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<java.lang.annotation.Annotation>): boolean
            public asSubclass<U>(arg0: java.lang.Class<U>): java.lang.Class<U>
            public cast<U>(arg0: java.lang.Object): T
            public isEnum<U>(): boolean
            public getEnumConstants<U>(): T[]
            public isSynthetic<U>(): boolean
            public getTypeParameters<U>(): java.lang.reflect.TypeVariable<java.lang.Class<T>>[]
            public getGenericInterfaces<U>(): java.lang.reflect.Type[]
            public getGenericSuperclass<U>(): java.lang.reflect.Type
            public getEnclosingConstructor<U>(): java.lang.reflect.Constructor<any>
            public getEnclosingMethod<U>(): java.lang.reflect.Method
            public getEnclosingClass<U>(): java.lang.Class<any>
            public getSimpleName<U>(): string
            public getCanonicalName<U>(): string
            public isAnonymousClass<U>(): boolean
            public isLocalClass<U>(): boolean
            public isMemberClass<U>(): boolean
            public static class: java.lang.Class<any>
        }
        class Class$$Lambda<T> implements java.io.Serializable , java.lang.reflect.GenericDeclaration , java.lang.reflect.Type {
            public static (arg0: java.lang.String | string): java.lang.Class<any>
        }
        class ClassCastException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class ClassCircularityError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class ClassFormatError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        abstract class ClassLoader {
            protected constructor()
            protected constructor(arg0: java.lang.ClassLoader)
            protected defineClass(arg0: byte[], arg1: int, arg2: int): java.lang.Class<any>
            protected defineClass(arg0: java.lang.String | string, arg1: byte[], arg2: int, arg3: int): java.lang.Class<any>
            protected defineClass(arg0: java.lang.String | string, arg1: byte[], arg2: int, arg3: int, arg4: java.security.ProtectionDomain): java.lang.Class<any>
            protected findClass(arg0: java.lang.String | string): java.lang.Class<any>
            protected findLoadedClass(arg0: java.lang.String | string): java.lang.Class<any>
            protected findSystemClass(arg0: java.lang.String | string): java.lang.Class<any>
            public getParent(): java.lang.ClassLoader
            public getResource(arg0: java.lang.String | string): java.net.URL
            public getResources(arg0: java.lang.String | string): java.util.Enumeration<java.net.URL>
            public getResourceAsStream(arg0: java.lang.String | string): java.io.InputStream
            public static getSystemClassLoader(): java.lang.ClassLoader
            public static getSystemResource(arg0: java.lang.String | string): java.net.URL
            public static getSystemResources(arg0: java.lang.String | string): java.util.Enumeration<java.net.URL>
            public static getSystemResourceAsStream(arg0: java.lang.String | string): java.io.InputStream
            public loadClass(arg0: java.lang.String | string): java.lang.Class<any>
            protected loadClass(arg0: java.lang.String | string, arg1: boolean): java.lang.Class<any>
            protected static registerAsParallelCapable(): boolean
            protected getClassLoadingLock(arg0: java.lang.String | string): java.lang.Object
            protected resolveClass(arg0: java.lang.Class<any>): void
            protected findResource(arg0: java.lang.String | string): java.net.URL
            protected findResources(arg0: java.lang.String | string): java.util.Enumeration<java.net.URL>
            protected findLibrary(arg0: java.lang.String | string): string
            protected getPackage(arg0: java.lang.String | string): java.lang.Package
            protected getPackages(): java.lang.Package[]
            protected definePackage(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String | string, arg6: java.lang.String | string, arg7: java.net.URL): java.lang.Package
            protected setSigners(arg0: java.lang.Class<any>, arg1: java.lang.Object[]): void
            public setClassAssertionStatus(arg0: java.lang.String | string, arg1: boolean): void
            public setPackageAssertionStatus(arg0: java.lang.String | string, arg1: boolean): void
            public setDefaultAssertionStatus(arg0: boolean): void
            public clearAssertionStatus(): void
            protected defineClass(arg0: java.lang.String | string, arg1: java.nio.ByteBuffer, arg2: java.security.ProtectionDomain): java.lang.Class<any>
            protected clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class ClassNotFoundException extends java.lang.ReflectiveOperationException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public getException(): java.lang.Throwable
            public getCause(): java.lang.Throwable
            public static class: java.lang.Class<any>
        }
        abstract class ClassValue<T> {
            protected constructor()
            protected computeValue(arg0: java.lang.Class<any>): T
            public get(arg0: java.lang.Class<any>): T
            public remove(arg0: java.lang.Class<any>): void
            public static class: java.lang.Class<any>
        }
        class CloneNotSupportedException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface Cloneable {
        }
        interface Comparable<T> {
            compareTo(arg0: T): int
        }
        interface Comparable$$Lambda<T> {
            (arg0: T): int
        }
        class Compiler {
            public static command(arg0: java.lang.Object): java.lang.Object
            public static compileClass(arg0: java.lang.Class<any>): boolean
            public static compileClasses(arg0: java.lang.String | string): boolean
            public static disable(): void
            public static enable(): void
            public static class: java.lang.Class<any>
        }
        class ConditionalSpecialCasing {
            public static class: java.lang.Class<any>
        }
        interface Deprecated extends java.lang.annotation.Annotation {
        }
        class Double extends java.lang.Number implements java.lang.Comparable<java.lang.Double> {
            public static POSITIVE_INFINITY: double
            public static NEGATIVE_INFINITY: double
            public static NaN: double
            public static MAX_VALUE: double
            public static MIN_NORMAL: double
            public static MIN_VALUE: double
            public static MAX_EXPONENT: int
            public static MIN_EXPONENT: int
            public static SIZE: int
            public static BYTES: int
            public static TYPE: java.lang.Class<java.lang.Double>
            public static toString(arg0: double): string
            public static toHexString(arg0: double): string
            public static valueOf(arg0: java.lang.String | string): java.lang.Double
            public static valueOf(arg0: double): java.lang.Double
            public static parseDouble(arg0: java.lang.String | string): double
            public static isNaN(arg0: double): boolean
            public static isInfinite(arg0: double): boolean
            public static isFinite(arg0: double): boolean
            public constructor(arg0: double)
            public constructor(arg0: java.lang.String | string)
            public isNaN(): boolean
            public isInfinite(): boolean
            public toString(): string
            public byteValue(): byte
            public shortValue(): short
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public hashCode(): int
            public static hashCode(arg0: double): int
            public equals(arg0: java.lang.Object): boolean
            public static doubleToLongBits(arg0: double): long
            public static doubleToRawLongBits(arg0: double): long
            public static longBitsToDouble(arg0: long): double
            public compareTo(arg0: java.lang.Double): int
            public static compare(arg0: double, arg1: double): int
            public static sum(arg0: double, arg1: double): double
            public static max(arg0: double, arg1: double): double
            public static min(arg0: double, arg1: double): double
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        abstract class Enum<E extends java.lang.Enum<E>> implements java.lang.Comparable<E> , java.io.Serializable {
            public name(): string
            public ordinal(): int
            protected constructor(arg0: java.lang.String | string, arg1: int)
            public toString(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            protected clone(): java.lang.Object
            public compareTo(arg0: E): int
            public getDeclaringClass(): java.lang.Class<E>
            public static valueOf<T extends java.lang.Enum<T>>(arg0: java.lang.Class<T>, arg1: java.lang.String | string): T
            protected finalize(): void
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class EnumConstantNotPresentException extends java.lang.RuntimeException {
            public constructor(arg0: java.lang.Class<java.lang.Enum>, arg1: java.lang.String | string)
            public enumType(): java.lang.Class<java.lang.Enum>
            public constantName(): string
            public static class: java.lang.Class<any>
        }
        class Error extends java.lang.Throwable {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            protected constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: boolean, arg3: boolean)
            public static class: java.lang.Class<any>
        }
        class Exception extends java.lang.Throwable {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            protected constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: boolean, arg3: boolean)
            public static class: java.lang.Class<any>
        }
        class ExceptionInInitializerError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.Throwable)
            public constructor(arg0: java.lang.String | string)
            public getException(): java.lang.Throwable
            public getCause(): java.lang.Throwable
            public static class: java.lang.Class<any>
        }
        class Float extends java.lang.Number implements java.lang.Comparable<java.lang.Float> {
            public static POSITIVE_INFINITY: float
            public static NEGATIVE_INFINITY: float
            public static NaN: float
            public static MAX_VALUE: float
            public static MIN_NORMAL: float
            public static MIN_VALUE: float
            public static MAX_EXPONENT: int
            public static MIN_EXPONENT: int
            public static SIZE: int
            public static BYTES: int
            public static TYPE: java.lang.Class<java.lang.Float>
            public static toString(arg0: float): string
            public static toHexString(arg0: float): string
            public static valueOf(arg0: java.lang.String | string): java.lang.Float
            public static valueOf(arg0: float): java.lang.Float
            public static parseFloat(arg0: java.lang.String | string): float
            public static isNaN(arg0: float): boolean
            public static isInfinite(arg0: float): boolean
            public static isFinite(arg0: float): boolean
            public constructor(arg0: float)
            public constructor(arg0: double)
            public constructor(arg0: java.lang.String | string)
            public isNaN(): boolean
            public isInfinite(): boolean
            public toString(): string
            public byteValue(): byte
            public shortValue(): short
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public hashCode(): int
            public static hashCode(arg0: float): int
            public equals(arg0: java.lang.Object): boolean
            public static floatToIntBits(arg0: float): int
            public static floatToRawIntBits(arg0: float): int
            public static intBitsToFloat(arg0: int): float
            public compareTo(arg0: java.lang.Float): int
            public static compare(arg0: float, arg1: float): int
            public static sum(arg0: float, arg1: float): float
            public static max(arg0: float, arg1: float): float
            public static min(arg0: float, arg1: float): float
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        interface FunctionalInterface extends java.lang.annotation.Annotation {
        }
        class IllegalAccessError extends java.lang.IncompatibleClassChangeError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class IllegalAccessException extends java.lang.ReflectiveOperationException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class IllegalArgumentException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class IllegalMonitorStateException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class IllegalStateException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class IllegalThreadStateException extends java.lang.IllegalArgumentException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class IncompatibleClassChangeError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class IndexOutOfBoundsException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class InheritableThreadLocal<T> extends java.lang.ThreadLocal<T> {
            public constructor()
            protected childValue(arg0: T): T
            public static class: java.lang.Class<any>
        }
        class InstantiationError extends java.lang.IncompatibleClassChangeError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class InstantiationException extends java.lang.ReflectiveOperationException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class Integer extends java.lang.Number implements java.lang.Comparable<java.lang.Integer> {
            public static MIN_VALUE: int
            public static MAX_VALUE: int
            public static TYPE: java.lang.Class<java.lang.Integer>
            public static SIZE: int
            public static BYTES: int
            public static toString(arg0: int, arg1: int): string
            public static toUnsignedString(arg0: int, arg1: int): string
            public static toHexString(arg0: int): string
            public static toOctalString(arg0: int): string
            public static toBinaryString(arg0: int): string
            public static toString(arg0: int): string
            public static toUnsignedString(arg0: int): string
            public static parseInt(arg0: java.lang.String | string, arg1: int): int
            public static parseInt(arg0: java.lang.String | string): int
            public static parseUnsignedInt(arg0: java.lang.String | string, arg1: int): int
            public static parseUnsignedInt(arg0: java.lang.String | string): int
            public static valueOf(arg0: java.lang.String | string, arg1: int): java.lang.Integer
            public static valueOf(arg0: java.lang.String | string): java.lang.Integer
            public static valueOf(arg0: int): java.lang.Integer
            public constructor(arg0: int)
            public constructor(arg0: java.lang.String | string)
            public byteValue(): byte
            public shortValue(): short
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public toString(): string
            public hashCode(): int
            public static hashCode(arg0: int): int
            public equals(arg0: java.lang.Object): boolean
            public static getInteger(arg0: java.lang.String | string): java.lang.Integer
            public static getInteger(arg0: java.lang.String | string, arg1: int): java.lang.Integer
            public static getInteger(arg0: java.lang.String | string, arg1: java.lang.Integer): java.lang.Integer
            public static decode(arg0: java.lang.String | string): java.lang.Integer
            public compareTo(arg0: java.lang.Integer): int
            public static compare(arg0: int, arg1: int): int
            public static compareUnsigned(arg0: int, arg1: int): int
            public static toUnsignedLong(arg0: int): long
            public static divideUnsigned(arg0: int, arg1: int): int
            public static remainderUnsigned(arg0: int, arg1: int): int
            public static highestOneBit(arg0: int): int
            public static lowestOneBit(arg0: int): int
            public static numberOfLeadingZeros(arg0: int): int
            public static numberOfTrailingZeros(arg0: int): int
            public static bitCount(arg0: int): int
            public static rotateLeft(arg0: int, arg1: int): int
            public static rotateRight(arg0: int, arg1: int): int
            public static reverse(arg0: int): int
            public static signum(arg0: int): int
            public static reverseBytes(arg0: int): int
            public static sum(arg0: int, arg1: int): int
            public static max(arg0: int, arg1: int): int
            public static min(arg0: int, arg1: int): int
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class InternalError extends java.lang.VirtualMachineError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class InterruptedException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface Iterable<T> {
            iterator(): java.util.Iterator<T>
            forEach(arg0: java.util.function$.Consumer$$TypeScript<T>): void
            spliterator(): java.util.Spliterator<T>
        }
        class LinkageError extends java.lang.Error {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class Long extends java.lang.Number implements java.lang.Comparable<java.lang.Long> {
            public static MIN_VALUE: long
            public static MAX_VALUE: long
            public static TYPE: java.lang.Class<java.lang.Long>
            public static SIZE: int
            public static BYTES: int
            public static toString(arg0: long, arg1: int): string
            public static toUnsignedString(arg0: long, arg1: int): string
            public static toHexString(arg0: long): string
            public static toOctalString(arg0: long): string
            public static toBinaryString(arg0: long): string
            public static toString(arg0: long): string
            public static toUnsignedString(arg0: long): string
            public static parseLong(arg0: java.lang.String | string, arg1: int): long
            public static parseLong(arg0: java.lang.String | string): long
            public static parseUnsignedLong(arg0: java.lang.String | string, arg1: int): long
            public static parseUnsignedLong(arg0: java.lang.String | string): long
            public static valueOf(arg0: java.lang.String | string, arg1: int): java.lang.Long
            public static valueOf(arg0: java.lang.String | string): java.lang.Long
            public static valueOf(arg0: long): java.lang.Long
            public static decode(arg0: java.lang.String | string): java.lang.Long
            public constructor(arg0: long)
            public constructor(arg0: java.lang.String | string)
            public byteValue(): byte
            public shortValue(): short
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public toString(): string
            public hashCode(): int
            public static hashCode(arg0: long): int
            public equals(arg0: java.lang.Object): boolean
            public static getLong(arg0: java.lang.String | string): java.lang.Long
            public static getLong(arg0: java.lang.String | string, arg1: long): java.lang.Long
            public static getLong(arg0: java.lang.String | string, arg1: java.lang.Long): java.lang.Long
            public compareTo(arg0: java.lang.Long): int
            public static compare(arg0: long, arg1: long): int
            public static compareUnsigned(arg0: long, arg1: long): int
            public static divideUnsigned(arg0: long, arg1: long): long
            public static remainderUnsigned(arg0: long, arg1: long): long
            public static highestOneBit(arg0: long): long
            public static lowestOneBit(arg0: long): long
            public static numberOfLeadingZeros(arg0: long): int
            public static numberOfTrailingZeros(arg0: long): int
            public static bitCount(arg0: long): int
            public static rotateLeft(arg0: long, arg1: int): long
            public static rotateRight(arg0: long, arg1: int): long
            public static reverse(arg0: long): long
            public static signum(arg0: long): int
            public static reverseBytes(arg0: long): long
            public static sum(arg0: long, arg1: long): long
            public static max(arg0: long, arg1: long): long
            public static min(arg0: long, arg1: long): long
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class Math {
            public static E: double
            public static PI: double
            public static sin(arg0: double): double
            public static cos(arg0: double): double
            public static tan(arg0: double): double
            public static asin(arg0: double): double
            public static acos(arg0: double): double
            public static atan(arg0: double): double
            public static toRadians(arg0: double): double
            public static toDegrees(arg0: double): double
            public static exp(arg0: double): double
            public static log(arg0: double): double
            public static log10(arg0: double): double
            public static sqrt(arg0: double): double
            public static cbrt(arg0: double): double
            public static IEEEremainder(arg0: double, arg1: double): double
            public static ceil(arg0: double): double
            public static floor(arg0: double): double
            public static rint(arg0: double): double
            public static atan2(arg0: double, arg1: double): double
            public static pow(arg0: double, arg1: double): double
            public static round(arg0: float): int
            public static round(arg0: double): long
            public static random(): double
            public static addExact(arg0: int, arg1: int): int
            public static addExact(arg0: long, arg1: long): long
            public static subtractExact(arg0: int, arg1: int): int
            public static subtractExact(arg0: long, arg1: long): long
            public static multiplyExact(arg0: int, arg1: int): int
            public static multiplyExact(arg0: long, arg1: long): long
            public static incrementExact(arg0: int): int
            public static incrementExact(arg0: long): long
            public static decrementExact(arg0: int): int
            public static decrementExact(arg0: long): long
            public static negateExact(arg0: int): int
            public static negateExact(arg0: long): long
            public static toIntExact(arg0: long): int
            public static floorDiv(arg0: int, arg1: int): int
            public static floorDiv(arg0: long, arg1: long): long
            public static floorMod(arg0: int, arg1: int): int
            public static floorMod(arg0: long, arg1: long): long
            public static abs(arg0: int): int
            public static abs(arg0: long): long
            public static abs(arg0: float): float
            public static abs(arg0: double): double
            public static max(arg0: int, arg1: int): int
            public static max(arg0: long, arg1: long): long
            public static max(arg0: float, arg1: float): float
            public static max(arg0: double, arg1: double): double
            public static min(arg0: int, arg1: int): int
            public static min(arg0: long, arg1: long): long
            public static min(arg0: float, arg1: float): float
            public static min(arg0: double, arg1: double): double
            public static ulp(arg0: double): double
            public static ulp(arg0: float): float
            public static signum(arg0: double): double
            public static signum(arg0: float): float
            public static sinh(arg0: double): double
            public static cosh(arg0: double): double
            public static tanh(arg0: double): double
            public static hypot(arg0: double, arg1: double): double
            public static expm1(arg0: double): double
            public static log1p(arg0: double): double
            public static copySign(arg0: double, arg1: double): double
            public static copySign(arg0: float, arg1: float): float
            public static getExponent(arg0: float): int
            public static getExponent(arg0: double): int
            public static nextAfter(arg0: double, arg1: double): double
            public static nextAfter(arg0: float, arg1: double): float
            public static nextUp(arg0: double): double
            public static nextUp(arg0: float): float
            public static nextDown(arg0: double): double
            public static nextDown(arg0: float): float
            public static scalb(arg0: double, arg1: int): double
            public static scalb(arg0: float, arg1: int): float
            public static class: java.lang.Class<any>
        }
        class NegativeArraySizeException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NoClassDefFoundError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NoSuchFieldError extends java.lang.IncompatibleClassChangeError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NoSuchFieldException extends java.lang.ReflectiveOperationException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NoSuchMethodError extends java.lang.IncompatibleClassChangeError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NoSuchMethodException extends java.lang.ReflectiveOperationException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NullPointerException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        abstract class Number implements java.io.Serializable {
            public constructor()
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public byteValue(): byte
            public shortValue(): short
            public static class: java.lang.Class<any>
        }
        class NumberFormatException extends java.lang.IllegalArgumentException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        type Object = any
        class OutOfMemoryError extends java.lang.VirtualMachineError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface Override extends java.lang.annotation.Annotation {
        }
        class Package implements java.lang.reflect.AnnotatedElement {
            public getName(): string
            public getSpecificationTitle(): string
            public getSpecificationVersion(): string
            public getSpecificationVendor(): string
            public getImplementationTitle(): string
            public getImplementationVersion(): string
            public getImplementationVendor(): string
            public isSealed(): boolean
            public isSealed(arg0: java.net.URL): boolean
            public isCompatibleWith(arg0: java.lang.String | string): boolean
            public static getPackage(arg0: java.lang.String | string): java.lang.Package
            public static getPackages(): java.lang.Package[]
            public hashCode(): int
            public toString(): string
            public getAnnotation<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A
            public isAnnotationPresent<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<java.lang.annotation.Annotation>): boolean
            public getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A[]
            public getAnnotations<A extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
            public getDeclaredAnnotation<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A
            public getDeclaredAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: java.lang.Class<A>): A[]
            public getDeclaredAnnotations<A extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
            public static class: java.lang.Class<any>
        }
        abstract class Process {
            public constructor()
            public getOutputStream(): java.io.OutputStream
            public getInputStream(): java.io.InputStream
            public getErrorStream(): java.io.InputStream
            public waitFor(): int
            public waitFor(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
            public exitValue(): int
            public destroy(): void
            public destroyForcibly(): java.lang.Process
            public isAlive(): boolean
            public static class: java.lang.Class<any>
        }
        class ProcessBuilder {
            public constructor(arg0: java.util.List<java.lang.String>)
            public constructor(...arg0: java.lang.String[])
            public command(arg0: java.util.List<java.lang.String>): java.lang.ProcessBuilder
            public command(...arg0: java.lang.String[]): java.lang.ProcessBuilder
            public command(): java.util.List<java.lang.String>
            public environment(): java.util.Map<java.lang.String, java.lang.String>
            public directory(): java.io.File
            public directory(arg0: java.io.File): java.lang.ProcessBuilder
            public redirectInput(arg0: java.lang.ProcessBuilder$Redirect): java.lang.ProcessBuilder
            public redirectOutput(arg0: java.lang.ProcessBuilder$Redirect): java.lang.ProcessBuilder
            public redirectError(arg0: java.lang.ProcessBuilder$Redirect): java.lang.ProcessBuilder
            public redirectInput(arg0: java.io.File): java.lang.ProcessBuilder
            public redirectOutput(arg0: java.io.File): java.lang.ProcessBuilder
            public redirectError(arg0: java.io.File): java.lang.ProcessBuilder
            public redirectInput(): java.lang.ProcessBuilder$Redirect
            public redirectOutput(): java.lang.ProcessBuilder$Redirect
            public redirectError(): java.lang.ProcessBuilder$Redirect
            public inheritIO(): java.lang.ProcessBuilder
            public redirectErrorStream(): boolean
            public redirectErrorStream(arg0: boolean): java.lang.ProcessBuilder
            public start(): java.lang.Process
            public static class: java.lang.Class<any>
        }
        interface Readable {
            read(arg0: java.nio.CharBuffer): int
        }
        interface Readable$$Lambda {
            (arg0: java.nio.CharBuffer): int
        }
        class ReflectiveOperationException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        interface Runnable {
            run(): void
        }
        interface Runnable$$Lambda {
            (): void
        }
        class Runtime {
            public static getRuntime(): java.lang.Runtime
            public exit(arg0: int): void
            public addShutdownHook(arg0: java.lang.Thread | java.lang.Thread$$Lambda): void
            public removeShutdownHook(arg0: java.lang.Thread | java.lang.Thread$$Lambda): boolean
            public halt(arg0: int): void
            public static runFinalizersOnExit(arg0: boolean): void
            public exec(arg0: java.lang.String | string): java.lang.Process
            public exec(arg0: java.lang.String | string, arg1: java.lang.String[]): java.lang.Process
            public exec(arg0: java.lang.String | string, arg1: java.lang.String[], arg2: java.io.File): java.lang.Process
            public exec(arg0: java.lang.String[]): java.lang.Process
            public exec(arg0: java.lang.String[], arg1: java.lang.String[]): java.lang.Process
            public exec(arg0: java.lang.String[], arg1: java.lang.String[], arg2: java.io.File): java.lang.Process
            public availableProcessors(): int
            public freeMemory(): long
            public totalMemory(): long
            public maxMemory(): long
            public gc(): void
            public runFinalization(): void
            public traceInstructions(arg0: boolean): void
            public traceMethodCalls(arg0: boolean): void
            public load(arg0: java.lang.String | string): void
            public loadLibrary(arg0: java.lang.String | string): void
            public getLocalizedInputStream(arg0: java.io.InputStream): java.io.InputStream
            public getLocalizedOutputStream(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): java.io.OutputStream
            public static class: java.lang.Class<any>
        }
        class RuntimeException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            protected constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: boolean, arg3: boolean)
            public static class: java.lang.Class<any>
        }
        class RuntimePermission extends java.security.BasicPermission {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface SafeVarargs extends java.lang.annotation.Annotation {
        }
        class SecurityException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class SecurityManager {
            protected inCheck: boolean
            public getInCheck(): boolean
            public constructor()
            protected getClassContext(): java.lang.Class[]
            protected currentClassLoader(): java.lang.ClassLoader
            protected currentLoadedClass(): java.lang.Class<any>
            protected classDepth(arg0: java.lang.String | string): int
            protected classLoaderDepth(): int
            protected inClass(arg0: java.lang.String | string): boolean
            protected inClassLoader(): boolean
            public getSecurityContext(): java.lang.Object
            public checkPermission(arg0: java.security.Permission): void
            public checkPermission(arg0: java.security.Permission, arg1: java.lang.Object): void
            public checkCreateClassLoader(): void
            public checkAccess(arg0: java.lang.Thread | java.lang.Thread$$Lambda): void
            public checkAccess(arg0: java.lang.ThreadGroup): void
            public checkExit(arg0: int): void
            public checkExec(arg0: java.lang.String | string): void
            public checkLink(arg0: java.lang.String | string): void
            public checkRead(arg0: java.io.FileDescriptor): void
            public checkRead(arg0: java.lang.String | string): void
            public checkRead(arg0: java.lang.String | string, arg1: java.lang.Object): void
            public checkWrite(arg0: java.io.FileDescriptor): void
            public checkWrite(arg0: java.lang.String | string): void
            public checkDelete(arg0: java.lang.String | string): void
            public checkConnect(arg0: java.lang.String | string, arg1: int): void
            public checkConnect(arg0: java.lang.String | string, arg1: int, arg2: java.lang.Object): void
            public checkListen(arg0: int): void
            public checkAccept(arg0: java.lang.String | string, arg1: int): void
            public checkMulticast(arg0: java.net.InetAddress): void
            public checkMulticast(arg0: java.net.InetAddress, arg1: byte): void
            public checkPropertiesAccess(): void
            public checkPropertyAccess(arg0: java.lang.String | string): void
            public checkTopLevelWindow(arg0: java.lang.Object): boolean
            public checkPrintJobAccess(): void
            public checkSystemClipboardAccess(): void
            public checkAwtEventQueueAccess(): void
            public checkPackageAccess(arg0: java.lang.String | string): void
            public checkPackageDefinition(arg0: java.lang.String | string): void
            public checkSetFactory(): void
            public checkMemberAccess(arg0: java.lang.Class<any>, arg1: int): void
            public checkSecurityAccess(arg0: java.lang.String | string): void
            public getThreadGroup(): java.lang.ThreadGroup
            public static class: java.lang.Class<any>
        }
        class Short extends java.lang.Number implements java.lang.Comparable<java.lang.Short> {
            public static MIN_VALUE: short
            public static MAX_VALUE: short
            public static TYPE: java.lang.Class<java.lang.Short>
            public static SIZE: int
            public static BYTES: int
            public static toString(arg0: short): string
            public static parseShort(arg0: java.lang.String | string, arg1: int): short
            public static parseShort(arg0: java.lang.String | string): short
            public static valueOf(arg0: java.lang.String | string, arg1: int): java.lang.Short
            public static valueOf(arg0: java.lang.String | string): java.lang.Short
            public static valueOf(arg0: short): java.lang.Short
            public static decode(arg0: java.lang.String | string): java.lang.Short
            public constructor(arg0: short)
            public constructor(arg0: java.lang.String | string)
            public byteValue(): byte
            public shortValue(): short
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public toString(): string
            public hashCode(): int
            public static hashCode(arg0: short): int
            public equals(arg0: java.lang.Object): boolean
            public compareTo(arg0: java.lang.Short): int
            public static compare(arg0: short, arg1: short): int
            public static reverseBytes(arg0: short): short
            public static toUnsignedInt(arg0: short): int
            public static toUnsignedLong(arg0: short): long
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class Shutdown {
            public static class: java.lang.Class<any>
        }
        class StackOverflowError extends java.lang.VirtualMachineError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class StackTraceElement implements java.io.Serializable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int)
            public equals(arg0: java.lang.Object): boolean
            public getClassName(): string
            public getFileName(): string
            public getLineNumber(): int
            public getMethodName(): string
            public hashCode(): int
            public isNativeMethod(): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class StrictMath {
            public static E: double
            public static PI: double
            public static sin(arg0: double): double
            public static cos(arg0: double): double
            public static tan(arg0: double): double
            public static asin(arg0: double): double
            public static acos(arg0: double): double
            public static atan(arg0: double): double
            public static toRadians(arg0: double): double
            public static toDegrees(arg0: double): double
            public static exp(arg0: double): double
            public static log(arg0: double): double
            public static log10(arg0: double): double
            public static sqrt(arg0: double): double
            public static cbrt(arg0: double): double
            public static IEEEremainder(arg0: double, arg1: double): double
            public static ceil(arg0: double): double
            public static floor(arg0: double): double
            public static rint(arg0: double): double
            public static atan2(arg0: double, arg1: double): double
            public static pow(arg0: double, arg1: double): double
            public static round(arg0: float): int
            public static round(arg0: double): long
            public static random(): double
            public static addExact(arg0: int, arg1: int): int
            public static addExact(arg0: long, arg1: long): long
            public static subtractExact(arg0: int, arg1: int): int
            public static subtractExact(arg0: long, arg1: long): long
            public static multiplyExact(arg0: int, arg1: int): int
            public static multiplyExact(arg0: long, arg1: long): long
            public static toIntExact(arg0: long): int
            public static floorDiv(arg0: int, arg1: int): int
            public static floorDiv(arg0: long, arg1: long): long
            public static floorMod(arg0: int, arg1: int): int
            public static floorMod(arg0: long, arg1: long): long
            public static abs(arg0: int): int
            public static abs(arg0: long): long
            public static abs(arg0: float): float
            public static abs(arg0: double): double
            public static max(arg0: int, arg1: int): int
            public static max(arg0: long, arg1: long): long
            public static max(arg0: float, arg1: float): float
            public static max(arg0: double, arg1: double): double
            public static min(arg0: int, arg1: int): int
            public static min(arg0: long, arg1: long): long
            public static min(arg0: float, arg1: float): float
            public static min(arg0: double, arg1: double): double
            public static ulp(arg0: double): double
            public static ulp(arg0: float): float
            public static signum(arg0: double): double
            public static signum(arg0: float): float
            public static sinh(arg0: double): double
            public static cosh(arg0: double): double
            public static tanh(arg0: double): double
            public static hypot(arg0: double, arg1: double): double
            public static expm1(arg0: double): double
            public static log1p(arg0: double): double
            public static copySign(arg0: double, arg1: double): double
            public static copySign(arg0: float, arg1: float): float
            public static getExponent(arg0: float): int
            public static getExponent(arg0: double): int
            public static nextAfter(arg0: double, arg1: double): double
            public static nextAfter(arg0: float, arg1: double): float
            public static nextUp(arg0: double): double
            public static nextUp(arg0: float): float
            public static nextDown(arg0: double): double
            public static nextDown(arg0: float): float
            public static scalb(arg0: double, arg1: int): double
            public static scalb(arg0: float, arg1: int): float
            public static class: java.lang.Class<any>
        }
        class String implements java.io.Serializable , java.lang.Comparable<java.lang.String> , java.lang.CharSequence {
            public static CASE_INSENSITIVE_ORDER: java.util.Comparator<java.lang.String>
            public constructor()
            public constructor(arg0: byte[])
            public constructor(arg0: byte[], arg1: int)
            public constructor(arg0: byte[], arg1: int, arg2: int)
            public constructor(arg0: byte[], arg1: int, arg2: int, arg3: int)
            public constructor(arg0: byte[], arg1: int, arg2: int, arg3: java.lang.String | string)
            public constructor(arg0: byte[], arg1: java.lang.String | string)
            public constructor(arg0: char[])
            public constructor(arg0: char[], arg1: int, arg2: int)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.StringBuffer)
            public charAt(arg0: int): char
            public compareTo(arg0: java.lang.String | string): int
            public compareToIgnoreCase(arg0: java.lang.String | string): int
            public concat(arg0: java.lang.String | string): string
            public static copyValueOf(arg0: char[]): string
            public static copyValueOf(arg0: char[], arg1: int, arg2: int): string
            public endsWith(arg0: java.lang.String | string): boolean
            public equals(arg0: java.lang.Object): boolean
            public equalsIgnoreCase(arg0: java.lang.String | string): boolean
            public getBytes(): byte[]
            public getBytes(arg0: int, arg1: int, arg2: byte[], arg3: int): void
            public getBytes(arg0: java.lang.String | string): byte[]
            public getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void
            public hashCode(): int
            public indexOf(arg0: int): int
            public indexOf(arg0: int, arg1: int): int
            public indexOf(arg0: java.lang.String | string): int
            public indexOf(arg0: java.lang.String | string, arg1: int): int
            public intern(): string
            public lastIndexOf(arg0: int): int
            public lastIndexOf(arg0: int, arg1: int): int
            public lastIndexOf(arg0: java.lang.String | string): int
            public lastIndexOf(arg0: java.lang.String | string, arg1: int): int
            public length(): int
            public regionMatches(arg0: int, arg1: java.lang.String | string, arg2: int, arg3: int): boolean
            public regionMatches(arg0: boolean, arg1: int, arg2: java.lang.String | string, arg3: int, arg4: int): boolean
            public replace(arg0: char, arg1: char): string
            public startsWith(arg0: java.lang.String | string): boolean
            public startsWith(arg0: java.lang.String | string, arg1: int): boolean
            public substring(arg0: int): string
            public substring(arg0: int, arg1: int): string
            public toCharArray(): char[]
            public toLowerCase(): string
            public toLowerCase(arg0: java.util.Locale): string
            public toString(): string
            public toUpperCase(): string
            public toUpperCase(arg0: java.util.Locale): string
            public trim(): string
            public static valueOf(arg0: char[]): string
            public static valueOf(arg0: char[], arg1: int, arg2: int): string
            public static valueOf(arg0: char): string
            public static valueOf(arg0: double): string
            public static valueOf(arg0: float): string
            public static valueOf(arg0: int): string
            public static valueOf(arg0: long): string
            public static valueOf(arg0: java.lang.Object): string
            public static valueOf(arg0: boolean): string
            public contentEquals(arg0: java.lang.StringBuffer): boolean
            public matches(arg0: java.lang.String | string): boolean
            public replaceAll(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public replaceFirst(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public split(arg0: java.lang.String | string): java.lang.String[]
            public split(arg0: java.lang.String | string, arg1: int): java.lang.String[]
            public subSequence(arg0: int, arg1: int): java.lang.CharSequence
            public constructor(arg0: int[], arg1: int, arg2: int)
            public constructor(arg0: java.lang.StringBuilder)
            public codePointAt(arg0: int): int
            public codePointBefore(arg0: int): int
            public codePointCount(arg0: int, arg1: int): int
            public offsetByCodePoints(arg0: int, arg1: int): int
            public contentEquals(arg0: java.lang.CharSequence): boolean
            public contains(arg0: java.lang.CharSequence): boolean
            public replace(arg0: java.lang.CharSequence, arg1: java.lang.CharSequence): string
            public static format(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): string
            public static format(arg0: java.util.Locale, arg1: java.lang.String | string, ...arg2: java.lang.Object[]): string
            public isEmpty(): boolean
            public constructor(arg0: byte[], arg1: java.nio.charset.Charset)
            public constructor(arg0: byte[], arg1: int, arg2: int, arg3: java.nio.charset.Charset)
            public getBytes(arg0: java.nio.charset.Charset): byte[]
            public static join(arg0: java.lang.CharSequence, ...arg1: java.lang.CharSequence[]): string
            public static join(arg0: java.lang.CharSequence, arg1: java.lang.Iterable<java.lang.CharSequence>): string
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class StringBuffer extends java.lang.AbstractStringBuilder implements java.io.Serializable , java.lang.CharSequence , java.lang.Appendable {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.lang.String | string)
            public append(arg0: char[]): java.lang.StringBuffer
            public append(arg0: char[], arg1: int, arg2: int): java.lang.StringBuffer
            public append(arg0: char): java.lang.StringBuffer
            public append(arg0: double): java.lang.StringBuffer
            public append(arg0: float): java.lang.StringBuffer
            public append(arg0: int): java.lang.StringBuffer
            public append(arg0: long): java.lang.StringBuffer
            public append(arg0: java.lang.Object): java.lang.StringBuffer
            public append(arg0: java.lang.String | string): java.lang.StringBuffer
            public append(arg0: boolean): java.lang.StringBuffer
            public capacity(): int
            public charAt(arg0: int): char
            public delete(arg0: int, arg1: int): java.lang.StringBuffer
            public deleteCharAt(arg0: int): java.lang.StringBuffer
            public ensureCapacity(arg0: int): void
            public getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void
            public insert(arg0: int, arg1: char[]): java.lang.StringBuffer
            public insert(arg0: int, arg1: char[], arg2: int, arg3: int): java.lang.StringBuffer
            public insert(arg0: int, arg1: char): java.lang.StringBuffer
            public insert(arg0: int, arg1: double): java.lang.StringBuffer
            public insert(arg0: int, arg1: float): java.lang.StringBuffer
            public insert(arg0: int, arg1: int): java.lang.StringBuffer
            public insert(arg0: int, arg1: long): java.lang.StringBuffer
            public insert(arg0: int, arg1: java.lang.Object): java.lang.StringBuffer
            public insert(arg0: int, arg1: java.lang.String | string): java.lang.StringBuffer
            public insert(arg0: int, arg1: boolean): java.lang.StringBuffer
            public length(): int
            public replace(arg0: int, arg1: int, arg2: java.lang.String | string): java.lang.StringBuffer
            public reverse(): java.lang.StringBuffer
            public setCharAt(arg0: int, arg1: char): void
            public setLength(arg0: int): void
            public substring(arg0: int): string
            public substring(arg0: int, arg1: int): string
            public toString(): string
            public append(arg0: java.lang.StringBuffer): java.lang.StringBuffer
            public subSequence(arg0: int, arg1: int): java.lang.CharSequence
            public indexOf(arg0: java.lang.String | string): int
            public indexOf(arg0: java.lang.String | string, arg1: int): int
            public lastIndexOf(arg0: java.lang.String | string): int
            public lastIndexOf(arg0: java.lang.String | string, arg1: int): int
            public constructor(arg0: java.lang.CharSequence)
            public append(arg0: java.lang.CharSequence): java.lang.StringBuffer
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.StringBuffer
            public insert(arg0: int, arg1: java.lang.CharSequence): java.lang.StringBuffer
            public insert(arg0: int, arg1: java.lang.CharSequence, arg2: int, arg3: int): java.lang.StringBuffer
            public trimToSize(): void
            public codePointAt(arg0: int): int
            public codePointBefore(arg0: int): int
            public codePointCount(arg0: int, arg1: int): int
            public offsetByCodePoints(arg0: int, arg1: int): int
            public appendCodePoint(arg0: int): java.lang.StringBuffer
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        class StringBuilder extends java.lang.AbstractStringBuilder implements java.io.Serializable , java.lang.CharSequence , java.lang.Appendable {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.lang.String | string)
            public append(arg0: char[]): java.lang.StringBuilder
            public append(arg0: char[], arg1: int, arg2: int): java.lang.StringBuilder
            public append(arg0: char): java.lang.StringBuilder
            public append(arg0: double): java.lang.StringBuilder
            public append(arg0: float): java.lang.StringBuilder
            public append(arg0: int): java.lang.StringBuilder
            public append(arg0: long): java.lang.StringBuilder
            public append(arg0: java.lang.Object): java.lang.StringBuilder
            public append(arg0: java.lang.String | string): java.lang.StringBuilder
            public append(arg0: boolean): java.lang.StringBuilder
            public capacity(): int
            public charAt(arg0: int): char
            public delete(arg0: int, arg1: int): java.lang.StringBuilder
            public deleteCharAt(arg0: int): java.lang.StringBuilder
            public ensureCapacity(arg0: int): void
            public getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void
            public insert(arg0: int, arg1: char[]): java.lang.StringBuilder
            public insert(arg0: int, arg1: char[], arg2: int, arg3: int): java.lang.StringBuilder
            public insert(arg0: int, arg1: char): java.lang.StringBuilder
            public insert(arg0: int, arg1: double): java.lang.StringBuilder
            public insert(arg0: int, arg1: float): java.lang.StringBuilder
            public insert(arg0: int, arg1: int): java.lang.StringBuilder
            public insert(arg0: int, arg1: long): java.lang.StringBuilder
            public insert(arg0: int, arg1: java.lang.Object): java.lang.StringBuilder
            public insert(arg0: int, arg1: java.lang.String | string): java.lang.StringBuilder
            public insert(arg0: int, arg1: boolean): java.lang.StringBuilder
            public length(): int
            public replace(arg0: int, arg1: int, arg2: java.lang.String | string): java.lang.StringBuilder
            public reverse(): java.lang.StringBuilder
            public setCharAt(arg0: int, arg1: char): void
            public setLength(arg0: int): void
            public substring(arg0: int): string
            public substring(arg0: int, arg1: int): string
            public toString(): string
            public append(arg0: java.lang.StringBuffer): java.lang.StringBuilder
            public subSequence(arg0: int, arg1: int): java.lang.CharSequence
            public indexOf(arg0: java.lang.String | string): int
            public indexOf(arg0: java.lang.String | string, arg1: int): int
            public lastIndexOf(arg0: java.lang.String | string): int
            public lastIndexOf(arg0: java.lang.String | string, arg1: int): int
            public constructor(arg0: java.lang.CharSequence)
            public append(arg0: java.lang.CharSequence): java.lang.StringBuilder
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.StringBuilder
            public insert(arg0: int, arg1: java.lang.CharSequence): java.lang.StringBuilder
            public insert(arg0: int, arg1: java.lang.CharSequence, arg2: int, arg3: int): java.lang.StringBuilder
            public trimToSize(): void
            public codePointAt(arg0: int): int
            public codePointBefore(arg0: int): int
            public codePointCount(arg0: int, arg1: int): int
            public offsetByCodePoints(arg0: int, arg1: int): int
            public appendCodePoint(arg0: int): java.lang.StringBuilder
            public append(arg0: char): java.lang.Appendable
            public append(arg0: java.lang.CharSequence, arg1: int, arg2: int): java.lang.Appendable
            public append(arg0: java.lang.CharSequence): java.lang.Appendable
            public static class: java.lang.Class<any>
        }
        class StringCoding {
            public static class: java.lang.Class<any>
        }
        class StringIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: int)
            public static class: java.lang.Class<any>
        }
        interface SuppressWarnings extends java.lang.annotation.Annotation {
            value(): java.lang.String[]
        }
        class System {
            public static in: java.io.InputStream
            public static out: java.io.PrintStream
            public static err: java.io.PrintStream
            public static setIn(arg0: java.io.InputStream): void
            public static setOut(arg0: java.io.PrintStream): void
            public static setErr(arg0: java.io.PrintStream): void
            public static arraycopy(arg0: java.lang.Object, arg1: int, arg2: java.lang.Object, arg3: int, arg4: int): void
            public static currentTimeMillis(): long
            public static exit(arg0: int): void
            public static gc(): void
            public static getenv(arg0: java.lang.String | string): string
            public static getProperties(): java.util.Properties
            public static getProperty(arg0: java.lang.String | string): string
            public static getProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public static setProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public static getSecurityManager(): java.lang.SecurityManager
            public static identityHashCode(arg0: java.lang.Object): int
            public static load(arg0: java.lang.String | string): void
            public static loadLibrary(arg0: java.lang.String | string): void
            public static runFinalization(): void
            public static runFinalizersOnExit(arg0: boolean): void
            public static setProperties(arg0: java.util.Properties): void
            public static setSecurityManager(arg0: java.lang.SecurityManager): void
            public static mapLibraryName(arg0: java.lang.String | string): string
            public static inheritedChannel(): java.nio.channels.Channel
            public static nanoTime(): long
            public static clearProperty(arg0: java.lang.String | string): string
            public static getenv(): java.util.Map<java.lang.String, java.lang.String>
            public static console(): java.io.Console
            public static lineSeparator(): string
            public static class: java.lang.Class<any>
        }
        class Thread implements java.lang.Runnable {
            public static MAX_PRIORITY: int
            public static MIN_PRIORITY: int
            public static NORM_PRIORITY: int
            public constructor()
            public constructor(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda)
            public constructor(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.lang.String | string)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.ThreadGroup, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda)
            public constructor(arg0: java.lang.ThreadGroup, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.lang.String | string, arg3: long)
            public constructor(arg0: java.lang.ThreadGroup, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.lang.String | string)
            public constructor(arg0: java.lang.ThreadGroup, arg1: java.lang.String | string)
            public static activeCount(): int
            public checkAccess(): void
            public countStackFrames(): int
            public static currentThread(): java.lang.Thread
            public destroy(): void
            public static dumpStack(): void
            public static enumerate(arg0: java.lang.Thread[]): int
            public getContextClassLoader(): java.lang.ClassLoader
            public getName(): string
            public getPriority(): int
            public getThreadGroup(): java.lang.ThreadGroup
            public interrupt(): void
            public static interrupted(): boolean
            public isAlive(): boolean
            public isDaemon(): boolean
            public isInterrupted(): boolean
            public join(): void
            public join(arg0: long): void
            public join(arg0: long, arg1: int): void
            public resume(): void
            public run(): void
            public setContextClassLoader(arg0: java.lang.ClassLoader): void
            public setDaemon(arg0: boolean): void
            public setName(arg0: java.lang.String | string): void
            public setPriority(arg0: int): void
            public static sleep(arg0: long): void
            public static sleep(arg0: long, arg1: int): void
            public start(): void
            public stop(): void
            public stop(arg0: java.lang.Throwable): void
            public suspend(): void
            public toString(): string
            public static yield(): void
            public static holdsLock(arg0: java.lang.Object): boolean
            public getStackTrace(): java.lang.StackTraceElement[]
            public static getAllStackTraces(): java.util.Map<java.lang.Thread, java.lang.StackTraceElement[]>
            public getId(): long
            public getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler
            public setUncaughtExceptionHandler(arg0: java.lang.Thread$UncaughtExceptionHandler): void
            public static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler
            public static setDefaultUncaughtExceptionHandler(arg0: java.lang.Thread$UncaughtExceptionHandler): void
            public getState(): java.lang.Thread$State
            protected clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class Thread$$Lambda implements java.lang.Runnable {
            public static MAX_PRIORITY: int
        }
        class ThreadDeath extends java.lang.Error {
            public constructor()
            public static class: java.lang.Class<any>
        }
        class ThreadGroup implements java.lang.Thread$UncaughtExceptionHandler {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.ThreadGroup, arg1: java.lang.String | string)
            public activeCount(): int
            public activeGroupCount(): int
            public allowThreadSuspension(arg0: boolean): boolean
            public checkAccess(): void
            public destroy(): void
            public enumerate(arg0: java.lang.Thread[]): int
            public enumerate(arg0: java.lang.Thread[], arg1: boolean): int
            public enumerate(arg0: java.lang.ThreadGroup[]): int
            public enumerate(arg0: java.lang.ThreadGroup[], arg1: boolean): int
            public getMaxPriority(): int
            public getName(): string
            public getParent(): java.lang.ThreadGroup
            public interrupt(): void
            public isDaemon(): boolean
            public isDestroyed(): boolean
            public list(): void
            public parentOf(arg0: java.lang.ThreadGroup): boolean
            public resume(): void
            public setDaemon(arg0: boolean): void
            public setMaxPriority(arg0: int): void
            public stop(): void
            public suspend(): void
            public toString(): string
            public uncaughtException(arg0: java.lang.Thread | java.lang.Thread$$Lambda, arg1: java.lang.Throwable): void
            public static class: java.lang.Class<any>
        }
        class ThreadLocal<T> {
            protected initialValue(): T
            public static withInitial<S>(arg0: java.util.function$.Supplier<S> | java.util.function$.Supplier$$Lambda<S>): java.lang.ThreadLocal<S>
            public constructor()
            public get(): T
            public set(arg0: T): void
            public remove(): void
            public static class: java.lang.Class<any>
        }
        class Throwable implements java.io.Serializable {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            protected constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: boolean, arg3: boolean)
            public fillInStackTrace(): java.lang.Throwable
            public getMessage(): string
            public getLocalizedMessage(): string
            public getStackTrace(): java.lang.StackTraceElement[]
            public setStackTrace(arg0: java.lang.StackTraceElement[]): void
            public printStackTrace(): void
            public printStackTrace(arg0: java.io.PrintStream): void
            public printStackTrace(arg0: java.io.PrintWriter): void
            public toString(): string
            public initCause(arg0: java.lang.Throwable): java.lang.Throwable
            public getCause(): java.lang.Throwable
            public addSuppressed(arg0: java.lang.Throwable): void
            public getSuppressed(): java.lang.Throwable[]
            public static class: java.lang.Class<any>
        }
        class TypeNotPresentException extends java.lang.RuntimeException {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public typeName(): string
            public static class: java.lang.Class<any>
        }
        class UnknownError extends java.lang.VirtualMachineError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UnsatisfiedLinkError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UnsupportedClassVersionError extends java.lang.ClassFormatError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UnsupportedOperationException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class VerifyError extends java.lang.LinkageError {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        abstract class VirtualMachineError extends java.lang.Error {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class Void {
            public static TYPE: java.lang.Class<java.lang.Void>
            public static class: java.lang.Class<any>
        }
    }
    namespace math {
        class BigDecimal extends java.lang.Number implements java.lang.Comparable<java.math.BigDecimal> {
            public static ZERO: java.math.BigDecimal
            public static ONE: java.math.BigDecimal
            public static TEN: java.math.BigDecimal
            public static ROUND_UP: int
            public static ROUND_DOWN: int
            public static ROUND_CEILING: int
            public static ROUND_FLOOR: int
            public static ROUND_HALF_UP: int
            public static ROUND_HALF_DOWN: int
            public static ROUND_HALF_EVEN: int
            public static ROUND_UNNECESSARY: int
            public constructor(arg0: char[], arg1: int, arg2: int)
            public constructor(arg0: char[], arg1: int, arg2: int, arg3: java.math.MathContext)
            public constructor(arg0: char[])
            public constructor(arg0: char[], arg1: java.math.MathContext)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.math.MathContext)
            public constructor(arg0: double)
            public constructor(arg0: double, arg1: java.math.MathContext)
            public constructor(arg0: java.math.BigInteger)
            public constructor(arg0: java.math.BigInteger, arg1: java.math.MathContext)
            public constructor(arg0: java.math.BigInteger, arg1: int)
            public constructor(arg0: java.math.BigInteger, arg1: int, arg2: java.math.MathContext)
            public constructor(arg0: int)
            public constructor(arg0: int, arg1: java.math.MathContext)
            public constructor(arg0: long)
            public constructor(arg0: long, arg1: java.math.MathContext)
            public static valueOf(arg0: long, arg1: int): java.math.BigDecimal
            public static valueOf(arg0: long): java.math.BigDecimal
            public static valueOf(arg0: double): java.math.BigDecimal
            public add(arg0: java.math.BigDecimal): java.math.BigDecimal
            public add(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal
            public subtract(arg0: java.math.BigDecimal): java.math.BigDecimal
            public subtract(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal
            public multiply(arg0: java.math.BigDecimal): java.math.BigDecimal
            public multiply(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal
            public divide(arg0: java.math.BigDecimal, arg1: int, arg2: int): java.math.BigDecimal
            public divide(arg0: java.math.BigDecimal, arg1: int, arg2: java.math.RoundingMode): java.math.BigDecimal
            public divide(arg0: java.math.BigDecimal, arg1: int): java.math.BigDecimal
            public divide(arg0: java.math.BigDecimal, arg1: java.math.RoundingMode): java.math.BigDecimal
            public divide(arg0: java.math.BigDecimal): java.math.BigDecimal
            public divide(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal
            public divideToIntegralValue(arg0: java.math.BigDecimal): java.math.BigDecimal
            public divideToIntegralValue(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal
            public remainder(arg0: java.math.BigDecimal): java.math.BigDecimal
            public remainder(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal
            public divideAndRemainder(arg0: java.math.BigDecimal): java.math.BigDecimal[]
            public divideAndRemainder(arg0: java.math.BigDecimal, arg1: java.math.MathContext): java.math.BigDecimal[]
            public pow(arg0: int): java.math.BigDecimal
            public pow(arg0: int, arg1: java.math.MathContext): java.math.BigDecimal
            public abs(): java.math.BigDecimal
            public abs(arg0: java.math.MathContext): java.math.BigDecimal
            public negate(): java.math.BigDecimal
            public negate(arg0: java.math.MathContext): java.math.BigDecimal
            public plus(): java.math.BigDecimal
            public plus(arg0: java.math.MathContext): java.math.BigDecimal
            public signum(): int
            public scale(): int
            public precision(): int
            public unscaledValue(): java.math.BigInteger
            public round(arg0: java.math.MathContext): java.math.BigDecimal
            public setScale(arg0: int, arg1: java.math.RoundingMode): java.math.BigDecimal
            public setScale(arg0: int, arg1: int): java.math.BigDecimal
            public setScale(arg0: int): java.math.BigDecimal
            public movePointLeft(arg0: int): java.math.BigDecimal
            public movePointRight(arg0: int): java.math.BigDecimal
            public scaleByPowerOfTen(arg0: int): java.math.BigDecimal
            public stripTrailingZeros(): java.math.BigDecimal
            public compareTo(arg0: java.math.BigDecimal): int
            public equals(arg0: java.lang.Object): boolean
            public min(arg0: java.math.BigDecimal): java.math.BigDecimal
            public max(arg0: java.math.BigDecimal): java.math.BigDecimal
            public hashCode(): int
            public toString(): string
            public toEngineeringString(): string
            public toPlainString(): string
            public toBigInteger(): java.math.BigInteger
            public toBigIntegerExact(): java.math.BigInteger
            public longValue(): long
            public longValueExact(): long
            public intValue(): int
            public intValueExact(): int
            public shortValueExact(): short
            public byteValueExact(): byte
            public floatValue(): float
            public doubleValue(): double
            public ulp(): java.math.BigDecimal
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class BigInteger extends java.lang.Number implements java.lang.Comparable<java.math.BigInteger> {
            public static ZERO: java.math.BigInteger
            public static ONE: java.math.BigInteger
            public static TEN: java.math.BigInteger
            public constructor(arg0: byte[])
            public constructor(arg0: int, arg1: byte[])
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: int, arg1: java.util.Random)
            public constructor(arg0: int, arg1: int, arg2: java.util.Random)
            public static probablePrime(arg0: int, arg1: java.util.Random): java.math.BigInteger
            public nextProbablePrime(): java.math.BigInteger
            public static valueOf(arg0: long): java.math.BigInteger
            public add(arg0: java.math.BigInteger): java.math.BigInteger
            public subtract(arg0: java.math.BigInteger): java.math.BigInteger
            public multiply(arg0: java.math.BigInteger): java.math.BigInteger
            public divide(arg0: java.math.BigInteger): java.math.BigInteger
            public divideAndRemainder(arg0: java.math.BigInteger): java.math.BigInteger[]
            public remainder(arg0: java.math.BigInteger): java.math.BigInteger
            public pow(arg0: int): java.math.BigInteger
            public gcd(arg0: java.math.BigInteger): java.math.BigInteger
            public abs(): java.math.BigInteger
            public negate(): java.math.BigInteger
            public signum(): int
            public mod(arg0: java.math.BigInteger): java.math.BigInteger
            public modPow(arg0: java.math.BigInteger, arg1: java.math.BigInteger): java.math.BigInteger
            public modInverse(arg0: java.math.BigInteger): java.math.BigInteger
            public shiftLeft(arg0: int): java.math.BigInteger
            public shiftRight(arg0: int): java.math.BigInteger
            public and(arg0: java.math.BigInteger): java.math.BigInteger
            public or(arg0: java.math.BigInteger): java.math.BigInteger
            public xor(arg0: java.math.BigInteger): java.math.BigInteger
            public not(): java.math.BigInteger
            public andNot(arg0: java.math.BigInteger): java.math.BigInteger
            public testBit(arg0: int): boolean
            public setBit(arg0: int): java.math.BigInteger
            public clearBit(arg0: int): java.math.BigInteger
            public flipBit(arg0: int): java.math.BigInteger
            public getLowestSetBit(): int
            public bitLength(): int
            public bitCount(): int
            public isProbablePrime(arg0: int): boolean
            public compareTo(arg0: java.math.BigInteger): int
            public equals(arg0: java.lang.Object): boolean
            public min(arg0: java.math.BigInteger): java.math.BigInteger
            public max(arg0: java.math.BigInteger): java.math.BigInteger
            public hashCode(): int
            public toString(arg0: int): string
            public toString(): string
            public toByteArray(): byte[]
            public intValue(): int
            public longValue(): long
            public floatValue(): float
            public doubleValue(): double
            public longValueExact(): long
            public intValueExact(): int
            public shortValueExact(): short
            public byteValueExact(): byte
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class BitSieve {
            public static class: java.lang.Class<any>
        }
        class MathContext implements java.io.Serializable {
            public static UNLIMITED: java.math.MathContext
            public static DECIMAL32: java.math.MathContext
            public static DECIMAL64: java.math.MathContext
            public static DECIMAL128: java.math.MathContext
            public constructor(arg0: int)
            public constructor(arg0: int, arg1: java.math.RoundingMode)
            public constructor(arg0: java.lang.String | string)
            public getPrecision(): int
            public getRoundingMode(): java.math.RoundingMode
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class MutableBigInteger {
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class RoundingMode extends java.lang.Enum<java.math.RoundingMode> {
            public static UP: java.math.RoundingMode
            public static DOWN: java.math.RoundingMode
            public static CEILING: java.math.RoundingMode
            public static FLOOR: java.math.RoundingMode
            public static HALF_UP: java.math.RoundingMode
            public static HALF_DOWN: java.math.RoundingMode
            public static HALF_EVEN: java.math.RoundingMode
            public static UNNECESSARY: java.math.RoundingMode
            public static values(): java.math.RoundingMode[]
            public static valueOf(arg0: java.lang.String | string): java.math.RoundingMode
            public static valueOf(arg0: int): java.math.RoundingMode
            public static class: java.lang.Class<any>
        }
        class SignedMutableBigInteger extends java.math.MutableBigInteger {
            public toString(): string
            public static class: java.lang.Class<any>
        }
    }
    namespace net {
        abstract class AbstractPlainDatagramSocketImpl extends java.net.DatagramSocketImpl {
            protected connectedAddress: java.net.InetAddress
            protected create(): void
            protected bind(arg0: int, arg1: java.net.InetAddress): void
            protected bind0(arg0: int, arg1: java.net.InetAddress): void
            protected send(arg0: java.net.DatagramPacket): void
            protected connect(arg0: java.net.InetAddress, arg1: int): void
            protected disconnect(): void
            protected peek(arg0: java.net.InetAddress): int
            protected peekData(arg0: java.net.DatagramPacket): int
            protected receive(arg0: java.net.DatagramPacket): void
            protected receive0(arg0: java.net.DatagramPacket): void
            protected setTimeToLive(arg0: int): void
            protected getTimeToLive(): int
            protected setTTL(arg0: byte): void
            protected getTTL(): byte
            protected join(arg0: java.net.InetAddress): void
            protected leave(arg0: java.net.InetAddress): void
            protected joinGroup(arg0: java.net.SocketAddress, arg1: java.net.NetworkInterface): void
            protected join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface): void
            protected leaveGroup(arg0: java.net.SocketAddress, arg1: java.net.NetworkInterface): void
            protected leave(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface): void
            protected close(): void
            protected isClosed(): boolean
            protected finalize(): void
            public setOption(arg0: int, arg1: java.lang.Object): void
            public getOption(arg0: int): java.lang.Object
            protected datagramSocketCreate(): void
            protected datagramSocketClose(): void
            protected socketSetOption(arg0: int, arg1: java.lang.Object): void
            protected socketGetOption(arg0: int): java.lang.Object
            protected connect0(arg0: java.net.InetAddress, arg1: int): void
            protected disconnect0(arg0: int): void
            protected nativeConnectDisabled(): boolean
            public static class: java.lang.Class<any>
        }
        abstract class AbstractPlainSocketImpl extends java.net.SocketImpl {
            protected fdUseCount: int
            protected fdLock: java.lang.Object
            protected closePending: boolean
            protected stream: boolean
            public static SHUT_RD: int
            public static SHUT_WR: int
            protected create(arg0: boolean): void
            protected connect(arg0: java.lang.String | string, arg1: int): void
            protected connect(arg0: java.net.InetAddress, arg1: int): void
            protected connect(arg0: java.net.SocketAddress, arg1: int): void
            public setOption(arg0: int, arg1: java.lang.Object): void
            public getOption(arg0: int): java.lang.Object
            protected bind(arg0: java.net.InetAddress, arg1: int): void
            protected listen(arg0: int): void
            protected accept(arg0: java.net.SocketImpl): void
            protected getInputStream(): java.io.InputStream
            protected getOutputStream(): java.io.OutputStream
            protected available(): int
            protected close(): void
            protected shutdownInput(): void
            protected shutdownOutput(): void
            protected supportsUrgentData(): boolean
            protected sendUrgentData(arg0: int): void
            protected finalize(): void
            public isConnectionReset(): boolean
            public isConnectionResetPending(): boolean
            public setConnectionReset(): void
            public setConnectionResetPending(): void
            public isClosedOrPending(): boolean
            public getTimeout(): int
            protected socketClose(): void
            public static class: java.lang.Class<any>
        }
        abstract class Authenticator {
            public constructor()
            public static setDefault(arg0: java.net.Authenticator): void
            public static requestPasswordAuthentication(arg0: java.net.InetAddress, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string): java.net.PasswordAuthentication
            public static requestPasswordAuthentication(arg0: java.lang.String | string, arg1: java.net.InetAddress, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String | string): java.net.PasswordAuthentication
            public static requestPasswordAuthentication(arg0: java.lang.String | string, arg1: java.net.InetAddress, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String | string, arg6: java.net.URL, arg7: java.net.Authenticator$RequestorType): java.net.PasswordAuthentication
            protected getRequestingHost(): string
            protected getRequestingSite(): java.net.InetAddress
            protected getRequestingPort(): int
            protected getRequestingProtocol(): string
            protected getRequestingPrompt(): string
            protected getRequestingScheme(): string
            protected getPasswordAuthentication(): java.net.PasswordAuthentication
            protected getRequestingURL(): java.net.URL
            protected getRequestorType(): java.net.Authenticator$RequestorType
            public static class: java.lang.Class<any>
        }
        class BindException extends java.net.SocketException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        abstract class CacheRequest {
            public constructor()
            public getBody(): java.io.OutputStream
            public abort(): void
            public static class: java.lang.Class<any>
        }
        abstract class CacheResponse {
            public constructor()
            public getHeaders(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
            public getBody(): java.io.InputStream
            public static class: java.lang.Class<any>
        }
        class ConnectException extends java.net.SocketException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        abstract class ContentHandler {
            public constructor()
            public getContent(arg0: java.net.URLConnection): java.lang.Object
            public getContent(arg0: java.net.URLConnection, arg1: java.lang.Class[]): java.lang.Object
            public static class: java.lang.Class<any>
        }
        interface ContentHandlerFactory {
            createContentHandler(arg0: java.lang.String | string): java.net.ContentHandler
        }
        interface ContentHandlerFactory$$Lambda {
            (arg0: java.lang.String | string): java.net.ContentHandler
        }
        abstract class CookieHandler {
            public constructor()
            public static getDefault(): java.net.CookieHandler
            public static setDefault(arg0: java.net.CookieHandler): void
            public get(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
            public put(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): void
            public static class: java.lang.Class<any>
        }
        class CookieManager extends java.net.CookieHandler {
            public constructor()
            public constructor(arg0: java.net.CookieStore, arg1: java.net.CookiePolicy)
            public setCookiePolicy(arg0: java.net.CookiePolicy): void
            public getCookieStore(): java.net.CookieStore
            public get(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
            public put(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): void
            public static class: java.lang.Class<any>
        }
        interface CookiePolicy {
            ACCEPT_ALL: java.net.CookiePolicy
            ACCEPT_NONE: java.net.CookiePolicy
            ACCEPT_ORIGINAL_SERVER: java.net.CookiePolicy
            shouldAccept(arg0: java.net.URI, arg1: java.net.HttpCookie): boolean
        }
        interface CookieStore {
            add(arg0: java.net.URI, arg1: java.net.HttpCookie): void
            get(arg0: java.net.URI): java.util.List<java.net.HttpCookie>
            getCookies(): java.util.List<java.net.HttpCookie>
            getURIs(): java.util.List<java.net.URI>
            remove(arg0: java.net.URI, arg1: java.net.HttpCookie): boolean
            removeAll(): boolean
        }
        class DatagramPacket {
            public constructor(arg0: byte[], arg1: int, arg2: int)
            public constructor(arg0: byte[], arg1: int)
            public constructor(arg0: byte[], arg1: int, arg2: int, arg3: java.net.InetAddress, arg4: int)
            public constructor(arg0: byte[], arg1: int, arg2: int, arg3: java.net.SocketAddress)
            public constructor(arg0: byte[], arg1: int, arg2: java.net.InetAddress, arg3: int)
            public constructor(arg0: byte[], arg1: int, arg2: java.net.SocketAddress)
            public getAddress(): java.net.InetAddress
            public getPort(): int
            public getData(): byte[]
            public getOffset(): int
            public getLength(): int
            public setData(arg0: byte[], arg1: int, arg2: int): void
            public setAddress(arg0: java.net.InetAddress): void
            public setPort(arg0: int): void
            public setSocketAddress(arg0: java.net.SocketAddress): void
            public getSocketAddress(): java.net.SocketAddress
            public setData(arg0: byte[]): void
            public setLength(arg0: int): void
            public static class: java.lang.Class<any>
        }
        class DatagramSocket implements java.io.Closeable {
            public constructor()
            protected constructor(arg0: java.net.DatagramSocketImpl)
            public constructor(arg0: java.net.SocketAddress)
            public constructor(arg0: int)
            public constructor(arg0: int, arg1: java.net.InetAddress)
            public bind(arg0: java.net.SocketAddress): void
            public connect(arg0: java.net.InetAddress, arg1: int): void
            public connect(arg0: java.net.SocketAddress): void
            public disconnect(): void
            public isBound(): boolean
            public isConnected(): boolean
            public getInetAddress(): java.net.InetAddress
            public getPort(): int
            public getRemoteSocketAddress(): java.net.SocketAddress
            public getLocalSocketAddress(): java.net.SocketAddress
            public send(arg0: java.net.DatagramPacket): void
            public receive(arg0: java.net.DatagramPacket): void
            public getLocalAddress(): java.net.InetAddress
            public getLocalPort(): int
            public setSoTimeout(arg0: int): void
            public getSoTimeout(): int
            public setSendBufferSize(arg0: int): void
            public getSendBufferSize(): int
            public setReceiveBufferSize(arg0: int): void
            public getReceiveBufferSize(): int
            public setReuseAddress(arg0: boolean): void
            public getReuseAddress(): boolean
            public setBroadcast(arg0: boolean): void
            public getBroadcast(): boolean
            public setTrafficClass(arg0: int): void
            public getTrafficClass(): int
            public close(): void
            public isClosed(): boolean
            public getChannel(): java.nio.channels.DatagramChannel
            public static setDatagramSocketImplFactory(arg0: java.net.DatagramSocketImplFactory | java.net.DatagramSocketImplFactory$$Lambda): void
            public static class: java.lang.Class<any>
        }
        abstract class DatagramSocketImpl implements java.net.SocketOptions {
            protected localPort: int
            protected fd: java.io.FileDescriptor
            public constructor()
            protected create(): void
            protected bind(arg0: int, arg1: java.net.InetAddress): void
            protected send(arg0: java.net.DatagramPacket): void
            protected connect(arg0: java.net.InetAddress, arg1: int): void
            protected disconnect(): void
            protected peek(arg0: java.net.InetAddress): int
            protected peekData(arg0: java.net.DatagramPacket): int
            protected receive(arg0: java.net.DatagramPacket): void
            protected setTTL(arg0: byte): void
            protected getTTL(): byte
            protected setTimeToLive(arg0: int): void
            protected getTimeToLive(): int
            protected join(arg0: java.net.InetAddress): void
            protected leave(arg0: java.net.InetAddress): void
            protected joinGroup(arg0: java.net.SocketAddress, arg1: java.net.NetworkInterface): void
            protected leaveGroup(arg0: java.net.SocketAddress, arg1: java.net.NetworkInterface): void
            protected close(): void
            protected getLocalPort(): int
            protected getFileDescriptor(): java.io.FileDescriptor
            public static class: java.lang.Class<any>
        }
        interface DatagramSocketImplFactory {
            createDatagramSocketImpl(): java.net.DatagramSocketImpl
        }
        interface DatagramSocketImplFactory$$Lambda {
            (): java.net.DatagramSocketImpl
        }
        interface FileNameMap {
            getContentTypeFor(arg0: java.lang.String | string): string
        }
        interface FileNameMap$$Lambda {
            (arg0: java.lang.String | string): string
        }
        class HostPortrange {
            public hashCode(): int
            public literal(): boolean
            public ipv4Literal(): boolean
            public ipv6Literal(): boolean
            public hostname(): string
            public portrange(): int[]
            public wildcard(): boolean
            public static class: java.lang.Class<any>
        }
        class HttpConnectSocketImpl extends java.net.PlainSocketImpl {
            protected connect(arg0: java.net.SocketAddress, arg1: int): void
            public setOption(arg0: int, arg1: java.lang.Object): void
            protected getInetAddress(): java.net.InetAddress
            protected getPort(): int
            protected getLocalPort(): int
            public static class: java.lang.Class<any>
        }
        class HttpCookie implements java.lang.Cloneable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public static parse(arg0: java.lang.String | string): java.util.List<java.net.HttpCookie>
            public hasExpired(): boolean
            public setComment(arg0: java.lang.String | string): void
            public getComment(): string
            public setCommentURL(arg0: java.lang.String | string): void
            public getCommentURL(): string
            public setDiscard(arg0: boolean): void
            public getDiscard(): boolean
            public setPortlist(arg0: java.lang.String | string): void
            public getPortlist(): string
            public setDomain(arg0: java.lang.String | string): void
            public getDomain(): string
            public setMaxAge(arg0: long): void
            public getMaxAge(): long
            public setPath(arg0: java.lang.String | string): void
            public getPath(): string
            public setSecure(arg0: boolean): void
            public getSecure(): boolean
            public getName(): string
            public setValue(arg0: java.lang.String | string): void
            public getValue(): string
            public getVersion(): int
            public setVersion(arg0: int): void
            public isHttpOnly(): boolean
            public setHttpOnly(arg0: boolean): void
            public static domainMatches(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
            public toString(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class HttpRetryException extends java.io.IOException {
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor(arg0: java.lang.String | string, arg1: int, arg2: java.lang.String | string)
            public responseCode(): int
            public getReason(): string
            public getLocation(): string
            public static class: java.lang.Class<any>
        }
        abstract class HttpURLConnection extends java.net.URLConnection {
            protected method: string
            protected chunkLength: int
            protected fixedContentLength: int
            protected fixedContentLengthLong: long
            protected responseCode: int
            protected responseMessage: string
            protected instanceFollowRedirects: boolean
            public static HTTP_OK: int
            public static HTTP_CREATED: int
            public static HTTP_ACCEPTED: int
            public static HTTP_NOT_AUTHORITATIVE: int
            public static HTTP_NO_CONTENT: int
            public static HTTP_RESET: int
            public static HTTP_PARTIAL: int
            public static HTTP_MULT_CHOICE: int
            public static HTTP_MOVED_PERM: int
            public static HTTP_MOVED_TEMP: int
            public static HTTP_SEE_OTHER: int
            public static HTTP_NOT_MODIFIED: int
            public static HTTP_USE_PROXY: int
            public static HTTP_BAD_REQUEST: int
            public static HTTP_UNAUTHORIZED: int
            public static HTTP_PAYMENT_REQUIRED: int
            public static HTTP_FORBIDDEN: int
            public static HTTP_NOT_FOUND: int
            public static HTTP_BAD_METHOD: int
            public static HTTP_NOT_ACCEPTABLE: int
            public static HTTP_PROXY_AUTH: int
            public static HTTP_CLIENT_TIMEOUT: int
            public static HTTP_CONFLICT: int
            public static HTTP_GONE: int
            public static HTTP_LENGTH_REQUIRED: int
            public static HTTP_PRECON_FAILED: int
            public static HTTP_ENTITY_TOO_LARGE: int
            public static HTTP_REQ_TOO_LONG: int
            public static HTTP_UNSUPPORTED_TYPE: int
            public static HTTP_SERVER_ERROR: int
            public static HTTP_INTERNAL_ERROR: int
            public static HTTP_NOT_IMPLEMENTED: int
            public static HTTP_BAD_GATEWAY: int
            public static HTTP_UNAVAILABLE: int
            public static HTTP_GATEWAY_TIMEOUT: int
            public static HTTP_VERSION: int
            public getHeaderFieldKey(arg0: int): string
            public setFixedLengthStreamingMode(arg0: int): void
            public setFixedLengthStreamingMode(arg0: long): void
            public setChunkedStreamingMode(arg0: int): void
            public getHeaderField(arg0: int): string
            protected constructor(arg0: java.net.URL)
            public static setFollowRedirects(arg0: boolean): void
            public static getFollowRedirects(): boolean
            public setInstanceFollowRedirects(arg0: boolean): void
            public getInstanceFollowRedirects(): boolean
            public setRequestMethod(arg0: java.lang.String | string): void
            public getRequestMethod(): string
            public getResponseCode(): int
            public getResponseMessage(): string
            public getHeaderFieldDate(arg0: java.lang.String | string, arg1: long): long
            public disconnect(): void
            public usingProxy(): boolean
            public getPermission(): java.security.Permission
            public getErrorStream(): java.io.InputStream
            public static class: java.lang.Class<any>
        }
        class IDN {
            public static ALLOW_UNASSIGNED: int
            public static USE_STD3_ASCII_RULES: int
            public static toASCII(arg0: java.lang.String | string, arg1: int): string
            public static toASCII(arg0: java.lang.String | string): string
            public static toUnicode(arg0: java.lang.String | string, arg1: int): string
            public static toUnicode(arg0: java.lang.String | string): string
            public static class: java.lang.Class<any>
        }
        class InMemoryCookieStore implements java.net.CookieStore {
            public constructor()
            public add(arg0: java.net.URI, arg1: java.net.HttpCookie): void
            public get(arg0: java.net.URI): java.util.List<java.net.HttpCookie>
            public getCookies(): java.util.List<java.net.HttpCookie>
            public getURIs(): java.util.List<java.net.URI>
            public remove(arg0: java.net.URI, arg1: java.net.HttpCookie): boolean
            public removeAll(): boolean
            public static class: java.lang.Class<any>
        }
        class Inet4Address extends java.net.InetAddress {
            public isMulticastAddress(): boolean
            public isAnyLocalAddress(): boolean
            public isLoopbackAddress(): boolean
            public isLinkLocalAddress(): boolean
            public isSiteLocalAddress(): boolean
            public isMCGlobal(): boolean
            public isMCNodeLocal(): boolean
            public isMCLinkLocal(): boolean
            public isMCSiteLocal(): boolean
            public isMCOrgLocal(): boolean
            public getAddress(): byte[]
            public getHostAddress(): string
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public static class: java.lang.Class<any>
        }
        class Inet4AddressImpl implements java.net.InetAddressImpl {
            public getLocalHostName(): string
            public lookupAllHostAddr(arg0: java.lang.String | string): java.net.InetAddress[]
            public getHostByAddr(arg0: byte[]): string
            public anyLocalAddress(): java.net.InetAddress
            public loopbackAddress(): java.net.InetAddress
            public isReachable(arg0: java.net.InetAddress, arg1: int, arg2: java.net.NetworkInterface, arg3: int): boolean
            public static class: java.lang.Class<any>
        }
        class Inet6Address extends java.net.InetAddress {
            public static getByAddress(arg0: java.lang.String | string, arg1: byte[], arg2: java.net.NetworkInterface): java.net.Inet6Address
            public static getByAddress(arg0: java.lang.String | string, arg1: byte[], arg2: int): java.net.Inet6Address
            public isMulticastAddress(): boolean
            public isAnyLocalAddress(): boolean
            public isLoopbackAddress(): boolean
            public isLinkLocalAddress(): boolean
            public isSiteLocalAddress(): boolean
            public isMCGlobal(): boolean
            public isMCNodeLocal(): boolean
            public isMCLinkLocal(): boolean
            public isMCSiteLocal(): boolean
            public isMCOrgLocal(): boolean
            public getAddress(): byte[]
            public getScopeId(): int
            public getScopedInterface(): java.net.NetworkInterface
            public getHostAddress(): string
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public isIPv4CompatibleAddress(): boolean
            public static class: java.lang.Class<any>
        }
        class Inet6AddressImpl implements java.net.InetAddressImpl {
            public getLocalHostName(): string
            public lookupAllHostAddr(arg0: java.lang.String | string): java.net.InetAddress[]
            public getHostByAddr(arg0: byte[]): string
            public isReachable(arg0: java.net.InetAddress, arg1: int, arg2: java.net.NetworkInterface, arg3: int): boolean
            public anyLocalAddress(): java.net.InetAddress
            public loopbackAddress(): java.net.InetAddress
            public static class: java.lang.Class<any>
        }
        class InetAddress implements java.io.Serializable {
            public isMulticastAddress(): boolean
            public isAnyLocalAddress(): boolean
            public isLoopbackAddress(): boolean
            public isLinkLocalAddress(): boolean
            public isSiteLocalAddress(): boolean
            public isMCGlobal(): boolean
            public isMCNodeLocal(): boolean
            public isMCLinkLocal(): boolean
            public isMCSiteLocal(): boolean
            public isMCOrgLocal(): boolean
            public isReachable(arg0: int): boolean
            public isReachable(arg0: java.net.NetworkInterface, arg1: int, arg2: int): boolean
            public getHostName(): string
            public getCanonicalHostName(): string
            public getAddress(): byte[]
            public getHostAddress(): string
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public toString(): string
            public static getByAddress(arg0: java.lang.String | string, arg1: byte[]): java.net.InetAddress
            public static getByName(arg0: java.lang.String | string): java.net.InetAddress
            public static getAllByName(arg0: java.lang.String | string): java.net.InetAddress[]
            public static getLoopbackAddress(): java.net.InetAddress
            public static getByAddress(arg0: byte[]): java.net.InetAddress
            public static getLocalHost(): java.net.InetAddress
            public static class: java.lang.Class<any>
        }
        class InetAddressContainer {
            public static class: java.lang.Class<any>
        }
        interface InetAddressImpl {
            getLocalHostName(): string
            lookupAllHostAddr(arg0: java.lang.String | string): java.net.InetAddress[]
            getHostByAddr(arg0: byte[]): string
            anyLocalAddress(): java.net.InetAddress
            loopbackAddress(): java.net.InetAddress
            isReachable(arg0: java.net.InetAddress, arg1: int, arg2: java.net.NetworkInterface, arg3: int): boolean
        }
        class InetSocketAddress extends java.net.SocketAddress {
            public constructor(arg0: int)
            public constructor(arg0: java.net.InetAddress, arg1: int)
            public constructor(arg0: java.lang.String | string, arg1: int)
            public static createUnresolved(arg0: java.lang.String | string, arg1: int): java.net.InetSocketAddress
            public getPort(): int
            public getAddress(): java.net.InetAddress
            public getHostName(): string
            public getHostString(): string
            public isUnresolved(): boolean
            public toString(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        class InterfaceAddress {
            public getAddress(): java.net.InetAddress
            public getBroadcast(): java.net.InetAddress
            public getNetworkPrefixLength(): short
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class JarURLConnection extends java.net.URLConnection {
            protected jarFileURLConnection: java.net.URLConnection
            protected constructor(arg0: java.net.URL)
            public getJarFileURL(): java.net.URL
            public getEntryName(): string
            public getJarFile(): java.util.jar.JarFile
            public getManifest(): java.util.jar.Manifest
            public getJarEntry(): java.util.jar.JarEntry
            public getAttributes(): java.util.jar.Attributes
            public getMainAttributes(): java.util.jar.Attributes
            public getCertificates(): java.security.cert.Certificate[]
            public static class: java.lang.Class<any>
        }
        class MalformedURLException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class MulticastSocket extends java.net.DatagramSocket {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.net.SocketAddress)
            public setTTL(arg0: byte): void
            public setTimeToLive(arg0: int): void
            public getTTL(): byte
            public getTimeToLive(): int
            public joinGroup(arg0: java.net.InetAddress): void
            public leaveGroup(arg0: java.net.InetAddress): void
            public joinGroup(arg0: java.net.SocketAddress, arg1: java.net.NetworkInterface): void
            public leaveGroup(arg0: java.net.SocketAddress, arg1: java.net.NetworkInterface): void
            public setInterface(arg0: java.net.InetAddress): void
            public getInterface(): java.net.InetAddress
            public setNetworkInterface(arg0: java.net.NetworkInterface): void
            public getNetworkInterface(): java.net.NetworkInterface
            public setLoopbackMode(arg0: boolean): void
            public getLoopbackMode(): boolean
            public send(arg0: java.net.DatagramPacket, arg1: byte): void
            public static class: java.lang.Class<any>
        }
        class NetPermission extends java.security.BasicPermission {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NetworkInterface {
            public getName(): string
            public getInetAddresses(): java.util.Enumeration<java.net.InetAddress>
            public getInterfaceAddresses(): java.util.List<java.net.InterfaceAddress>
            public getSubInterfaces(): java.util.Enumeration<java.net.NetworkInterface>
            public getParent(): java.net.NetworkInterface
            public getIndex(): int
            public getDisplayName(): string
            public static getByName(arg0: java.lang.String | string): java.net.NetworkInterface
            public static getByIndex(arg0: int): java.net.NetworkInterface
            public static getByInetAddress(arg0: java.net.InetAddress): java.net.NetworkInterface
            public static getNetworkInterfaces(): java.util.Enumeration<java.net.NetworkInterface>
            public isUp(): boolean
            public isLoopback(): boolean
            public isPointToPoint(): boolean
            public supportsMulticast(): boolean
            public getHardwareAddress(): byte[]
            public getMTU(): int
            public isVirtual(): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class NoRouteToHostException extends java.net.SocketException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        class PasswordAuthentication {
            public constructor(arg0: java.lang.String | string, arg1: char[])
            public getUserName(): string
            public getPassword(): char[]
            public static class: java.lang.Class<any>
        }
        class PortUnreachableException extends java.net.SocketException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        class ProtocolException extends java.io.IOException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        interface ProtocolFamily {
            name(): string
        }
        interface ProtocolFamily$$Lambda {
            (): string
        }
        class Proxy {
            public static NO_PROXY: java.net.Proxy
            public constructor(arg0: java.net.Proxy$Type, arg1: java.net.SocketAddress)
            public type(): java.net.Proxy$Type
            public address(): java.net.SocketAddress
            public toString(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        abstract class ProxySelector {
            public constructor()
            public static getDefault(): java.net.ProxySelector
            public static setDefault(arg0: java.net.ProxySelector): void
            public select(arg0: java.net.URI): java.util.List<java.net.Proxy>
            public connectFailed(arg0: java.net.URI, arg1: java.net.SocketAddress, arg2: java.io.IOException): void
            public static class: java.lang.Class<any>
        }
        abstract class ResponseCache {
            public constructor()
            public static getDefault(): java.net.ResponseCache
            public static setDefault(arg0: java.net.ResponseCache): void
            public get(arg0: java.net.URI, arg1: java.lang.String | string, arg2: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): java.net.CacheResponse
            public put(arg0: java.net.URI, arg1: java.net.URLConnection): java.net.CacheRequest
            public static class: java.lang.Class<any>
        }
        abstract class SecureCacheResponse extends java.net.CacheResponse {
            public constructor()
            public getCipherSuite(): string
            public getLocalCertificateChain(): java.util.List<java.security.cert.Certificate>
            public getServerCertificateChain(): java.util.List<java.security.cert.Certificate>
            public getPeerPrincipal(): java.security.Principal
            public getLocalPrincipal(): java.security.Principal
            public static class: java.lang.Class<any>
        }
        class ServerSocket implements java.io.Closeable {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: int, arg1: int)
            public constructor(arg0: int, arg1: int, arg2: java.net.InetAddress)
            public bind(arg0: java.net.SocketAddress): void
            public bind(arg0: java.net.SocketAddress, arg1: int): void
            public getInetAddress(): java.net.InetAddress
            public getLocalPort(): int
            public getLocalSocketAddress(): java.net.SocketAddress
            public accept(): java.net.Socket
            protected implAccept(arg0: java.net.Socket): void
            public close(): void
            public getChannel(): java.nio.channels.ServerSocketChannel
            public isBound(): boolean
            public isClosed(): boolean
            public setSoTimeout(arg0: int): void
            public getSoTimeout(): int
            public setReuseAddress(arg0: boolean): void
            public getReuseAddress(): boolean
            public toString(): string
            public static setSocketFactory(arg0: java.net.SocketImplFactory | java.net.SocketImplFactory$$Lambda): void
            public setReceiveBufferSize(arg0: int): void
            public getReceiveBufferSize(): int
            public setPerformancePreferences(arg0: int, arg1: int, arg2: int): void
            public static class: java.lang.Class<any>
        }
        class Socket implements java.io.Closeable {
            public constructor()
            public constructor(arg0: java.net.Proxy)
            protected constructor(arg0: java.net.SocketImpl)
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor(arg0: java.net.InetAddress, arg1: int)
            public constructor(arg0: java.lang.String | string, arg1: int, arg2: java.net.InetAddress, arg3: int)
            public constructor(arg0: java.net.InetAddress, arg1: int, arg2: java.net.InetAddress, arg3: int)
            public constructor(arg0: java.lang.String | string, arg1: int, arg2: boolean)
            public constructor(arg0: java.net.InetAddress, arg1: int, arg2: boolean)
            public connect(arg0: java.net.SocketAddress): void
            public connect(arg0: java.net.SocketAddress, arg1: int): void
            public bind(arg0: java.net.SocketAddress): void
            public getInetAddress(): java.net.InetAddress
            public getLocalAddress(): java.net.InetAddress
            public getPort(): int
            public getLocalPort(): int
            public getRemoteSocketAddress(): java.net.SocketAddress
            public getLocalSocketAddress(): java.net.SocketAddress
            public getChannel(): java.nio.channels.SocketChannel
            public getInputStream(): java.io.InputStream
            public getOutputStream(): java.io.OutputStream
            public setTcpNoDelay(arg0: boolean): void
            public getTcpNoDelay(): boolean
            public setSoLinger(arg0: boolean, arg1: int): void
            public getSoLinger(): int
            public sendUrgentData(arg0: int): void
            public setOOBInline(arg0: boolean): void
            public getOOBInline(): boolean
            public setSoTimeout(arg0: int): void
            public getSoTimeout(): int
            public setSendBufferSize(arg0: int): void
            public getSendBufferSize(): int
            public setReceiveBufferSize(arg0: int): void
            public getReceiveBufferSize(): int
            public setKeepAlive(arg0: boolean): void
            public getKeepAlive(): boolean
            public setTrafficClass(arg0: int): void
            public getTrafficClass(): int
            public setReuseAddress(arg0: boolean): void
            public getReuseAddress(): boolean
            public close(): void
            public shutdownInput(): void
            public shutdownOutput(): void
            public toString(): string
            public isConnected(): boolean
            public isBound(): boolean
            public isClosed(): boolean
            public isInputShutdown(): boolean
            public isOutputShutdown(): boolean
            public static setSocketImplFactory(arg0: java.net.SocketImplFactory | java.net.SocketImplFactory$$Lambda): void
            public setPerformancePreferences(arg0: int, arg1: int, arg2: int): void
            public static class: java.lang.Class<any>
        }
        abstract class SocketAddress implements java.io.Serializable {
            public constructor()
            public static class: java.lang.Class<any>
        }
        class SocketException extends java.io.IOException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        abstract class SocketImpl implements java.net.SocketOptions {
            protected fd: java.io.FileDescriptor
            protected address: java.net.InetAddress
            protected port: int
            protected localport: int
            public constructor()
            protected create(arg0: boolean): void
            protected connect(arg0: java.lang.String | string, arg1: int): void
            protected connect(arg0: java.net.InetAddress, arg1: int): void
            protected connect(arg0: java.net.SocketAddress, arg1: int): void
            protected bind(arg0: java.net.InetAddress, arg1: int): void
            protected listen(arg0: int): void
            protected accept(arg0: java.net.SocketImpl): void
            protected getInputStream(): java.io.InputStream
            protected getOutputStream(): java.io.OutputStream
            protected available(): int
            protected close(): void
            protected shutdownInput(): void
            protected shutdownOutput(): void
            protected getFileDescriptor(): java.io.FileDescriptor
            protected getInetAddress(): java.net.InetAddress
            protected getPort(): int
            protected supportsUrgentData(): boolean
            protected sendUrgentData(arg0: int): void
            protected getLocalPort(): int
            public toString(): string
            protected setPerformancePreferences(arg0: int, arg1: int, arg2: int): void
            public static class: java.lang.Class<any>
        }
        interface SocketImplFactory {
            createSocketImpl(): java.net.SocketImpl
        }
        interface SocketImplFactory$$Lambda {
            (): java.net.SocketImpl
        }
        class SocketInputStream extends java.io.FileInputStream {
            public getChannel(): java.nio.channels.FileChannel
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public read(): int
            public skip(arg0: long): long
            public available(): int
            public close(): void
            protected finalize(): void
            public static class: java.lang.Class<any>
        }
        interface SocketOption<T> {
            name(): string
            type(): java.lang.Class<T>
        }
        interface SocketOptions {
            TCP_NODELAY: int
            SO_BINDADDR: int
            SO_REUSEADDR: int
            SO_BROADCAST: int
            IP_MULTICAST_IF: int
            IP_MULTICAST_IF2: int
            IP_MULTICAST_LOOP: int
            IP_TOS: int
            SO_LINGER: int
            SO_TIMEOUT: int
            SO_SNDBUF: int
            SO_RCVBUF: int
            SO_KEEPALIVE: int
            SO_OOBINLINE: int
            setOption(arg0: int, arg1: java.lang.Object): void
            getOption(arg0: int): java.lang.Object
        }
        class SocketOutputStream extends java.io.FileOutputStream {
            public getChannel(): java.nio.channels.FileChannel
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public close(): void
            protected finalize(): void
            public static class: java.lang.Class<any>
        }
        class SocketPermission extends java.security.Permission implements java.io.Serializable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        class SocketTimeoutException extends java.io.InterruptedIOException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        interface SocksConsts {
            PROTO_VERS4: int
            PROTO_VERS: int
            DEFAULT_PORT: int
            NO_AUTH: int
            GSSAPI: int
            USER_PASSW: int
            NO_METHODS: int
            CONNECT: int
            BIND: int
            UDP_ASSOC: int
            IPV4: int
            DOMAIN_NAME: int
            IPV6: int
            REQUEST_OK: int
            GENERAL_FAILURE: int
            NOT_ALLOWED: int
            NET_UNREACHABLE: int
            HOST_UNREACHABLE: int
            CONN_REFUSED: int
            TTL_EXPIRED: int
            CMD_NOT_SUPPORTED: int
            ADDR_TYPE_NOT_SUP: int
        }
        class SocksSocketImpl extends java.net.PlainSocketImpl implements java.net.SocksConsts {
            protected connect(arg0: java.net.SocketAddress, arg1: int): void
            protected socksBind(arg0: java.net.InetSocketAddress): void
            protected acceptFrom(arg0: java.net.SocketImpl, arg1: java.net.InetSocketAddress): void
            protected getInetAddress(): java.net.InetAddress
            protected getPort(): int
            protected getLocalPort(): int
            protected close(): void
            public static class: java.lang.Class<any>
        }
        class StandardProtocolFamily extends java.lang.Enum<java.net.StandardProtocolFamily> implements java.net.ProtocolFamily {
            public static INET: java.net.StandardProtocolFamily
            public static INET6: java.net.StandardProtocolFamily
            public static values(): java.net.StandardProtocolFamily[]
            public static valueOf(arg0: java.lang.String | string): java.net.StandardProtocolFamily
            public static class: java.lang.Class<any>
        }
        class StandardProtocolFamily$$Lambda extends java.lang.Enum<java.net.StandardProtocolFamily> implements java.net.ProtocolFamily {
            public static INET: java.net.StandardProtocolFamily
        }
        class StandardSocketOptions {
            public static SO_BROADCAST: java.net.SocketOption<java.lang.Boolean>
            public static SO_KEEPALIVE: java.net.SocketOption<java.lang.Boolean>
            public static SO_SNDBUF: java.net.SocketOption<java.lang.Integer>
            public static SO_RCVBUF: java.net.SocketOption<java.lang.Integer>
            public static SO_REUSEADDR: java.net.SocketOption<java.lang.Boolean>
            public static SO_LINGER: java.net.SocketOption<java.lang.Integer>
            public static IP_TOS: java.net.SocketOption<java.lang.Integer>
            public static IP_MULTICAST_IF: java.net.SocketOption<java.net.NetworkInterface>
            public static IP_MULTICAST_TTL: java.net.SocketOption<java.lang.Integer>
            public static IP_MULTICAST_LOOP: java.net.SocketOption<java.lang.Boolean>
            public static TCP_NODELAY: java.net.SocketOption<java.lang.Boolean>
            public static class: java.lang.Class<any>
        }
        class URI implements java.lang.Comparable<java.net.URI> , java.io.Serializable {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int, arg4: java.lang.String | string, arg5: java.lang.String | string, arg6: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
            public static create(arg0: java.lang.String | string): java.net.URI
            public parseServerAuthority(): java.net.URI
            public normalize(): java.net.URI
            public resolve(arg0: java.net.URI): java.net.URI
            public resolve(arg0: java.lang.String | string): java.net.URI
            public relativize(arg0: java.net.URI): java.net.URI
            public toURL(): java.net.URL
            public getScheme(): string
            public isAbsolute(): boolean
            public isOpaque(): boolean
            public getRawSchemeSpecificPart(): string
            public getSchemeSpecificPart(): string
            public getRawAuthority(): string
            public getAuthority(): string
            public getRawUserInfo(): string
            public getUserInfo(): string
            public getHost(): string
            public getPort(): int
            public getRawPath(): string
            public getPath(): string
            public getRawQuery(): string
            public getQuery(): string
            public getRawFragment(): string
            public getFragment(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public compareTo(arg0: java.net.URI): int
            public toString(): string
            public toASCIIString(): string
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class URISyntaxException extends java.lang.Exception {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: int)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public getInput(): string
            public getReason(): string
            public getIndex(): int
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class URL implements java.io.Serializable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: int, arg3: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: int, arg3: java.lang.String | string, arg4: java.net.URLStreamHandler)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.net.URL, arg1: java.lang.String | string)
            public constructor(arg0: java.net.URL, arg1: java.lang.String | string, arg2: java.net.URLStreamHandler)
            public getQuery(): string
            public getPath(): string
            public getUserInfo(): string
            public getAuthority(): string
            public getPort(): int
            public getDefaultPort(): int
            public getProtocol(): string
            public getHost(): string
            public getFile(): string
            public getRef(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public sameFile(arg0: java.net.URL): boolean
            public toString(): string
            public toExternalForm(): string
            public toURI(): java.net.URI
            public openConnection(): java.net.URLConnection
            public openConnection(arg0: java.net.Proxy): java.net.URLConnection
            public openStream(): java.io.InputStream
            public getContent(): java.lang.Object
            public getContent(arg0: java.lang.Class[]): java.lang.Object
            public static setURLStreamHandlerFactory(arg0: java.net.URLStreamHandlerFactory | java.net.URLStreamHandlerFactory$$Lambda): void
            public static class: java.lang.Class<any>
        }
        class URLClassLoader extends java.security.SecureClassLoader implements java.io.Closeable {
            public constructor(arg0: java.net.URL[], arg1: java.lang.ClassLoader)
            public constructor(arg0: java.net.URL[])
            public constructor(arg0: java.net.URL[], arg1: java.lang.ClassLoader, arg2: java.net.URLStreamHandlerFactory | java.net.URLStreamHandlerFactory$$Lambda)
            public getResourceAsStream(arg0: java.lang.String | string): java.io.InputStream
            public close(): void
            protected addURL(arg0: java.net.URL): void
            public getURLs(): java.net.URL[]
            protected findClass(arg0: java.lang.String | string): java.lang.Class<any>
            protected definePackage(arg0: java.lang.String | string, arg1: java.util.jar.Manifest, arg2: java.net.URL): java.lang.Package
            public findResource(arg0: java.lang.String | string): java.net.URL
            public findResources(arg0: java.lang.String | string): java.util.Enumeration<java.net.URL>
            protected getPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
            public static newInstance(arg0: java.net.URL[], arg1: java.lang.ClassLoader): java.net.URLClassLoader
            public static newInstance(arg0: java.net.URL[]): java.net.URLClassLoader
            public static class: java.lang.Class<any>
        }
        abstract class URLConnection {
            protected url: java.net.URL
            protected doInput: boolean
            protected doOutput: boolean
            protected allowUserInteraction: boolean
            protected useCaches: boolean
            protected ifModifiedSince: long
            protected connected: boolean
            public static getFileNameMap(): java.net.FileNameMap
            public static setFileNameMap(arg0: java.net.FileNameMap | java.net.FileNameMap$$Lambda): void
            public connect(): void
            public setConnectTimeout(arg0: int): void
            public getConnectTimeout(): int
            public setReadTimeout(arg0: int): void
            public getReadTimeout(): int
            protected constructor(arg0: java.net.URL)
            public getURL(): java.net.URL
            public getContentLength(): int
            public getContentLengthLong(): long
            public getContentType(): string
            public getContentEncoding(): string
            public getExpiration(): long
            public getDate(): long
            public getLastModified(): long
            public getHeaderField(arg0: java.lang.String | string): string
            public getHeaderFields(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
            public getHeaderFieldInt(arg0: java.lang.String | string, arg1: int): int
            public getHeaderFieldLong(arg0: java.lang.String | string, arg1: long): long
            public getHeaderFieldDate(arg0: java.lang.String | string, arg1: long): long
            public getHeaderFieldKey(arg0: int): string
            public getHeaderField(arg0: int): string
            public getContent(): java.lang.Object
            public getContent(arg0: java.lang.Class[]): java.lang.Object
            public getPermission(): java.security.Permission
            public getInputStream(): java.io.InputStream
            public getOutputStream(): java.io.OutputStream
            public toString(): string
            public setDoInput(arg0: boolean): void
            public getDoInput(): boolean
            public setDoOutput(arg0: boolean): void
            public getDoOutput(): boolean
            public setAllowUserInteraction(arg0: boolean): void
            public getAllowUserInteraction(): boolean
            public static setDefaultAllowUserInteraction(arg0: boolean): void
            public static getDefaultAllowUserInteraction(): boolean
            public setUseCaches(arg0: boolean): void
            public getUseCaches(): boolean
            public setIfModifiedSince(arg0: long): void
            public getIfModifiedSince(): long
            public getDefaultUseCaches(): boolean
            public setDefaultUseCaches(arg0: boolean): void
            public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
            public addRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
            public getRequestProperty(arg0: java.lang.String | string): string
            public getRequestProperties(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
            public static setDefaultRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
            public static getDefaultRequestProperty(arg0: java.lang.String | string): string
            public static setContentHandlerFactory(arg0: java.net.ContentHandlerFactory | java.net.ContentHandlerFactory$$Lambda): void
            public static guessContentTypeFromName(arg0: java.lang.String | string): string
            public static guessContentTypeFromStream(arg0: java.io.InputStream): string
            public static class: java.lang.Class<any>
        }
        class URLDecoder {
            public constructor()
            public static decode(arg0: java.lang.String | string): string
            public static decode(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public static class: java.lang.Class<any>
        }
        class URLEncoder {
            public static encode(arg0: java.lang.String | string): string
            public static encode(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public static class: java.lang.Class<any>
        }
        class URLPermission extends java.security.Permission {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.lang.String | string)
            public getActions(): string
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        abstract class URLStreamHandler {
            public constructor()
            protected openConnection(arg0: java.net.URL): java.net.URLConnection
            protected openConnection(arg0: java.net.URL, arg1: java.net.Proxy): java.net.URLConnection
            protected parseURL(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: int): void
            protected getDefaultPort(): int
            protected equals(arg0: java.net.URL, arg1: java.net.URL): boolean
            protected hashCode(arg0: java.net.URL): int
            protected sameFile(arg0: java.net.URL, arg1: java.net.URL): boolean
            protected getHostAddress(arg0: java.net.URL): java.net.InetAddress
            protected hostsEqual(arg0: java.net.URL, arg1: java.net.URL): boolean
            protected toExternalForm(arg0: java.net.URL): string
            protected setURL(arg0: java.net.URL, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int, arg4: java.lang.String | string, arg5: java.lang.String | string, arg6: java.lang.String | string, arg7: java.lang.String | string, arg8: java.lang.String | string): void
            protected setURL(arg0: java.net.URL, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int, arg4: java.lang.String | string, arg5: java.lang.String | string): void
            public static class: java.lang.Class<any>
        }
        interface URLStreamHandlerFactory {
            createURLStreamHandler(arg0: java.lang.String | string): java.net.URLStreamHandler
        }
        interface URLStreamHandlerFactory$$Lambda {
            (arg0: java.lang.String | string): java.net.URLStreamHandler
        }
        class UnknownHostException extends java.io.IOException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        class UnknownServiceException extends java.io.IOException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
    }
    namespace nio {
        namespace channels {
            namespace spi {
                abstract class AbstractInterruptibleChannel implements java.nio.channels.Channel , java.nio.channels.InterruptibleChannel {
                    protected constructor()
                    public close(): void
                    protected implCloseChannel(): void
                    public isOpen(): boolean
                    protected begin(): void
                    protected end(arg0: boolean): void
                    public static class: java.lang.Class<any>
                }
                abstract class AbstractSelectableChannel extends java.nio.channels.SelectableChannel {
                    protected constructor(arg0: java.nio.channels.spi.SelectorProvider)
                    public provider(): java.nio.channels.spi.SelectorProvider
                    public isRegistered(): boolean
                    public keyFor(arg0: java.nio.channels.Selector): java.nio.channels.SelectionKey
                    public register(arg0: java.nio.channels.Selector, arg1: int, arg2: java.lang.Object): java.nio.channels.SelectionKey
                    protected implCloseChannel(): void
                    protected implCloseSelectableChannel(): void
                    public isBlocking(): boolean
                    public blockingLock(): java.lang.Object
                    public configureBlocking(arg0: boolean): java.nio.channels.SelectableChannel
                    protected implConfigureBlocking(arg0: boolean): void
                    public static class: java.lang.Class<any>
                }
                abstract class AbstractSelectionKey extends java.nio.channels.SelectionKey {
                    protected constructor()
                    public isValid(): boolean
                    public cancel(): void
                    public static class: java.lang.Class<any>
                }
                abstract class AbstractSelector extends java.nio.channels.Selector {
                    protected constructor(arg0: java.nio.channels.spi.SelectorProvider)
                    public close(): void
                    protected implCloseSelector(): void
                    public isOpen(): boolean
                    public provider(): java.nio.channels.spi.SelectorProvider
                    protected cancelledKeys(): java.util.Set<java.nio.channels.SelectionKey>
                    protected register(arg0: java.nio.channels.spi.AbstractSelectableChannel, arg1: int, arg2: java.lang.Object): java.nio.channels.SelectionKey
                    protected deregister(arg0: java.nio.channels.spi.AbstractSelectionKey): void
                    protected begin(): void
                    protected end(): void
                    public static class: java.lang.Class<any>
                }
                abstract class AsynchronousChannelProvider {
                    protected constructor()
                    public static provider(): java.nio.channels.spi.AsynchronousChannelProvider
                    public openAsynchronousChannelGroup(arg0: int, arg1: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.nio.channels.AsynchronousChannelGroup
                    public openAsynchronousChannelGroup(arg0: java.util.concurrent.ExecutorService, arg1: int): java.nio.channels.AsynchronousChannelGroup
                    public openAsynchronousServerSocketChannel(arg0: java.nio.channels.AsynchronousChannelGroup): java.nio.channels.AsynchronousServerSocketChannel
                    public openAsynchronousSocketChannel(arg0: java.nio.channels.AsynchronousChannelGroup): java.nio.channels.AsynchronousSocketChannel
                    public static class: java.lang.Class<any>
                }
                abstract class SelectorProvider {
                    protected constructor()
                    public static provider(): java.nio.channels.spi.SelectorProvider
                    public openDatagramChannel(): java.nio.channels.DatagramChannel
                    public openDatagramChannel(arg0: java.net.ProtocolFamily | java.net.ProtocolFamily$$Lambda): java.nio.channels.DatagramChannel
                    public openPipe(): java.nio.channels.Pipe
                    public openSelector(): java.nio.channels.spi.AbstractSelector
                    public openServerSocketChannel(): java.nio.channels.ServerSocketChannel
                    public openSocketChannel(): java.nio.channels.SocketChannel
                    public inheritedChannel(): java.nio.channels.Channel
                    public static class: java.lang.Class<any>
                }
            }
            interface AsynchronousByteChannel extends java.nio.channels.AsynchronousChannel {
                read<A>(arg0: java.nio.ByteBuffer, arg1: A, arg2: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                read(arg0: java.nio.ByteBuffer): java.util.concurrent.Future<java.lang.Integer>
                write<A>(arg0: java.nio.ByteBuffer, arg1: A, arg2: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                write(arg0: java.nio.ByteBuffer): java.util.concurrent.Future<java.lang.Integer>
            }
            interface AsynchronousChannel extends java.nio.channels.Channel {
                close(): void
            }
            abstract class AsynchronousChannelGroup {
                protected constructor(arg0: java.nio.channels.spi.AsynchronousChannelProvider)
                public provider(): java.nio.channels.spi.AsynchronousChannelProvider
                public static withFixedThreadPool(arg0: int, arg1: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.nio.channels.AsynchronousChannelGroup
                public static withCachedThreadPool(arg0: java.util.concurrent.ExecutorService, arg1: int): java.nio.channels.AsynchronousChannelGroup
                public static withThreadPool(arg0: java.util.concurrent.ExecutorService): java.nio.channels.AsynchronousChannelGroup
                public isShutdown(): boolean
                public isTerminated(): boolean
                public shutdown(): void
                public shutdownNow(): void
                public awaitTermination(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousFileChannel implements java.nio.channels.AsynchronousChannel {
                protected constructor()
                public static open(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.OpenOption>, arg2: java.util.concurrent.ExecutorService, ...arg3: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.AsynchronousFileChannel
                public static open(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.nio.channels.AsynchronousFileChannel
                public size(): long
                public truncate(arg0: long): java.nio.channels.AsynchronousFileChannel
                public force(arg0: boolean): void
                public lock<A>(arg0: long, arg1: long, arg2: boolean, arg3: A, arg4: java.nio.channels.CompletionHandler<java.nio.channels.FileLock, A>): void
                public lock<A>(arg0: A, arg1: java.nio.channels.CompletionHandler<java.nio.channels.FileLock, A>): void
                public lock(arg0: long, arg1: long, arg2: boolean): java.util.concurrent.Future<java.nio.channels.FileLock>
                public lock(): java.util.concurrent.Future<java.nio.channels.FileLock>
                public tryLock(arg0: long, arg1: long, arg2: boolean): java.nio.channels.FileLock
                public tryLock(): java.nio.channels.FileLock
                public read<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public read(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<java.lang.Integer>
                public write<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public write(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<java.lang.Integer>
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousServerSocketChannel implements java.nio.channels.AsynchronousChannel , java.nio.channels.NetworkChannel {
                protected constructor(arg0: java.nio.channels.spi.AsynchronousChannelProvider)
                public provider(): java.nio.channels.spi.AsynchronousChannelProvider
                public static open(arg0: java.nio.channels.AsynchronousChannelGroup): java.nio.channels.AsynchronousServerSocketChannel
                public static open(): java.nio.channels.AsynchronousServerSocketChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.AsynchronousServerSocketChannel
                public bind(arg0: java.net.SocketAddress, arg1: int): java.nio.channels.AsynchronousServerSocketChannel
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.AsynchronousServerSocketChannel
                public accept<A>(arg0: A, arg1: java.nio.channels.CompletionHandler<java.nio.channels.AsynchronousSocketChannel, A>): void
                public accept(): java.util.concurrent.Future<java.nio.channels.AsynchronousSocketChannel>
                public getLocalAddress(): java.net.SocketAddress
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousSocketChannel implements java.nio.channels.AsynchronousByteChannel , java.nio.channels.NetworkChannel {
                protected constructor(arg0: java.nio.channels.spi.AsynchronousChannelProvider)
                public provider(): java.nio.channels.spi.AsynchronousChannelProvider
                public static open(arg0: java.nio.channels.AsynchronousChannelGroup): java.nio.channels.AsynchronousSocketChannel
                public static open(): java.nio.channels.AsynchronousSocketChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.AsynchronousSocketChannel
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.AsynchronousSocketChannel
                public shutdownInput(): java.nio.channels.AsynchronousSocketChannel
                public shutdownOutput(): java.nio.channels.AsynchronousSocketChannel
                public getRemoteAddress(): java.net.SocketAddress
                public connect<A>(arg0: java.net.SocketAddress, arg1: A, arg2: java.nio.channels.CompletionHandler<java.lang.Void, A>): void
                public connect(arg0: java.net.SocketAddress): java.util.concurrent.Future<java.lang.Void>
                public read<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: java.util.concurrent.TimeUnit, arg3: A, arg4: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public read<A>(arg0: java.nio.ByteBuffer, arg1: A, arg2: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public read(arg0: java.nio.ByteBuffer): java.util.concurrent.Future<java.lang.Integer>
                public read<A>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int, arg3: long, arg4: java.util.concurrent.TimeUnit, arg5: A, arg6: java.nio.channels.CompletionHandler<java.lang.Long, A>): void
                public write<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: java.util.concurrent.TimeUnit, arg3: A, arg4: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public write<A>(arg0: java.nio.ByteBuffer, arg1: A, arg2: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public write(arg0: java.nio.ByteBuffer): java.util.concurrent.Future<java.lang.Integer>
                public write<A>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int, arg3: long, arg4: java.util.concurrent.TimeUnit, arg5: A, arg6: java.nio.channels.CompletionHandler<java.lang.Long, A>): void
                public getLocalAddress(): java.net.SocketAddress
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            interface ByteChannel extends java.nio.channels.ReadableByteChannel , java.nio.channels.WritableByteChannel {
            }
            interface Channel extends java.io.Closeable {
                isOpen(): boolean
                close(): void
            }
            class Channels {
                public static newInputStream(arg0: java.nio.channels.ReadableByteChannel): java.io.InputStream
                public static newOutputStream(arg0: java.nio.channels.WritableByteChannel): java.io.OutputStream
                public static newInputStream(arg0: java.nio.channels.AsynchronousByteChannel): java.io.InputStream
                public static newOutputStream(arg0: java.nio.channels.AsynchronousByteChannel): java.io.OutputStream
                public static newChannel(arg0: java.io.InputStream): java.nio.channels.ReadableByteChannel
                public static newChannel(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): java.nio.channels.WritableByteChannel
                public static newReader(arg0: java.nio.channels.ReadableByteChannel, arg1: java.nio.charset.CharsetDecoder, arg2: int): java.io.Reader
                public static newReader(arg0: java.nio.channels.ReadableByteChannel, arg1: java.lang.String | string): java.io.Reader
                public static newWriter(arg0: java.nio.channels.WritableByteChannel, arg1: java.nio.charset.CharsetEncoder, arg2: int): java.io.Writer
                public static newWriter(arg0: java.nio.channels.WritableByteChannel, arg1: java.lang.String | string): java.io.Writer
                public static class: java.lang.Class<any>
            }
            interface CompletionHandler<V, A> {
                completed(arg0: V, arg1: A): void
                failed(arg0: java.lang.Throwable, arg1: A): void
            }
            abstract class DatagramChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel , java.nio.channels.ScatteringByteChannel , java.nio.channels.GatheringByteChannel , java.nio.channels.MulticastChannel {
                protected constructor(arg0: java.nio.channels.spi.SelectorProvider)
                public static open(): java.nio.channels.DatagramChannel
                public static open(arg0: java.net.ProtocolFamily | java.net.ProtocolFamily$$Lambda): java.nio.channels.DatagramChannel
                public validOps(): int
                public bind(arg0: java.net.SocketAddress): java.nio.channels.DatagramChannel
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.DatagramChannel
                public socket(): java.net.DatagramSocket
                public isConnected(): boolean
                public connect(arg0: java.net.SocketAddress): java.nio.channels.DatagramChannel
                public disconnect(): java.nio.channels.DatagramChannel
                public getRemoteAddress(): java.net.SocketAddress
                public receive(arg0: java.nio.ByteBuffer): java.net.SocketAddress
                public send(arg0: java.nio.ByteBuffer, arg1: java.net.SocketAddress): int
                public read(arg0: java.nio.ByteBuffer): int
                public read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public read(arg0: java.nio.ByteBuffer[]): long
                public write(arg0: java.nio.ByteBuffer): int
                public write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public write(arg0: java.nio.ByteBuffer[]): long
                public getLocalAddress(): java.net.SocketAddress
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            abstract class FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.SeekableByteChannel , java.nio.channels.GatheringByteChannel , java.nio.channels.ScatteringByteChannel {
                protected constructor()
                public static open(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.OpenOption>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.FileChannel
                public static open(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.nio.channels.FileChannel
                public read(arg0: java.nio.ByteBuffer): int
                public read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public read(arg0: java.nio.ByteBuffer[]): long
                public write(arg0: java.nio.ByteBuffer): int
                public write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public write(arg0: java.nio.ByteBuffer[]): long
                public position(): long
                public position(arg0: long): java.nio.channels.FileChannel
                public size(): long
                public truncate(arg0: long): java.nio.channels.FileChannel
                public force(arg0: boolean): void
                public transferTo(arg0: long, arg1: long, arg2: java.nio.channels.WritableByteChannel): long
                public transferFrom(arg0: java.nio.channels.ReadableByteChannel, arg1: long, arg2: long): long
                public read(arg0: java.nio.ByteBuffer, arg1: long): int
                public write(arg0: java.nio.ByteBuffer, arg1: long): int
                public map(arg0: java.nio.channels.FileChannel$MapMode, arg1: long, arg2: long): java.nio.MappedByteBuffer
                public lock(arg0: long, arg1: long, arg2: boolean): java.nio.channels.FileLock
                public lock(): java.nio.channels.FileLock
                public tryLock(arg0: long, arg1: long, arg2: boolean): java.nio.channels.FileLock
                public tryLock(): java.nio.channels.FileLock
                public truncate(arg0: long): java.nio.channels.SeekableByteChannel
                public position(arg0: long): java.nio.channels.SeekableByteChannel
                public static class: java.lang.Class<any>
            }
            abstract class FileLock implements java.lang.AutoCloseable {
                protected constructor(arg0: java.nio.channels.FileChannel, arg1: long, arg2: long, arg3: boolean)
                protected constructor(arg0: java.nio.channels.AsynchronousFileChannel, arg1: long, arg2: long, arg3: boolean)
                public channel(): java.nio.channels.FileChannel
                public acquiredBy(): java.nio.channels.Channel
                public position(): long
                public size(): long
                public isShared(): boolean
                public overlaps(arg0: long, arg1: long): boolean
                public isValid(): boolean
                public release(): void
                public close(): void
                public toString(): string
                public static class: java.lang.Class<any>
            }
            abstract class FileLock$$Lambda implements java.lang.AutoCloseable {
                protected constructor(arg0: java.nio.channels.FileChannel, arg1: long, arg2: long, arg3: boolean)
            }
            interface GatheringByteChannel extends java.nio.channels.WritableByteChannel {
                write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                write(arg0: java.nio.ByteBuffer[]): long
            }
            interface InterruptibleChannel extends java.nio.channels.Channel {
                close(): void
            }
            abstract class MembershipKey {
                protected constructor()
                public isValid(): boolean
                public drop(): void
                public block(arg0: java.net.InetAddress): java.nio.channels.MembershipKey
                public unblock(arg0: java.net.InetAddress): java.nio.channels.MembershipKey
                public channel(): java.nio.channels.MulticastChannel
                public group(): java.net.InetAddress
                public networkInterface(): java.net.NetworkInterface
                public sourceAddress(): java.net.InetAddress
                public static class: java.lang.Class<any>
            }
            interface MulticastChannel extends java.nio.channels.NetworkChannel {
                close(): void
                join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface): java.nio.channels.MembershipKey
                join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface, arg2: java.net.InetAddress): java.nio.channels.MembershipKey
            }
            interface NetworkChannel extends java.nio.channels.Channel {
                bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                getLocalAddress(): java.net.SocketAddress
                setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.NetworkChannel
                getOption<T>(arg0: java.net.SocketOption<T>): T
                supportedOptions(): java.util.Set<java.net.SocketOption<any>>
            }
            abstract class Pipe {
                protected constructor()
                public source(): java.nio.channels.Pipe$SourceChannel
                public sink(): java.nio.channels.Pipe$SinkChannel
                public static open(): java.nio.channels.Pipe
                public static class: java.lang.Class<any>
            }
            interface ReadableByteChannel extends java.nio.channels.Channel {
                read(arg0: java.nio.ByteBuffer): int
            }
            interface ScatteringByteChannel extends java.nio.channels.ReadableByteChannel {
                read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                read(arg0: java.nio.ByteBuffer[]): long
            }
            interface SeekableByteChannel extends java.nio.channels.ByteChannel {
                read(arg0: java.nio.ByteBuffer): int
                write(arg0: java.nio.ByteBuffer): int
                position(): long
                position(arg0: long): java.nio.channels.SeekableByteChannel
                size(): long
                truncate(arg0: long): java.nio.channels.SeekableByteChannel
            }
            abstract class SelectableChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.Channel {
                protected constructor()
                public provider(): java.nio.channels.spi.SelectorProvider
                public validOps(): int
                public isRegistered(): boolean
                public keyFor(arg0: java.nio.channels.Selector): java.nio.channels.SelectionKey
                public register(arg0: java.nio.channels.Selector, arg1: int, arg2: java.lang.Object): java.nio.channels.SelectionKey
                public register(arg0: java.nio.channels.Selector, arg1: int): java.nio.channels.SelectionKey
                public configureBlocking(arg0: boolean): java.nio.channels.SelectableChannel
                public isBlocking(): boolean
                public blockingLock(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class SelectionKey {
                public static OP_READ: int
                public static OP_WRITE: int
                public static OP_CONNECT: int
                public static OP_ACCEPT: int
                protected constructor()
                public channel(): java.nio.channels.SelectableChannel
                public selector(): java.nio.channels.Selector
                public isValid(): boolean
                public cancel(): void
                public interestOps(): int
                public interestOps(arg0: int): java.nio.channels.SelectionKey
                public readyOps(): int
                public isReadable(): boolean
                public isWritable(): boolean
                public isConnectable(): boolean
                public isAcceptable(): boolean
                public attach(arg0: java.lang.Object): java.lang.Object
                public attachment(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class Selector implements java.io.Closeable {
                protected constructor()
                public static open(): java.nio.channels.Selector
                public isOpen(): boolean
                public provider(): java.nio.channels.spi.SelectorProvider
                public keys(): java.util.Set<java.nio.channels.SelectionKey>
                public selectedKeys(): java.util.Set<java.nio.channels.SelectionKey>
                public selectNow(): int
                public select(arg0: long): int
                public select(): int
                public wakeup(): java.nio.channels.Selector
                public close(): void
                public static class: java.lang.Class<any>
            }
            abstract class ServerSocketChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.NetworkChannel {
                protected constructor(arg0: java.nio.channels.spi.SelectorProvider)
                public static open(): java.nio.channels.ServerSocketChannel
                public validOps(): int
                public bind(arg0: java.net.SocketAddress): java.nio.channels.ServerSocketChannel
                public bind(arg0: java.net.SocketAddress, arg1: int): java.nio.channels.ServerSocketChannel
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.ServerSocketChannel
                public socket(): java.net.ServerSocket
                public accept(): java.nio.channels.SocketChannel
                public getLocalAddress(): java.net.SocketAddress
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            abstract class SocketChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel , java.nio.channels.ScatteringByteChannel , java.nio.channels.GatheringByteChannel , java.nio.channels.NetworkChannel {
                protected constructor(arg0: java.nio.channels.spi.SelectorProvider)
                public static open(): java.nio.channels.SocketChannel
                public static open(arg0: java.net.SocketAddress): java.nio.channels.SocketChannel
                public validOps(): int
                public bind(arg0: java.net.SocketAddress): java.nio.channels.SocketChannel
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.SocketChannel
                public shutdownInput(): java.nio.channels.SocketChannel
                public shutdownOutput(): java.nio.channels.SocketChannel
                public socket(): java.net.Socket
                public isConnected(): boolean
                public isConnectionPending(): boolean
                public connect(arg0: java.net.SocketAddress): boolean
                public finishConnect(): boolean
                public getRemoteAddress(): java.net.SocketAddress
                public read(arg0: java.nio.ByteBuffer): int
                public read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public read(arg0: java.nio.ByteBuffer[]): long
                public write(arg0: java.nio.ByteBuffer): int
                public write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public write(arg0: java.nio.ByteBuffer[]): long
                public getLocalAddress(): java.net.SocketAddress
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            interface WritableByteChannel extends java.nio.channels.Channel {
                write(arg0: java.nio.ByteBuffer): int
            }
        }
        namespace charset {
            namespace spi {
                abstract class CharsetProvider {
                    protected constructor()
                    public charsets(): java.util.Iterator<java.nio.charset.Charset>
                    public charsetForName(arg0: java.lang.String | string): java.nio.charset.Charset
                    public static class: java.lang.Class<any>
                }
            }
            abstract class Charset implements java.lang.Comparable<java.nio.charset.Charset> {
                public static isSupported(arg0: java.lang.String | string): boolean
                public static forName(arg0: java.lang.String | string): java.nio.charset.Charset
                public static availableCharsets(): java.util.SortedMap<java.lang.String, java.nio.charset.Charset>
                public static defaultCharset(): java.nio.charset.Charset
                protected constructor(arg0: java.lang.String | string, arg1: java.lang.String[])
                public name(): string
                public aliases(): java.util.Set<java.lang.String>
                public displayName(): string
                public isRegistered(): boolean
                public displayName(arg0: java.util.Locale): string
                public contains(arg0: java.nio.charset.Charset): boolean
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public canEncode(): boolean
                public decode(arg0: java.nio.ByteBuffer): java.nio.CharBuffer
                public encode(arg0: java.nio.CharBuffer): java.nio.ByteBuffer
                public encode(arg0: java.lang.String | string): java.nio.ByteBuffer
                public compareTo(arg0: java.nio.charset.Charset): int
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public toString(): string
                public compareTo(arg0: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            class CoderMalfunctionError extends java.lang.Error {
                public constructor(arg0: java.lang.Exception)
                public static class: java.lang.Class<any>
            }
            class CoderResult {
                public static UNDERFLOW: java.nio.charset.CoderResult
                public static OVERFLOW: java.nio.charset.CoderResult
                public toString(): string
                public isUnderflow(): boolean
                public isOverflow(): boolean
                public isError(): boolean
                public isMalformed(): boolean
                public isUnmappable(): boolean
                public length(): int
                public static malformedForLength(arg0: int): java.nio.charset.CoderResult
                public static unmappableForLength(arg0: int): java.nio.charset.CoderResult
                public throwException(): void
                public static class: java.lang.Class<any>
            }
            class CodingErrorAction {
                public static IGNORE: java.nio.charset.CodingErrorAction
                public static REPLACE: java.nio.charset.CodingErrorAction
                public static REPORT: java.nio.charset.CodingErrorAction
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class MalformedInputException extends java.nio.charset.CharacterCodingException {
                public constructor(arg0: int)
                public getInputLength(): int
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
            class StandardCharsets {
                public static US_ASCII: java.nio.charset.Charset
                public static ISO_8859_1: java.nio.charset.Charset
                public static UTF_8: java.nio.charset.Charset
                public static UTF_16BE: java.nio.charset.Charset
                public static UTF_16LE: java.nio.charset.Charset
                public static UTF_16: java.nio.charset.Charset
                public static class: java.lang.Class<any>
            }
            class UnmappableCharacterException extends java.nio.charset.CharacterCodingException {
                public constructor(arg0: int)
                public getInputLength(): int
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
        }
        namespace file {
            namespace attribute {
                class AclEntry {
                    public static newBuilder(): java.nio.file.attribute.AclEntry$Builder
                    public static newBuilder(arg0: java.nio.file.attribute.AclEntry): java.nio.file.attribute.AclEntry$Builder
                    public type(): java.nio.file.attribute.AclEntryType
                    public principal(): java.nio.file.attribute.UserPrincipal
                    public permissions(): java.util.Set<java.nio.file.attribute.AclEntryPermission>
                    public flags(): java.util.Set<java.nio.file.attribute.AclEntryFlag>
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class AclEntryFlag extends java.lang.Enum<java.nio.file.attribute.AclEntryFlag> {
                    public static FILE_INHERIT: java.nio.file.attribute.AclEntryFlag
                    public static DIRECTORY_INHERIT: java.nio.file.attribute.AclEntryFlag
                    public static NO_PROPAGATE_INHERIT: java.nio.file.attribute.AclEntryFlag
                    public static INHERIT_ONLY: java.nio.file.attribute.AclEntryFlag
                    public static values(): java.nio.file.attribute.AclEntryFlag[]
                    public static valueOf(arg0: java.lang.String | string): java.nio.file.attribute.AclEntryFlag
                    public static class: java.lang.Class<any>
                }
                class AclEntryPermission extends java.lang.Enum<java.nio.file.attribute.AclEntryPermission> {
                    public static READ_DATA: java.nio.file.attribute.AclEntryPermission
                    public static WRITE_DATA: java.nio.file.attribute.AclEntryPermission
                    public static APPEND_DATA: java.nio.file.attribute.AclEntryPermission
                    public static READ_NAMED_ATTRS: java.nio.file.attribute.AclEntryPermission
                    public static WRITE_NAMED_ATTRS: java.nio.file.attribute.AclEntryPermission
                    public static EXECUTE: java.nio.file.attribute.AclEntryPermission
                    public static DELETE_CHILD: java.nio.file.attribute.AclEntryPermission
                    public static READ_ATTRIBUTES: java.nio.file.attribute.AclEntryPermission
                    public static WRITE_ATTRIBUTES: java.nio.file.attribute.AclEntryPermission
                    public static DELETE: java.nio.file.attribute.AclEntryPermission
                    public static READ_ACL: java.nio.file.attribute.AclEntryPermission
                    public static WRITE_ACL: java.nio.file.attribute.AclEntryPermission
                    public static WRITE_OWNER: java.nio.file.attribute.AclEntryPermission
                    public static SYNCHRONIZE: java.nio.file.attribute.AclEntryPermission
                    public static LIST_DIRECTORY: java.nio.file.attribute.AclEntryPermission
                    public static ADD_FILE: java.nio.file.attribute.AclEntryPermission
                    public static ADD_SUBDIRECTORY: java.nio.file.attribute.AclEntryPermission
                    public static values(): java.nio.file.attribute.AclEntryPermission[]
                    public static valueOf(arg0: java.lang.String | string): java.nio.file.attribute.AclEntryPermission
                    public static class: java.lang.Class<any>
                }
                class AclEntryType extends java.lang.Enum<java.nio.file.attribute.AclEntryType> {
                    public static ALLOW: java.nio.file.attribute.AclEntryType
                    public static DENY: java.nio.file.attribute.AclEntryType
                    public static AUDIT: java.nio.file.attribute.AclEntryType
                    public static ALARM: java.nio.file.attribute.AclEntryType
                    public static values(): java.nio.file.attribute.AclEntryType[]
                    public static valueOf(arg0: java.lang.String | string): java.nio.file.attribute.AclEntryType
                    public static class: java.lang.Class<any>
                }
                interface AclFileAttributeView extends java.nio.file.attribute.FileOwnerAttributeView {
                    name(): string
                    getAcl(): java.util.List<java.nio.file.attribute.AclEntry>
                    setAcl(arg0: java.util.List<java.nio.file.attribute.AclEntry>): void
                }
                interface AttributeView {
                    name(): string
                }
                interface AttributeView$$Lambda {
                    (): string
                }
                interface BasicFileAttributeView extends java.nio.file.attribute.FileAttributeView {
                    name(): string
                    readAttributes(): java.nio.file.attribute.BasicFileAttributes
                    setTimes(arg0: java.nio.file.attribute.FileTime, arg1: java.nio.file.attribute.FileTime, arg2: java.nio.file.attribute.FileTime): void
                }
                interface BasicFileAttributes {
                    lastModifiedTime(): java.nio.file.attribute.FileTime
                    lastAccessTime(): java.nio.file.attribute.FileTime
                    creationTime(): java.nio.file.attribute.FileTime
                    isRegularFile(): boolean
                    isDirectory(): boolean
                    isSymbolicLink(): boolean
                    isOther(): boolean
                    size(): long
                    fileKey(): java.lang.Object
                }
                interface DosFileAttributeView extends java.nio.file.attribute.BasicFileAttributeView {
                    name(): string
                    readAttributes(): java.nio.file.attribute.DosFileAttributes
                    setReadOnly(arg0: boolean): void
                    setHidden(arg0: boolean): void
                    setSystem(arg0: boolean): void
                    setArchive(arg0: boolean): void
                    readAttributes(): java.nio.file.attribute.BasicFileAttributes
                }
                interface DosFileAttributes extends java.nio.file.attribute.BasicFileAttributes {
                    isReadOnly(): boolean
                    isHidden(): boolean
                    isArchive(): boolean
                    isSystem(): boolean
                }
                interface FileAttribute<T> {
                    name(): string
                    value(): T
                }
                interface FileAttributeView extends java.nio.file.attribute.AttributeView {
                }
                interface FileOwnerAttributeView extends java.nio.file.attribute.FileAttributeView {
                    name(): string
                    getOwner(): java.nio.file.attribute.UserPrincipal
                    setOwner(arg0: java.nio.file.attribute.UserPrincipal): void
                }
                interface FileStoreAttributeView extends java.nio.file.attribute.AttributeView {
                }
                class FileTime implements java.lang.Comparable<java.nio.file.attribute.FileTime> {
                    public static from(arg0: long, arg1: java.util.concurrent.TimeUnit): java.nio.file.attribute.FileTime
                    public static fromMillis(arg0: long): java.nio.file.attribute.FileTime
                    public static from(arg0: java.time.Instant): java.nio.file.attribute.FileTime
                    public to(arg0: java.util.concurrent.TimeUnit): long
                    public toMillis(): long
                    public toInstant(): java.time.Instant
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public compareTo(arg0: java.nio.file.attribute.FileTime): int
                    public toString(): string
                    public compareTo(arg0: java.lang.Object): int
                    public static class: java.lang.Class<any>
                }
                interface GroupPrincipal extends java.nio.file.attribute.UserPrincipal {
                }
                interface PosixFileAttributeView extends java.nio.file.attribute.BasicFileAttributeView , java.nio.file.attribute.FileOwnerAttributeView {
                    name(): string
                    readAttributes(): java.nio.file.attribute.PosixFileAttributes
                    setPermissions(arg0: java.util.Set<java.nio.file.attribute.PosixFilePermission>): void
                    setGroup(arg0: java.nio.file.attribute.GroupPrincipal): void
                    readAttributes(): java.nio.file.attribute.BasicFileAttributes
                }
                interface PosixFileAttributes extends java.nio.file.attribute.BasicFileAttributes {
                    owner(): java.nio.file.attribute.UserPrincipal
                    group(): java.nio.file.attribute.GroupPrincipal
                    permissions(): java.util.Set<java.nio.file.attribute.PosixFilePermission>
                }
                class PosixFilePermission extends java.lang.Enum<java.nio.file.attribute.PosixFilePermission> {
                    public static OWNER_READ: java.nio.file.attribute.PosixFilePermission
                    public static OWNER_WRITE: java.nio.file.attribute.PosixFilePermission
                    public static OWNER_EXECUTE: java.nio.file.attribute.PosixFilePermission
                    public static GROUP_READ: java.nio.file.attribute.PosixFilePermission
                    public static GROUP_WRITE: java.nio.file.attribute.PosixFilePermission
                    public static GROUP_EXECUTE: java.nio.file.attribute.PosixFilePermission
                    public static OTHERS_READ: java.nio.file.attribute.PosixFilePermission
                    public static OTHERS_WRITE: java.nio.file.attribute.PosixFilePermission
                    public static OTHERS_EXECUTE: java.nio.file.attribute.PosixFilePermission
                    public static values(): java.nio.file.attribute.PosixFilePermission[]
                    public static valueOf(arg0: java.lang.String | string): java.nio.file.attribute.PosixFilePermission
                    public static class: java.lang.Class<any>
                }
                class PosixFilePermissions {
                    public static toString(arg0: java.util.Set<java.nio.file.attribute.PosixFilePermission>): string
                    public static fromString(arg0: java.lang.String | string): java.util.Set<java.nio.file.attribute.PosixFilePermission>
                    public static asFileAttribute(arg0: java.util.Set<java.nio.file.attribute.PosixFilePermission>): java.nio.file.attribute.FileAttribute<java.util.Set<java.nio.file.attribute.PosixFilePermission>>
                    public static class: java.lang.Class<any>
                }
                interface UserDefinedFileAttributeView extends java.nio.file.attribute.FileAttributeView {
                    name(): string
                    list(): java.util.List<java.lang.String>
                    size(arg0: java.lang.String | string): int
                    read(arg0: java.lang.String | string, arg1: java.nio.ByteBuffer): int
                    write(arg0: java.lang.String | string, arg1: java.nio.ByteBuffer): int
                    delete(arg0: java.lang.String | string): void
                }
                interface UserPrincipal extends java.security.Principal {
                }
                abstract class UserPrincipalLookupService {
                    protected constructor()
                    public lookupPrincipalByName(arg0: java.lang.String | string): java.nio.file.attribute.UserPrincipal
                    public lookupPrincipalByGroupName(arg0: java.lang.String | string): java.nio.file.attribute.GroupPrincipal
                    public static class: java.lang.Class<any>
                }
                class UserPrincipalNotFoundException extends java.io.IOException {
                    public constructor(arg0: java.lang.String | string)
                    public getName(): string
                    public static class: java.lang.Class<any>
                }
            }
            namespace spi {
                abstract class FileSystemProvider {
                    protected constructor()
                    public static installedProviders(): java.util.List<java.nio.file.spi.FileSystemProvider>
                    public getScheme(): string
                    public newFileSystem(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, any>): java.nio.file.FileSystem
                    public getFileSystem(arg0: java.net.URI): java.nio.file.FileSystem
                    public getPath(arg0: java.net.URI): java.nio.file.Path
                    public newFileSystem(arg0: java.nio.file.Path, arg1: java.util.Map<java.lang.String, any>): java.nio.file.FileSystem
                    public newInputStream(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.InputStream
                    public newOutputStream(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.OutputStream
                    public newFileChannel(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.OpenOption>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.FileChannel
                    public newAsynchronousFileChannel(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.OpenOption>, arg2: java.util.concurrent.ExecutorService, ...arg3: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.AsynchronousFileChannel
                    public newByteChannel(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.OpenOption>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.SeekableByteChannel
                    public newDirectoryStream(arg0: java.nio.file.Path, arg1: java.nio.file.DirectoryStream$Filter<java.nio.file.Path>): java.nio.file.DirectoryStream<java.nio.file.Path>
                    public createDirectory(arg0: java.nio.file.Path, ...arg1: java.nio.file.attribute.FileAttribute<any>[]): void
                    public createSymbolicLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): void
                    public createLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path): void
                    public delete(arg0: java.nio.file.Path): void
                    public deleteIfExists(arg0: java.nio.file.Path): boolean
                    public readSymbolicLink(arg0: java.nio.file.Path): java.nio.file.Path
                    public copy(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): void
                    public move(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): void
                    public isSameFile(arg0: java.nio.file.Path, arg1: java.nio.file.Path): boolean
                    public isHidden(arg0: java.nio.file.Path): boolean
                    public getFileStore(arg0: java.nio.file.Path): java.nio.file.FileStore
                    public checkAccess(arg0: java.nio.file.Path, ...arg1: java.nio.file.AccessMode[]): void
                    public getFileAttributeView<V extends java.nio.file.attribute.FileAttributeView>(arg0: java.nio.file.Path, arg1: java.lang.Class<V>, ...arg2: java.nio.file.LinkOption[]): V
                    public readAttributes<A extends java.nio.file.attribute.BasicFileAttributes>(arg0: java.nio.file.Path, arg1: java.lang.Class<A>, ...arg2: java.nio.file.LinkOption[]): A
                    public readAttributes(arg0: java.nio.file.Path, arg1: java.lang.String | string, ...arg2: java.nio.file.LinkOption[]): java.util.Map<java.lang.String, java.lang.Object>
                    public setAttribute(arg0: java.nio.file.Path, arg1: java.lang.String | string, arg2: java.lang.Object, ...arg3: java.nio.file.LinkOption[]): void
                    public static class: java.lang.Class<any>
                }
                abstract class FileTypeDetector {
                    protected constructor()
                    public probeContentType(arg0: java.nio.file.Path): string
                    public static class: java.lang.Class<any>
                }
            }
            class AccessDeniedException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class AccessMode extends java.lang.Enum<java.nio.file.AccessMode> {
                public static READ: java.nio.file.AccessMode
                public static WRITE: java.nio.file.AccessMode
                public static EXECUTE: java.nio.file.AccessMode
                public static values(): java.nio.file.AccessMode[]
                public static valueOf(arg0: java.lang.String | string): java.nio.file.AccessMode
                public static class: java.lang.Class<any>
            }
            class AtomicMoveNotSupportedException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class ClosedDirectoryStreamException extends java.lang.IllegalStateException {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class ClosedFileSystemException extends java.lang.IllegalStateException {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class ClosedWatchServiceException extends java.lang.IllegalStateException {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class CopyMoveHelper {
                public static class: java.lang.Class<any>
            }
            interface CopyOption {
            }
            class DirectoryIteratorException extends java.util.ConcurrentModificationException {
                public constructor(arg0: java.io.IOException)
                public getCause(): java.io.IOException
                public getCause(): java.lang.Throwable
                public static class: java.lang.Class<any>
            }
            class DirectoryNotEmptyException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface DirectoryStream<T> extends java.io.Closeable , java.lang.Iterable<T> {
                iterator(): java.util.Iterator<T>
            }
            class FileAlreadyExistsException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            abstract class FileStore {
                protected constructor()
                public name(): string
                public type(): string
                public isReadOnly(): boolean
                public getTotalSpace(): long
                public getUsableSpace(): long
                public getUnallocatedSpace(): long
                public supportsFileAttributeView(arg0: java.lang.Class<java.nio.file.attribute.FileAttributeView>): boolean
                public supportsFileAttributeView(arg0: java.lang.String | string): boolean
                public getFileStoreAttributeView<V extends java.nio.file.attribute.FileStoreAttributeView>(arg0: java.lang.Class<V>): V
                public getAttribute(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class FileSystem implements java.io.Closeable {
                protected constructor()
                public provider(): java.nio.file.spi.FileSystemProvider
                public close(): void
                public isOpen(): boolean
                public isReadOnly(): boolean
                public getSeparator(): string
                public getRootDirectories(): java.lang.Iterable<java.nio.file.Path>
                public getFileStores(): java.lang.Iterable<java.nio.file.FileStore>
                public supportedFileAttributeViews(): java.util.Set<java.lang.String>
                public getPath(arg0: java.lang.String | string, ...arg1: java.lang.String[]): java.nio.file.Path
                public getPathMatcher(arg0: java.lang.String | string): java.nio.file.PathMatcher
                public getUserPrincipalLookupService(): java.nio.file.attribute.UserPrincipalLookupService
                public newWatchService(): java.nio.file.WatchService
                public static class: java.lang.Class<any>
            }
            class FileSystemAlreadyExistsException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class FileSystemException extends java.io.IOException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                public getFile(): string
                public getOtherFile(): string
                public getReason(): string
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
            class FileSystemLoopException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class FileSystemNotFoundException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class FileSystems {
                public static getDefault(): java.nio.file.FileSystem
                public static getFileSystem(arg0: java.net.URI): java.nio.file.FileSystem
                public static newFileSystem(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, any>): java.nio.file.FileSystem
                public static newFileSystem(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, any>, arg2: java.lang.ClassLoader): java.nio.file.FileSystem
                public static newFileSystem(arg0: java.nio.file.Path, arg1: java.lang.ClassLoader): java.nio.file.FileSystem
                public static class: java.lang.Class<any>
            }
            class FileTreeIterator implements java.util.Iterator<java.nio.file.FileTreeWalker$Event> , java.io.Closeable {
                public hasNext(): boolean
                public next(): java.nio.file.FileTreeWalker$Event
                public close(): void
                public next(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class FileTreeWalker implements java.io.Closeable {
                public close(): void
                public static class: java.lang.Class<any>
            }
            class FileVisitOption extends java.lang.Enum<java.nio.file.FileVisitOption> {
                public static FOLLOW_LINKS: java.nio.file.FileVisitOption
                public static values(): java.nio.file.FileVisitOption[]
                public static valueOf(arg0: java.lang.String | string): java.nio.file.FileVisitOption
                public static class: java.lang.Class<any>
            }
            class FileVisitResult extends java.lang.Enum<java.nio.file.FileVisitResult> {
                public static CONTINUE: java.nio.file.FileVisitResult
                public static TERMINATE: java.nio.file.FileVisitResult
                public static SKIP_SUBTREE: java.nio.file.FileVisitResult
                public static SKIP_SIBLINGS: java.nio.file.FileVisitResult
                public static values(): java.nio.file.FileVisitResult[]
                public static valueOf(arg0: java.lang.String | string): java.nio.file.FileVisitResult
                public static class: java.lang.Class<any>
            }
            interface FileVisitor<T> {
                preVisitDirectory(arg0: T, arg1: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
                visitFile(arg0: T, arg1: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
                visitFileFailed(arg0: T, arg1: java.io.IOException): java.nio.file.FileVisitResult
                postVisitDirectory(arg0: T, arg1: java.io.IOException): java.nio.file.FileVisitResult
            }
            class Files {
                public static newInputStream(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.InputStream
                public static newOutputStream(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.OutputStream
                public static newByteChannel(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.OpenOption>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.SeekableByteChannel
                public static newByteChannel(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.nio.channels.SeekableByteChannel
                public static newDirectoryStream(arg0: java.nio.file.Path): java.nio.file.DirectoryStream<java.nio.file.Path>
                public static newDirectoryStream(arg0: java.nio.file.Path, arg1: java.lang.String | string): java.nio.file.DirectoryStream<java.nio.file.Path>
                public static newDirectoryStream(arg0: java.nio.file.Path, arg1: java.nio.file.DirectoryStream$Filter<java.nio.file.Path>): java.nio.file.DirectoryStream<java.nio.file.Path>
                public static createFile(arg0: java.nio.file.Path, ...arg1: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createDirectory(arg0: java.nio.file.Path, ...arg1: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createDirectories(arg0: java.nio.file.Path, ...arg1: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createTempFile(arg0: java.nio.file.Path, arg1: java.lang.String | string, arg2: java.lang.String | string, ...arg3: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createTempFile(arg0: java.lang.String | string, arg1: java.lang.String | string, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createTempDirectory(arg0: java.nio.file.Path, arg1: java.lang.String | string, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createTempDirectory(arg0: java.lang.String | string, ...arg1: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createSymbolicLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.file.Path
                public static createLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path): java.nio.file.Path
                public static delete(arg0: java.nio.file.Path): void
                public static deleteIfExists(arg0: java.nio.file.Path): boolean
                public static copy(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): java.nio.file.Path
                public static move(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): java.nio.file.Path
                public static readSymbolicLink(arg0: java.nio.file.Path): java.nio.file.Path
                public static getFileStore(arg0: java.nio.file.Path): java.nio.file.FileStore
                public static isSameFile(arg0: java.nio.file.Path, arg1: java.nio.file.Path): boolean
                public static isHidden(arg0: java.nio.file.Path): boolean
                public static probeContentType(arg0: java.nio.file.Path): string
                public static getFileAttributeView<V extends java.nio.file.attribute.FileAttributeView>(arg0: java.nio.file.Path, arg1: java.lang.Class<V>, ...arg2: java.nio.file.LinkOption[]): V
                public static readAttributes<A extends java.nio.file.attribute.BasicFileAttributes>(arg0: java.nio.file.Path, arg1: java.lang.Class<A>, ...arg2: java.nio.file.LinkOption[]): A
                public static setAttribute(arg0: java.nio.file.Path, arg1: java.lang.String | string, arg2: java.lang.Object, ...arg3: java.nio.file.LinkOption[]): java.nio.file.Path
                public static getAttribute(arg0: java.nio.file.Path, arg1: java.lang.String | string, ...arg2: java.nio.file.LinkOption[]): java.lang.Object
                public static readAttributes(arg0: java.nio.file.Path, arg1: java.lang.String | string, ...arg2: java.nio.file.LinkOption[]): java.util.Map<java.lang.String, java.lang.Object>
                public static getPosixFilePermissions(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): java.util.Set<java.nio.file.attribute.PosixFilePermission>
                public static setPosixFilePermissions(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.attribute.PosixFilePermission>): java.nio.file.Path
                public static getOwner(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): java.nio.file.attribute.UserPrincipal
                public static setOwner(arg0: java.nio.file.Path, arg1: java.nio.file.attribute.UserPrincipal): java.nio.file.Path
                public static isSymbolicLink(arg0: java.nio.file.Path): boolean
                public static isDirectory(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): boolean
                public static isRegularFile(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): boolean
                public static getLastModifiedTime(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): java.nio.file.attribute.FileTime
                public static setLastModifiedTime(arg0: java.nio.file.Path, arg1: java.nio.file.attribute.FileTime): java.nio.file.Path
                public static size(arg0: java.nio.file.Path): long
                public static exists(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): boolean
                public static notExists(arg0: java.nio.file.Path, ...arg1: java.nio.file.LinkOption[]): boolean
                public static isReadable(arg0: java.nio.file.Path): boolean
                public static isWritable(arg0: java.nio.file.Path): boolean
                public static isExecutable(arg0: java.nio.file.Path): boolean
                public static walkFileTree(arg0: java.nio.file.Path, arg1: java.util.Set<java.nio.file.FileVisitOption>, arg2: int, arg3: java.nio.file.FileVisitor<java.nio.file.Path>): java.nio.file.Path
                public static walkFileTree(arg0: java.nio.file.Path, arg1: java.nio.file.FileVisitor<java.nio.file.Path>): java.nio.file.Path
                public static newBufferedReader(arg0: java.nio.file.Path, arg1: java.nio.charset.Charset): java.io.BufferedReader
                public static newBufferedReader(arg0: java.nio.file.Path): java.io.BufferedReader
                public static newBufferedWriter(arg0: java.nio.file.Path, arg1: java.nio.charset.Charset, ...arg2: java.nio.file.OpenOption[]): java.io.BufferedWriter
                public static newBufferedWriter(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.BufferedWriter
                public static copy(arg0: java.io.InputStream, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): long
                public static copy(arg0: java.nio.file.Path, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda): long
                public static readAllBytes(arg0: java.nio.file.Path): byte[]
                public static readAllLines(arg0: java.nio.file.Path, arg1: java.nio.charset.Charset): java.util.List<java.lang.String>
                public static readAllLines(arg0: java.nio.file.Path): java.util.List<java.lang.String>
                public static write(arg0: java.nio.file.Path, arg1: byte[], ...arg2: java.nio.file.OpenOption[]): java.nio.file.Path
                public static write(arg0: java.nio.file.Path, arg1: java.lang.Iterable<java.lang.CharSequence>, arg2: java.nio.charset.Charset, ...arg3: java.nio.file.OpenOption[]): java.nio.file.Path
                public static write(arg0: java.nio.file.Path, arg1: java.lang.Iterable<java.lang.CharSequence>, ...arg2: java.nio.file.OpenOption[]): java.nio.file.Path
                public static list(arg0: java.nio.file.Path): java.util.stream.Stream<java.nio.file.Path>
                public static walk(arg0: java.nio.file.Path, arg1: int, ...arg2: java.nio.file.FileVisitOption[]): java.util.stream.Stream<java.nio.file.Path>
                public static walk(arg0: java.nio.file.Path, ...arg1: java.nio.file.FileVisitOption[]): java.util.stream.Stream<java.nio.file.Path>
                public static find(arg0: java.nio.file.Path, arg1: int, arg2: java.util.function$.BiPredicate<java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes>, ...arg3: java.nio.file.FileVisitOption[]): java.util.stream.Stream<java.nio.file.Path>
                public static lines(arg0: java.nio.file.Path, arg1: java.nio.charset.Charset): java.util.stream.Stream<java.lang.String>
                public static lines(arg0: java.nio.file.Path): java.util.stream.Stream<java.lang.String>
                public static class: java.lang.Class<any>
            }
            class InvalidPathException extends java.lang.IllegalArgumentException {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: int)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public getInput(): string
                public getReason(): string
                public getIndex(): int
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
            class LinkOption extends java.lang.Enum<java.nio.file.LinkOption> implements java.nio.file.OpenOption , java.nio.file.CopyOption {
                public static NOFOLLOW_LINKS: java.nio.file.LinkOption
                public static values(): java.nio.file.LinkOption[]
                public static valueOf(arg0: java.lang.String | string): java.nio.file.LinkOption
                public static class: java.lang.Class<any>
            }
            class LinkPermission extends java.security.BasicPermission {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class NoSuchFileException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class NotDirectoryException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class NotLinkException extends java.nio.file.FileSystemException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface OpenOption {
            }
            interface Path extends java.lang.Comparable<java.nio.file.Path> , java.lang.Iterable<java.nio.file.Path> , java.nio.file.Watchable {
                getFileSystem(): java.nio.file.FileSystem
                isAbsolute(): boolean
                getRoot(): java.nio.file.Path
                getFileName(): java.nio.file.Path
                getParent(): java.nio.file.Path
                getNameCount(): int
                getName(arg0: int): java.nio.file.Path
                subpath(arg0: int, arg1: int): java.nio.file.Path
                startsWith(arg0: java.nio.file.Path): boolean
                startsWith(arg0: java.lang.String | string): boolean
                endsWith(arg0: java.nio.file.Path): boolean
                endsWith(arg0: java.lang.String | string): boolean
                normalize(): java.nio.file.Path
                resolve(arg0: java.nio.file.Path): java.nio.file.Path
                resolve(arg0: java.lang.String | string): java.nio.file.Path
                resolveSibling(arg0: java.nio.file.Path): java.nio.file.Path
                resolveSibling(arg0: java.lang.String | string): java.nio.file.Path
                relativize(arg0: java.nio.file.Path): java.nio.file.Path
                toUri(): java.net.URI
                toAbsolutePath(): java.nio.file.Path
                toRealPath(...arg0: java.nio.file.LinkOption[]): java.nio.file.Path
                toFile(): java.io.File
                register(arg0: java.nio.file.WatchService, arg1: java.nio.file.WatchEvent$Kind<any>[], ...arg2: java.nio.file.WatchEvent$Modifier[]): java.nio.file.WatchKey
                register(arg0: java.nio.file.WatchService, ...arg1: java.nio.file.WatchEvent$Kind<any>[]): java.nio.file.WatchKey
                iterator(): java.util.Iterator<java.nio.file.Path>
                compareTo(arg0: java.nio.file.Path): int
                equals(arg0: java.lang.Object): boolean
                hashCode(): int
                toString(): string
                compareTo(arg0: java.lang.Object): int
            }
            interface PathMatcher {
                matches(arg0: java.nio.file.Path): boolean
            }
            interface PathMatcher$$Lambda {
                (arg0: java.nio.file.Path): boolean
            }
            class Paths {
                public static get(arg0: java.lang.String | string, ...arg1: java.lang.String[]): java.nio.file.Path
                public static get(arg0: java.net.URI): java.nio.file.Path
                public static class: java.lang.Class<any>
            }
            class ProviderMismatchException extends java.lang.IllegalArgumentException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class ProviderNotFoundException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class ReadOnlyFileSystemException extends java.lang.UnsupportedOperationException {
                public constructor()
                public static class: java.lang.Class<any>
            }
            interface SecureDirectoryStream<T> extends java.nio.file.DirectoryStream<T> {
                newDirectoryStream(arg0: T, ...arg1: java.nio.file.LinkOption[]): java.nio.file.SecureDirectoryStream<T>
                newByteChannel(arg0: T, arg1: java.util.Set<java.nio.file.OpenOption>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.SeekableByteChannel
                deleteFile(arg0: T): void
                deleteDirectory(arg0: T): void
                move(arg0: T, arg1: java.nio.file.SecureDirectoryStream<T>, arg2: T): void
                getFileAttributeView<V extends java.nio.file.attribute.FileAttributeView>(arg0: java.lang.Class<V>): V
                getFileAttributeView<V extends java.nio.file.attribute.FileAttributeView>(arg0: T, arg1: java.lang.Class<V>, ...arg2: java.nio.file.LinkOption[]): V
            }
            class SimpleFileVisitor<T> implements java.nio.file.FileVisitor<T> {
                protected constructor()
                public preVisitDirectory(arg0: T, arg1: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
                public visitFile(arg0: T, arg1: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
                public visitFileFailed(arg0: T, arg1: java.io.IOException): java.nio.file.FileVisitResult
                public postVisitDirectory(arg0: T, arg1: java.io.IOException): java.nio.file.FileVisitResult
                public static class: java.lang.Class<any>
            }
            class StandardCopyOption extends java.lang.Enum<java.nio.file.StandardCopyOption> implements java.nio.file.CopyOption {
                public static REPLACE_EXISTING: java.nio.file.StandardCopyOption
                public static COPY_ATTRIBUTES: java.nio.file.StandardCopyOption
                public static ATOMIC_MOVE: java.nio.file.StandardCopyOption
                public static values(): java.nio.file.StandardCopyOption[]
                public static valueOf(arg0: java.lang.String | string): java.nio.file.StandardCopyOption
                public static class: java.lang.Class<any>
            }
            class StandardOpenOption extends java.lang.Enum<java.nio.file.StandardOpenOption> implements java.nio.file.OpenOption {
                public static READ: java.nio.file.StandardOpenOption
                public static WRITE: java.nio.file.StandardOpenOption
                public static APPEND: java.nio.file.StandardOpenOption
                public static TRUNCATE_EXISTING: java.nio.file.StandardOpenOption
                public static CREATE: java.nio.file.StandardOpenOption
                public static CREATE_NEW: java.nio.file.StandardOpenOption
                public static DELETE_ON_CLOSE: java.nio.file.StandardOpenOption
                public static SPARSE: java.nio.file.StandardOpenOption
                public static SYNC: java.nio.file.StandardOpenOption
                public static DSYNC: java.nio.file.StandardOpenOption
                public static values(): java.nio.file.StandardOpenOption[]
                public static valueOf(arg0: java.lang.String | string): java.nio.file.StandardOpenOption
                public static class: java.lang.Class<any>
            }
            class StandardWatchEventKinds {
                public static OVERFLOW: java.nio.file.WatchEvent$Kind<java.lang.Object>
                public static ENTRY_CREATE: java.nio.file.WatchEvent$Kind<java.nio.file.Path>
                public static ENTRY_DELETE: java.nio.file.WatchEvent$Kind<java.nio.file.Path>
                public static ENTRY_MODIFY: java.nio.file.WatchEvent$Kind<java.nio.file.Path>
                public static class: java.lang.Class<any>
            }
            class TempFileHelper {
                public static class: java.lang.Class<any>
            }
            interface WatchEvent<T> {
                kind(): java.nio.file.WatchEvent$Kind<T>
                count(): int
                context(): T
            }
            interface WatchKey {
                isValid(): boolean
                pollEvents(): java.util.List<java.nio.file.WatchEvent<any>>
                reset(): boolean
                cancel(): void
                watchable(): java.nio.file.Watchable
            }
            interface WatchService extends java.io.Closeable {
                close(): void
                poll(): java.nio.file.WatchKey
                poll(arg0: long, arg1: java.util.concurrent.TimeUnit): java.nio.file.WatchKey
                take(): java.nio.file.WatchKey
            }
            interface Watchable {
                register(arg0: java.nio.file.WatchService, arg1: java.nio.file.WatchEvent$Kind<any>[], ...arg2: java.nio.file.WatchEvent$Modifier[]): java.nio.file.WatchKey
                register(arg0: java.nio.file.WatchService, ...arg1: java.nio.file.WatchEvent$Kind<any>[]): java.nio.file.WatchKey
            }
        }
        class Bits {
            public static class: java.lang.Class<any>
        }
        abstract class Buffer {
            public capacity(): int
            public position(): int
            public position(arg0: int): java.nio.Buffer
            public limit(): int
            public limit(arg0: int): java.nio.Buffer
            public mark(): java.nio.Buffer
            public reset(): java.nio.Buffer
            public clear(): java.nio.Buffer
            public flip(): java.nio.Buffer
            public rewind(): java.nio.Buffer
            public remaining(): int
            public hasRemaining(): boolean
            public isReadOnly(): boolean
            public hasArray(): boolean
            public array(): java.lang.Object
            public arrayOffset(): int
            public isDirect(): boolean
            public static class: java.lang.Class<any>
        }
        class ByteOrder {
            public static BIG_ENDIAN: java.nio.ByteOrder
            public static LITTLE_ENDIAN: java.nio.ByteOrder
            public static nativeOrder(): java.nio.ByteOrder
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class CharBufferSpliterator implements java.util.Spliterator$OfInt {
            public trySplit(): java.util.Spliterator$OfInt
            public forEachRemaining(arg0: java.util.function$.IntConsumer): void
            public tryAdvance(arg0: java.util.function$.IntConsumer): boolean
            public estimateSize(): long
            public characteristics(): int
            public forEachRemaining(arg0: java.lang.Object): void
            public tryAdvance(arg0: java.lang.Object): boolean
            public trySplit(): java.util.Spliterator$OfPrimitive
            public trySplit(): java.util.Spliterator
            public static class: java.lang.Class<any>
        }
        abstract class MappedByteBuffer extends java.nio.ByteBuffer {
            public isLoaded(): boolean
            public load(): java.nio.MappedByteBuffer
            public force(): java.nio.MappedByteBuffer
            public static class: java.lang.Class<any>
        }
        class StringCharBuffer extends java.nio.CharBuffer {
            public slice(): java.nio.CharBuffer
            public duplicate(): java.nio.CharBuffer
            public asReadOnlyBuffer(): java.nio.CharBuffer
            public get(): char
            public get(arg0: int): char
            public put(arg0: char): java.nio.CharBuffer
            public put(arg0: int, arg1: char): java.nio.CharBuffer
            public compact(): java.nio.CharBuffer
            public isReadOnly(): boolean
            public subSequence(arg0: int, arg1: int): java.nio.CharBuffer
            public isDirect(): boolean
            public order(): java.nio.ByteOrder
            public subSequence(arg0: int, arg1: int): java.lang.CharSequence
            public static class: java.lang.Class<any>
        }
    }
    namespace security {
        namespace acl {
            interface Acl extends java.security.acl.Owner {
                setName(arg0: java.security.Principal, arg1: java.lang.String | string): void
                getName(): string
                addEntry(arg0: java.security.Principal, arg1: java.security.acl.AclEntry): boolean
                removeEntry(arg0: java.security.Principal, arg1: java.security.acl.AclEntry): boolean
                getPermissions(arg0: java.security.Principal): java.util.Enumeration<java.security.acl.Permission>
                entries(): java.util.Enumeration<java.security.acl.AclEntry>
                checkPermission(arg0: java.security.Principal, arg1: java.security.acl.Permission): boolean
                toString(): string
            }
            interface AclEntry extends java.lang.Cloneable {
                setPrincipal(arg0: java.security.Principal): boolean
                getPrincipal(): java.security.Principal
                setNegativePermissions(): void
                isNegative(): boolean
                addPermission(arg0: java.security.acl.Permission): boolean
                removePermission(arg0: java.security.acl.Permission): boolean
                checkPermission(arg0: java.security.acl.Permission): boolean
                permissions(): java.util.Enumeration<java.security.acl.Permission>
                toString(): string
                clone(): java.lang.Object
            }
            class AclNotFoundException extends java.lang.Exception {
                public constructor()
                public static class: java.lang.Class<any>
            }
            interface Group extends java.security.Principal {
                addMember(arg0: java.security.Principal): boolean
                removeMember(arg0: java.security.Principal): boolean
                isMember(arg0: java.security.Principal): boolean
                members(): java.util.Enumeration<java.security.Principal>
            }
            class LastOwnerException extends java.lang.Exception {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class NotOwnerException extends java.lang.Exception {
                public constructor()
                public static class: java.lang.Class<any>
            }
            interface Owner {
                addOwner(arg0: java.security.Principal, arg1: java.security.Principal): boolean
                deleteOwner(arg0: java.security.Principal, arg1: java.security.Principal): boolean
                isOwner(arg0: java.security.Principal): boolean
            }
            interface Permission {
                equals(arg0: java.lang.Object): boolean
                toString(): string
            }
        }
        namespace cert {
            abstract class CRL {
                protected constructor(arg0: java.lang.String | string)
                public getType(): string
                public toString(): string
                public isRevoked(arg0: java.security.cert.Certificate): boolean
                public static class: java.lang.Class<any>
            }
            class CRLException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class CRLReason extends java.lang.Enum<java.security.cert.CRLReason> {
                public static UNSPECIFIED: java.security.cert.CRLReason
                public static KEY_COMPROMISE: java.security.cert.CRLReason
                public static CA_COMPROMISE: java.security.cert.CRLReason
                public static AFFILIATION_CHANGED: java.security.cert.CRLReason
                public static SUPERSEDED: java.security.cert.CRLReason
                public static CESSATION_OF_OPERATION: java.security.cert.CRLReason
                public static CERTIFICATE_HOLD: java.security.cert.CRLReason
                public static UNUSED: java.security.cert.CRLReason
                public static REMOVE_FROM_CRL: java.security.cert.CRLReason
                public static PRIVILEGE_WITHDRAWN: java.security.cert.CRLReason
                public static AA_COMPROMISE: java.security.cert.CRLReason
                public static values(): java.security.cert.CRLReason[]
                public static valueOf(arg0: java.lang.String | string): java.security.cert.CRLReason
                public static class: java.lang.Class<any>
            }
            interface CRLSelector extends java.lang.Cloneable {
                match(arg0: java.security.cert.CRL): boolean
                clone(): java.lang.Object
            }
            abstract class CertPath implements java.io.Serializable {
                protected constructor(arg0: java.lang.String | string)
                public getType(): string
                public getEncodings(): java.util.Iterator<java.lang.String>
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public getEncoded(): byte[]
                public getEncoded(arg0: java.lang.String | string): byte[]
                public getCertificates(): java.util.List<java.security.cert.Certificate>
                protected writeReplace(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertPathBuilder {
                protected constructor(arg0: java.security.cert.CertPathBuilderSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                public static getInstance(arg0: java.lang.String | string): java.security.cert.CertPathBuilder
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.cert.CertPathBuilder
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.cert.CertPathBuilder
                public getProvider(): java.security.Provider
                public getAlgorithm(): string
                public build(arg0: java.security.cert.CertPathParameters): java.security.cert.CertPathBuilderResult
                public static getDefaultType(): string
                public getRevocationChecker(): java.security.cert.CertPathChecker
                public static class: java.lang.Class<any>
            }
            class CertPathBuilderException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.Throwable)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            interface CertPathBuilderResult extends java.lang.Cloneable {
                getCertPath(): java.security.cert.CertPath
                clone(): java.lang.Object
            }
            abstract class CertPathBuilderSpi {
                public constructor()
                public engineBuild(arg0: java.security.cert.CertPathParameters): java.security.cert.CertPathBuilderResult
                public engineGetRevocationChecker(): java.security.cert.CertPathChecker
                public static class: java.lang.Class<any>
            }
            interface CertPathChecker {
                init(arg0: boolean): void
                isForwardCheckingSupported(): boolean
                check(arg0: java.security.cert.Certificate): void
            }
            class CertPathHelperImpl extends sun.security.provider.certpath.CertPathHelper {
                protected implSetPathToNames(arg0: java.security.cert.X509CertSelector, arg1: java.util.Set<sun.security.x509.GeneralNameInterface>): void
                protected implSetDateAndTime(arg0: java.security.cert.X509CRLSelector, arg1: java.util.Date, arg2: long): void
                public static class: java.lang.Class<any>
            }
            interface CertPathParameters extends java.lang.Cloneable {
                clone(): java.lang.Object
            }
            class CertPathValidator {
                protected constructor(arg0: java.security.cert.CertPathValidatorSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                public static getInstance(arg0: java.lang.String | string): java.security.cert.CertPathValidator
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.cert.CertPathValidator
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.cert.CertPathValidator
                public getProvider(): java.security.Provider
                public getAlgorithm(): string
                public validate(arg0: java.security.cert.CertPath, arg1: java.security.cert.CertPathParameters): java.security.cert.CertPathValidatorResult
                public static getDefaultType(): string
                public getRevocationChecker(): java.security.cert.CertPathChecker
                public static class: java.lang.Class<any>
            }
            class CertPathValidatorException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.Throwable)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: java.security.cert.CertPath, arg3: int)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable, arg2: java.security.cert.CertPath, arg3: int, arg4: java.security.cert.CertPathValidatorException$Reason)
                public getCertPath(): java.security.cert.CertPath
                public getIndex(): int
                public getReason(): java.security.cert.CertPathValidatorException$Reason
                public static class: java.lang.Class<any>
            }
            interface CertPathValidatorResult extends java.lang.Cloneable {
                clone(): java.lang.Object
            }
            abstract class CertPathValidatorSpi {
                public constructor()
                public engineValidate(arg0: java.security.cert.CertPath, arg1: java.security.cert.CertPathParameters): java.security.cert.CertPathValidatorResult
                public engineGetRevocationChecker(): java.security.cert.CertPathChecker
                public static class: java.lang.Class<any>
            }
            interface CertSelector extends java.lang.Cloneable {
                match(arg0: java.security.cert.Certificate): boolean
                clone(): java.lang.Object
            }
            class CertStore {
                protected constructor(arg0: java.security.cert.CertStoreSpi, arg1: java.security.Provider, arg2: java.lang.String | string, arg3: java.security.cert.CertStoreParameters)
                public getCertificates(arg0: java.security.cert.CertSelector): java.util.Collection<java.security.cert.Certificate>
                public getCRLs(arg0: java.security.cert.CRLSelector): java.util.Collection<java.security.cert.CRL>
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.cert.CertStoreParameters): java.security.cert.CertStore
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.cert.CertStoreParameters, arg2: java.lang.String | string): java.security.cert.CertStore
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.cert.CertStoreParameters, arg2: java.security.Provider): java.security.cert.CertStore
                public getCertStoreParameters(): java.security.cert.CertStoreParameters
                public getType(): string
                public getProvider(): java.security.Provider
                public static getDefaultType(): string
                public static class: java.lang.Class<any>
            }
            class CertStoreException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.Throwable)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            interface CertStoreParameters extends java.lang.Cloneable {
                clone(): java.lang.Object
            }
            abstract class CertStoreSpi {
                public constructor(arg0: java.security.cert.CertStoreParameters)
                public engineGetCertificates(arg0: java.security.cert.CertSelector): java.util.Collection<java.security.cert.Certificate>
                public engineGetCRLs(arg0: java.security.cert.CRLSelector): java.util.Collection<java.security.cert.CRL>
                public static class: java.lang.Class<any>
            }
            abstract class Certificate implements java.io.Serializable {
                protected constructor(arg0: java.lang.String | string)
                public getType(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getEncoded(): byte[]
                public verify(arg0: java.security.PublicKey): void
                public verify(arg0: java.security.PublicKey, arg1: java.lang.String | string): void
                public verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void
                public toString(): string
                public getPublicKey(): java.security.PublicKey
                protected writeReplace(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateEncodingException extends java.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class CertificateException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class CertificateExpiredException extends java.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CertificateFactory {
                protected constructor(arg0: java.security.cert.CertificateFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                public static getInstance(arg0: java.lang.String | string): java.security.cert.CertificateFactory
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.cert.CertificateFactory
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.cert.CertificateFactory
                public getProvider(): java.security.Provider
                public getType(): string
                public generateCertificate(arg0: java.io.InputStream): java.security.cert.Certificate
                public getCertPathEncodings(): java.util.Iterator<java.lang.String>
                public generateCertPath(arg0: java.io.InputStream): java.security.cert.CertPath
                public generateCertPath(arg0: java.io.InputStream, arg1: java.lang.String | string): java.security.cert.CertPath
                public generateCertPath(arg0: java.util.List<java.security.cert.Certificate>): java.security.cert.CertPath
                public generateCertificates(arg0: java.io.InputStream): java.util.Collection<java.security.cert.Certificate>
                public generateCRL(arg0: java.io.InputStream): java.security.cert.CRL
                public generateCRLs(arg0: java.io.InputStream): java.util.Collection<java.security.cert.CRL>
                public static class: java.lang.Class<any>
            }
            abstract class CertificateFactorySpi {
                public constructor()
                public engineGenerateCertificate(arg0: java.io.InputStream): java.security.cert.Certificate
                public engineGenerateCertPath(arg0: java.io.InputStream): java.security.cert.CertPath
                public engineGenerateCertPath(arg0: java.io.InputStream, arg1: java.lang.String | string): java.security.cert.CertPath
                public engineGenerateCertPath(arg0: java.util.List<java.security.cert.Certificate>): java.security.cert.CertPath
                public engineGetCertPathEncodings(): java.util.Iterator<java.lang.String>
                public engineGenerateCertificates(arg0: java.io.InputStream): java.util.Collection<java.security.cert.Certificate>
                public engineGenerateCRL(arg0: java.io.InputStream): java.security.cert.CRL
                public engineGenerateCRLs(arg0: java.io.InputStream): java.util.Collection<java.security.cert.CRL>
                public static class: java.lang.Class<any>
            }
            class CertificateNotYetValidException extends java.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CertificateParsingException extends java.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class CertificateRevokedException extends java.security.cert.CertificateException {
                public constructor(arg0: java.util.Date, arg1: java.security.cert.CRLReason, arg2: javax.security.auth.x500.X500Principal, arg3: java.util.Map<java.lang.String, java.security.cert.Extension>)
                public getRevocationDate(): java.util.Date
                public getRevocationReason(): java.security.cert.CRLReason
                public getAuthorityName(): javax.security.auth.x500.X500Principal
                public getInvalidityDate(): java.util.Date
                public getExtensions(): java.util.Map<java.lang.String, java.security.cert.Extension>
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
            class CollectionCertStoreParameters implements java.security.cert.CertStoreParameters {
                public constructor(arg0: java.util.Collection<any>)
                public constructor()
                public getCollection(): java.util.Collection<any>
                public clone(): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            interface Extension {
                getId(): string
                isCritical(): boolean
                getValue(): byte[]
                encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
            }
            class LDAPCertStoreParameters implements java.security.cert.CertStoreParameters {
                public constructor(arg0: java.lang.String | string, arg1: int)
                public constructor(arg0: java.lang.String | string)
                public constructor()
                public getServerName(): string
                public getPort(): int
                public clone(): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKIXBuilderParameters extends java.security.cert.PKIXParameters {
                public constructor(arg0: java.util.Set<java.security.cert.TrustAnchor>, arg1: java.security.cert.CertSelector)
                public constructor(arg0: java.security.KeyStore, arg1: java.security.cert.CertSelector)
                public setMaxPathLength(arg0: int): void
                public getMaxPathLength(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKIXCertPathBuilderResult extends java.security.cert.PKIXCertPathValidatorResult implements java.security.cert.CertPathBuilderResult {
                public constructor(arg0: java.security.cert.CertPath, arg1: java.security.cert.TrustAnchor, arg2: java.security.cert.PolicyNode, arg3: java.security.PublicKey)
                public getCertPath(): java.security.cert.CertPath
                public toString(): string
                public static class: java.lang.Class<any>
            }
            abstract class PKIXCertPathChecker implements java.security.cert.CertPathChecker , java.lang.Cloneable {
                protected constructor()
                public init(arg0: boolean): void
                public isForwardCheckingSupported(): boolean
                public getSupportedExtensions(): java.util.Set<java.lang.String>
                public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                public check(arg0: java.security.cert.Certificate): void
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class PKIXCertPathValidatorResult implements java.security.cert.CertPathValidatorResult {
                public constructor(arg0: java.security.cert.TrustAnchor, arg1: java.security.cert.PolicyNode, arg2: java.security.PublicKey)
                public getTrustAnchor(): java.security.cert.TrustAnchor
                public getPolicyTree(): java.security.cert.PolicyNode
                public getPublicKey(): java.security.PublicKey
                public clone(): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKIXParameters implements java.security.cert.CertPathParameters {
                public constructor(arg0: java.util.Set<java.security.cert.TrustAnchor>)
                public constructor(arg0: java.security.KeyStore)
                public getTrustAnchors(): java.util.Set<java.security.cert.TrustAnchor>
                public setTrustAnchors(arg0: java.util.Set<java.security.cert.TrustAnchor>): void
                public getInitialPolicies(): java.util.Set<java.lang.String>
                public setInitialPolicies(arg0: java.util.Set<java.lang.String>): void
                public setCertStores(arg0: java.util.List<java.security.cert.CertStore>): void
                public addCertStore(arg0: java.security.cert.CertStore): void
                public getCertStores(): java.util.List<java.security.cert.CertStore>
                public setRevocationEnabled(arg0: boolean): void
                public isRevocationEnabled(): boolean
                public setExplicitPolicyRequired(arg0: boolean): void
                public isExplicitPolicyRequired(): boolean
                public setPolicyMappingInhibited(arg0: boolean): void
                public isPolicyMappingInhibited(): boolean
                public setAnyPolicyInhibited(arg0: boolean): void
                public isAnyPolicyInhibited(): boolean
                public setPolicyQualifiersRejected(arg0: boolean): void
                public getPolicyQualifiersRejected(): boolean
                public getDate(): java.util.Date
                public setDate(arg0: java.util.Date): void
                public setCertPathCheckers(arg0: java.util.List<java.security.cert.PKIXCertPathChecker>): void
                public getCertPathCheckers(): java.util.List<java.security.cert.PKIXCertPathChecker>
                public addCertPathChecker(arg0: java.security.cert.PKIXCertPathChecker): void
                public getSigProvider(): string
                public setSigProvider(arg0: java.lang.String | string): void
                public getTargetCertConstraints(): java.security.cert.CertSelector
                public setTargetCertConstraints(arg0: java.security.cert.CertSelector): void
                public clone(): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKIXReason extends java.lang.Enum<java.security.cert.PKIXReason> implements java.security.cert.CertPathValidatorException$Reason {
                public static NAME_CHAINING: java.security.cert.PKIXReason
                public static INVALID_KEY_USAGE: java.security.cert.PKIXReason
                public static INVALID_POLICY: java.security.cert.PKIXReason
                public static NO_TRUST_ANCHOR: java.security.cert.PKIXReason
                public static UNRECOGNIZED_CRIT_EXT: java.security.cert.PKIXReason
                public static NOT_CA_CERT: java.security.cert.PKIXReason
                public static PATH_TOO_LONG: java.security.cert.PKIXReason
                public static INVALID_NAME: java.security.cert.PKIXReason
                public static values(): java.security.cert.PKIXReason[]
                public static valueOf(arg0: java.lang.String | string): java.security.cert.PKIXReason
                public static class: java.lang.Class<any>
            }
            abstract class PKIXRevocationChecker extends java.security.cert.PKIXCertPathChecker {
                protected constructor()
                public setOcspResponder(arg0: java.net.URI): void
                public getOcspResponder(): java.net.URI
                public setOcspResponderCert(arg0: java.security.cert.X509Certificate): void
                public getOcspResponderCert(): java.security.cert.X509Certificate
                public setOcspExtensions(arg0: java.util.List<java.security.cert.Extension>): void
                public getOcspExtensions(): java.util.List<java.security.cert.Extension>
                public setOcspResponses(arg0: java.util.Map<java.security.cert.X509Certificate, byte[]>): void
                public getOcspResponses(): java.util.Map<java.security.cert.X509Certificate, byte[]>
                public setOptions(arg0: java.util.Set<java.security.cert.PKIXRevocationChecker$Option>): void
                public getOptions(): java.util.Set<java.security.cert.PKIXRevocationChecker$Option>
                public getSoftFailExceptions(): java.util.List<java.security.cert.CertPathValidatorException>
                public clone(): java.security.cert.PKIXRevocationChecker
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            interface PolicyNode {
                getParent(): java.security.cert.PolicyNode
                getChildren(): java.util.Iterator<java.security.cert.PolicyNode>
                getDepth(): int
                getValidPolicy(): string
                getPolicyQualifiers(): java.util.Set<java.security.cert.PolicyQualifierInfo>
                getExpectedPolicies(): java.util.Set<java.lang.String>
                isCritical(): boolean
            }
            class PolicyQualifierInfo {
                public constructor(arg0: byte[])
                public getPolicyQualifierId(): string
                public getEncoded(): byte[]
                public getPolicyQualifier(): byte[]
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class TrustAnchor {
                public constructor(arg0: java.security.cert.X509Certificate, arg1: byte[])
                public constructor(arg0: javax.security.auth.x500.X500Principal, arg1: java.security.PublicKey, arg2: byte[])
                public constructor(arg0: java.lang.String | string, arg1: java.security.PublicKey, arg2: byte[])
                public getTrustedCert(): java.security.cert.X509Certificate
                public getCA(): javax.security.auth.x500.X500Principal
                public getCAName(): string
                public getCAPublicKey(): java.security.PublicKey
                public getNameConstraints(): byte[]
                public toString(): string
                public static class: java.lang.Class<any>
            }
            abstract class X509CRL extends java.security.cert.CRL implements java.security.cert.X509Extension {
                protected constructor()
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getEncoded(): byte[]
                public verify(arg0: java.security.PublicKey): void
                public verify(arg0: java.security.PublicKey, arg1: java.lang.String | string): void
                public verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void
                public getVersion(): int
                public getIssuerDN(): java.security.Principal
                public getIssuerX500Principal(): javax.security.auth.x500.X500Principal
                public getThisUpdate(): java.util.Date
                public getNextUpdate(): java.util.Date
                public getRevokedCertificate(arg0: java.math.BigInteger): java.security.cert.X509CRLEntry
                public getRevokedCertificate(arg0: java.security.cert.X509Certificate): java.security.cert.X509CRLEntry
                public getRevokedCertificates(): java.util.Set<java.security.cert.X509CRLEntry>
                public getTBSCertList(): byte[]
                public getSignature(): byte[]
                public getSigAlgName(): string
                public getSigAlgOID(): string
                public getSigAlgParams(): byte[]
                public static class: java.lang.Class<any>
            }
            abstract class X509CRLEntry implements java.security.cert.X509Extension {
                public constructor()
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getEncoded(): byte[]
                public getSerialNumber(): java.math.BigInteger
                public getCertificateIssuer(): javax.security.auth.x500.X500Principal
                public getRevocationDate(): java.util.Date
                public hasExtensions(): boolean
                public toString(): string
                public getRevocationReason(): java.security.cert.CRLReason
                public static class: java.lang.Class<any>
            }
            class X509CRLSelector implements java.security.cert.CRLSelector {
                public constructor()
                public setIssuers(arg0: java.util.Collection<javax.security.auth.x500.X500Principal>): void
                public setIssuerNames(arg0: java.util.Collection<any>): void
                public addIssuer(arg0: javax.security.auth.x500.X500Principal): void
                public addIssuerName(arg0: java.lang.String | string): void
                public addIssuerName(arg0: byte[]): void
                public setMinCRLNumber(arg0: java.math.BigInteger): void
                public setMaxCRLNumber(arg0: java.math.BigInteger): void
                public setDateAndTime(arg0: java.util.Date): void
                public setCertificateChecking(arg0: java.security.cert.X509Certificate): void
                public getIssuers(): java.util.Collection<javax.security.auth.x500.X500Principal>
                public getIssuerNames(): java.util.Collection<java.lang.Object>
                public getMinCRL(): java.math.BigInteger
                public getMaxCRL(): java.math.BigInteger
                public getDateAndTime(): java.util.Date
                public getCertificateChecking(): java.security.cert.X509Certificate
                public toString(): string
                public match(arg0: java.security.cert.CRL): boolean
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class X509CertSelector implements java.security.cert.CertSelector {
                public constructor()
                public setCertificate(arg0: java.security.cert.X509Certificate): void
                public setSerialNumber(arg0: java.math.BigInteger): void
                public setIssuer(arg0: javax.security.auth.x500.X500Principal): void
                public setIssuer(arg0: java.lang.String | string): void
                public setIssuer(arg0: byte[]): void
                public setSubject(arg0: javax.security.auth.x500.X500Principal): void
                public setSubject(arg0: java.lang.String | string): void
                public setSubject(arg0: byte[]): void
                public setSubjectKeyIdentifier(arg0: byte[]): void
                public setAuthorityKeyIdentifier(arg0: byte[]): void
                public setCertificateValid(arg0: java.util.Date): void
                public setPrivateKeyValid(arg0: java.util.Date): void
                public setSubjectPublicKeyAlgID(arg0: java.lang.String | string): void
                public setSubjectPublicKey(arg0: java.security.PublicKey): void
                public setSubjectPublicKey(arg0: byte[]): void
                public setKeyUsage(arg0: boolean[]): void
                public setExtendedKeyUsage(arg0: java.util.Set<java.lang.String>): void
                public setMatchAllSubjectAltNames(arg0: boolean): void
                public setSubjectAlternativeNames(arg0: java.util.Collection<java.util.List<any>>): void
                public addSubjectAlternativeName(arg0: int, arg1: java.lang.String | string): void
                public addSubjectAlternativeName(arg0: int, arg1: byte[]): void
                public setNameConstraints(arg0: byte[]): void
                public setBasicConstraints(arg0: int): void
                public setPolicy(arg0: java.util.Set<java.lang.String>): void
                public setPathToNames(arg0: java.util.Collection<java.util.List<any>>): void
                public addPathToName(arg0: int, arg1: java.lang.String | string): void
                public addPathToName(arg0: int, arg1: byte[]): void
                public getCertificate(): java.security.cert.X509Certificate
                public getSerialNumber(): java.math.BigInteger
                public getIssuer(): javax.security.auth.x500.X500Principal
                public getIssuerAsString(): string
                public getIssuerAsBytes(): byte[]
                public getSubject(): javax.security.auth.x500.X500Principal
                public getSubjectAsString(): string
                public getSubjectAsBytes(): byte[]
                public getSubjectKeyIdentifier(): byte[]
                public getAuthorityKeyIdentifier(): byte[]
                public getCertificateValid(): java.util.Date
                public getPrivateKeyValid(): java.util.Date
                public getSubjectPublicKeyAlgID(): string
                public getSubjectPublicKey(): java.security.PublicKey
                public getKeyUsage(): boolean[]
                public getExtendedKeyUsage(): java.util.Set<java.lang.String>
                public getMatchAllSubjectAltNames(): boolean
                public getSubjectAlternativeNames(): java.util.Collection<java.util.List<any>>
                public getNameConstraints(): byte[]
                public getBasicConstraints(): int
                public getPolicy(): java.util.Set<java.lang.String>
                public getPathToNames(): java.util.Collection<java.util.List<any>>
                public toString(): string
                public match(arg0: java.security.cert.Certificate): boolean
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class X509Certificate extends java.security.cert.Certificate implements java.security.cert.X509Extension {
                protected constructor()
                public checkValidity(): void
                public checkValidity(arg0: java.util.Date): void
                public getVersion(): int
                public getSerialNumber(): java.math.BigInteger
                public getIssuerDN(): java.security.Principal
                public getIssuerX500Principal(): javax.security.auth.x500.X500Principal
                public getSubjectDN(): java.security.Principal
                public getSubjectX500Principal(): javax.security.auth.x500.X500Principal
                public getNotBefore(): java.util.Date
                public getNotAfter(): java.util.Date
                public getTBSCertificate(): byte[]
                public getSignature(): byte[]
                public getSigAlgName(): string
                public getSigAlgOID(): string
                public getSigAlgParams(): byte[]
                public getIssuerUniqueID(): boolean[]
                public getSubjectUniqueID(): boolean[]
                public getKeyUsage(): boolean[]
                public getExtendedKeyUsage(): java.util.List<java.lang.String>
                public getBasicConstraints(): int
                public getSubjectAlternativeNames(): java.util.Collection<java.util.List<any>>
                public getIssuerAlternativeNames(): java.util.Collection<java.util.List<any>>
                public verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void
                public static class: java.lang.Class<any>
            }
            interface X509Extension {
                hasUnsupportedCriticalExtension(): boolean
                getCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                getNonCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                getExtensionValue(arg0: java.lang.String | string): byte[]
            }
        }
        namespace interfaces {
            interface DSAKey {
                getParams(): java.security.interfaces.DSAParams
            }
            interface DSAKey$$Lambda {
                (): java.security.interfaces.DSAParams
            }
            interface DSAKeyPairGenerator {
                initialize(arg0: java.security.interfaces.DSAParams, arg1: java.security.SecureRandom): void
                initialize(arg0: int, arg1: boolean, arg2: java.security.SecureRandom): void
            }
            interface DSAParams {
                getP(): java.math.BigInteger
                getQ(): java.math.BigInteger
                getG(): java.math.BigInteger
            }
            interface DSAPrivateKey extends java.security.interfaces.DSAKey , java.security.PrivateKey {
                serialVersionUID: long
                getX(): java.math.BigInteger
            }
            interface DSAPublicKey extends java.security.interfaces.DSAKey , java.security.PublicKey {
                serialVersionUID: long
                getY(): java.math.BigInteger
            }
            interface ECKey {
                getParams(): java.security.spec.ECParameterSpec
            }
            interface ECKey$$Lambda {
                (): java.security.spec.ECParameterSpec
            }
            interface ECPrivateKey extends java.security.PrivateKey , java.security.interfaces.ECKey {
                serialVersionUID: long
                getS(): java.math.BigInteger
            }
            interface ECPublicKey extends java.security.PublicKey , java.security.interfaces.ECKey {
                serialVersionUID: long
                getW(): java.security.spec.ECPoint
            }
            interface RSAKey {
                getModulus(): java.math.BigInteger
            }
            interface RSAKey$$Lambda {
                (): java.math.BigInteger
            }
            interface RSAMultiPrimePrivateCrtKey extends java.security.interfaces.RSAPrivateKey {
                serialVersionUID: long
                getPublicExponent(): java.math.BigInteger
                getPrimeP(): java.math.BigInteger
                getPrimeQ(): java.math.BigInteger
                getPrimeExponentP(): java.math.BigInteger
                getPrimeExponentQ(): java.math.BigInteger
                getCrtCoefficient(): java.math.BigInteger
                getOtherPrimeInfo(): java.security.spec.RSAOtherPrimeInfo[]
            }
            interface RSAPrivateCrtKey extends java.security.interfaces.RSAPrivateKey {
                serialVersionUID: long
                getPublicExponent(): java.math.BigInteger
                getPrimeP(): java.math.BigInteger
                getPrimeQ(): java.math.BigInteger
                getPrimeExponentP(): java.math.BigInteger
                getPrimeExponentQ(): java.math.BigInteger
                getCrtCoefficient(): java.math.BigInteger
            }
            interface RSAPrivateKey extends java.security.PrivateKey , java.security.interfaces.RSAKey {
                serialVersionUID: long
                getPrivateExponent(): java.math.BigInteger
            }
            interface RSAPublicKey extends java.security.PublicKey , java.security.interfaces.RSAKey {
                serialVersionUID: long
                getPublicExponent(): java.math.BigInteger
            }
        }
        namespace spec {
            interface AlgorithmParameterSpec {
            }
            class DSAGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: int, arg1: int)
                public constructor(arg0: int, arg1: int, arg2: int)
                public getPrimePLength(): int
                public getSubprimeQLength(): int
                public getSeedLength(): int
                public static class: java.lang.Class<any>
            }
            class DSAParameterSpec implements java.security.spec.AlgorithmParameterSpec , java.security.interfaces.DSAParams {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger)
                public getP(): java.math.BigInteger
                public getQ(): java.math.BigInteger
                public getG(): java.math.BigInteger
            }
            class DSAPrivateKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger)
                public getX(): java.math.BigInteger
                public getP(): java.math.BigInteger
                public getQ(): java.math.BigInteger
                public getG(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class DSAPublicKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger)
                public getY(): java.math.BigInteger
                public getP(): java.math.BigInteger
                public getQ(): java.math.BigInteger
                public getG(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            interface ECField {
                getFieldSize(): int
            }
            interface ECField$$Lambda {
                (): int
            }
            class ECFieldF2m implements java.security.spec.ECField {
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: java.math.BigInteger)
                public constructor(arg0: int, arg1: int[])
                public getFieldSize(): int
                public getM(): int
                public getReductionPolynomial(): java.math.BigInteger
                public getMidTermsOfReductionPolynomial(): int[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class ECFieldF2m$$Lambda implements java.security.spec.ECField {
                public constructor(arg0: int)
            }
            class ECFieldFp implements java.security.spec.ECField {
                public constructor(arg0: java.math.BigInteger)
                public getFieldSize(): int
                public getP(): java.math.BigInteger
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class ECFieldFp$$Lambda implements java.security.spec.ECField {
                public constructor(arg0: java.math.BigInteger)
            }
            class ECGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: java.lang.String | string)
                public getName(): string
                public static class: java.lang.Class<any>
            }
            class ECParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: java.security.spec.EllipticCurve, arg1: java.security.spec.ECPoint, arg2: java.math.BigInteger, arg3: int)
                public getCurve(): java.security.spec.EllipticCurve
                public getGenerator(): java.security.spec.ECPoint
                public getOrder(): java.math.BigInteger
                public getCofactor(): int
                public static class: java.lang.Class<any>
            }
            class ECPoint {
                public static POINT_INFINITY: java.security.spec.ECPoint
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger)
                public getAffineX(): java.math.BigInteger
                public getAffineY(): java.math.BigInteger
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class ECPrivateKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.security.spec.ECParameterSpec)
                public getS(): java.math.BigInteger
                public getParams(): java.security.spec.ECParameterSpec
                public static class: java.lang.Class<any>
            }
            class ECPublicKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.security.spec.ECPoint, arg1: java.security.spec.ECParameterSpec)
                public getW(): java.security.spec.ECPoint
                public getParams(): java.security.spec.ECParameterSpec
                public static class: java.lang.Class<any>
            }
            class EllipticCurve {
                public constructor(arg0: java.security.spec.ECField | java.security.spec.ECField$$Lambda, arg1: java.math.BigInteger, arg2: java.math.BigInteger)
                public constructor(arg0: java.security.spec.ECField | java.security.spec.ECField$$Lambda, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: byte[])
                public getField(): java.security.spec.ECField
                public getA(): java.math.BigInteger
                public getB(): java.math.BigInteger
                public getSeed(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            abstract class EncodedKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: byte[])
                public getEncoded(): byte[]
                public getFormat(): string
                public static class: java.lang.Class<any>
            }
            class InvalidKeySpecException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class InvalidParameterSpecException extends java.security.GeneralSecurityException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface KeySpec {
            }
            class MGF1ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public static SHA1: java.security.spec.MGF1ParameterSpec
                public static SHA224: java.security.spec.MGF1ParameterSpec
                public static SHA256: java.security.spec.MGF1ParameterSpec
                public static SHA384: java.security.spec.MGF1ParameterSpec
                public static SHA512: java.security.spec.MGF1ParameterSpec
                public constructor(arg0: java.lang.String | string)
                public getDigestAlgorithm(): string
                public static class: java.lang.Class<any>
            }
            class PKCS8EncodedKeySpec extends java.security.spec.EncodedKeySpec {
                public constructor(arg0: byte[])
                public getEncoded(): byte[]
                public getFormat(): string
                public static class: java.lang.Class<any>
            }
            class PSSParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public static DEFAULT: java.security.spec.PSSParameterSpec
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.security.spec.AlgorithmParameterSpec, arg3: int, arg4: int)
                public constructor(arg0: int)
                public getDigestAlgorithm(): string
                public getMGFAlgorithm(): string
                public getMGFParameters(): java.security.spec.AlgorithmParameterSpec
                public getSaltLength(): int
                public getTrailerField(): int
                public static class: java.lang.Class<any>
            }
            class RSAKeyGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public static F0: java.math.BigInteger
                public static F4: java.math.BigInteger
                public constructor(arg0: int, arg1: java.math.BigInteger)
                public getKeysize(): int
                public getPublicExponent(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class RSAMultiPrimePrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger, arg4: java.math.BigInteger, arg5: java.math.BigInteger, arg6: java.math.BigInteger, arg7: java.math.BigInteger, arg8: java.security.spec.RSAOtherPrimeInfo[])
                public getPublicExponent(): java.math.BigInteger
                public getPrimeP(): java.math.BigInteger
                public getPrimeQ(): java.math.BigInteger
                public getPrimeExponentP(): java.math.BigInteger
                public getPrimeExponentQ(): java.math.BigInteger
                public getCrtCoefficient(): java.math.BigInteger
                public getOtherPrimeInfo(): java.security.spec.RSAOtherPrimeInfo[]
                public static class: java.lang.Class<any>
            }
            class RSAOtherPrimeInfo {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger)
                public getPrime(): java.math.BigInteger
                public getExponent(): java.math.BigInteger
                public getCrtCoefficient(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class RSAPrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger, arg4: java.math.BigInteger, arg5: java.math.BigInteger, arg6: java.math.BigInteger, arg7: java.math.BigInteger)
                public getPublicExponent(): java.math.BigInteger
                public getPrimeP(): java.math.BigInteger
                public getPrimeQ(): java.math.BigInteger
                public getPrimeExponentP(): java.math.BigInteger
                public getPrimeExponentQ(): java.math.BigInteger
                public getCrtCoefficient(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class RSAPrivateKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger)
                public getModulus(): java.math.BigInteger
                public getPrivateExponent(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class RSAPublicKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger)
                public getModulus(): java.math.BigInteger
                public getPublicExponent(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class X509EncodedKeySpec extends java.security.spec.EncodedKeySpec {
                public constructor(arg0: byte[])
                public getEncoded(): byte[]
                public getFormat(): string
                public static class: java.lang.Class<any>
            }
        }
        class AccessControlContext {
            public constructor(arg0: java.security.ProtectionDomain[])
            public constructor(arg0: java.security.AccessControlContext, arg1: java.security.DomainCombiner | java.security.DomainCombiner$$Lambda)
            public checkPermission(arg0: java.security.Permission): void
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getDomainCombiner(): java.security.DomainCombiner
            public static class: java.lang.Class<any>
        }
        class AccessControlException extends java.lang.SecurityException {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.security.Permission)
            public getPermission(): java.security.Permission
            public static class: java.lang.Class<any>
        }
        class AccessController {
            public static checkPermission(arg0: java.security.Permission): void
            public static getContext(): java.security.AccessControlContext
            public static doPrivileged<T>(arg0: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>): T
            public static doPrivileged<T>(arg0: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>, arg1: java.security.AccessControlContext): T
            public static doPrivileged<T>(arg0: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>): T
            public static doPrivileged<T>(arg0: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>, arg1: java.security.AccessControlContext): T
            public static doPrivilegedWithCombiner<T>(arg0: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>): T
            public static doPrivilegedWithCombiner<T>(arg0: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>): T
            public static doPrivileged<T>(arg0: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>, arg1: java.security.AccessControlContext, ...arg2: java.security.Permission[]): T
            public static doPrivilegedWithCombiner<T>(arg0: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>, arg1: java.security.AccessControlContext, ...arg2: java.security.Permission[]): T
            public static doPrivileged<T>(arg0: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>, arg1: java.security.AccessControlContext, ...arg2: java.security.Permission[]): T
            public static doPrivilegedWithCombiner<T>(arg0: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>, arg1: java.security.AccessControlContext, ...arg2: java.security.Permission[]): T
            public static class: java.lang.Class<any>
        }
        interface AlgorithmConstraints {
            permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.AlgorithmParameters): boolean
            permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.security.Key): boolean
            permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.Key, arg3: java.security.AlgorithmParameters): boolean
        }
        class AlgorithmParameterGenerator {
            protected constructor(arg0: java.security.AlgorithmParameterGeneratorSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public getAlgorithm(): string
            public static getInstance(arg0: java.lang.String | string): java.security.AlgorithmParameterGenerator
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.AlgorithmParameterGenerator
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.AlgorithmParameterGenerator
            public getProvider(): java.security.Provider
            public init(arg0: int): void
            public init(arg0: int, arg1: java.security.SecureRandom): void
            public init(arg0: java.security.spec.AlgorithmParameterSpec): void
            public init(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
            public generateParameters(): java.security.AlgorithmParameters
            public static class: java.lang.Class<any>
        }
        abstract class AlgorithmParameterGeneratorSpi {
            public constructor()
            protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
            protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
            protected engineGenerateParameters(): java.security.AlgorithmParameters
            public static class: java.lang.Class<any>
        }
        class AlgorithmParameters {
            protected constructor(arg0: java.security.AlgorithmParametersSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public getAlgorithm(): string
            public static getInstance(arg0: java.lang.String | string): java.security.AlgorithmParameters
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.AlgorithmParameters
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.AlgorithmParameters
            public getProvider(): java.security.Provider
            public init(arg0: java.security.spec.AlgorithmParameterSpec): void
            public init(arg0: byte[]): void
            public init(arg0: byte[], arg1: java.lang.String | string): void
            public getParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
            public getEncoded(): byte[]
            public getEncoded(arg0: java.lang.String | string): byte[]
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class AlgorithmParametersSpi {
            public constructor()
            protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
            protected engineInit(arg0: byte[]): void
            protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
            protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
            protected engineGetEncoded(): byte[]
            protected engineGetEncoded(arg0: java.lang.String | string): byte[]
            protected engineToString(): string
            public static class: java.lang.Class<any>
        }
        class AllPermission extends java.security.Permission {
            public constructor()
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        abstract class AuthProvider extends java.security.Provider {
            protected constructor(arg0: java.lang.String | string, arg1: double, arg2: java.lang.String | string)
            public login(arg0: javax.security.auth.Subject, arg1: javax.security.auth.callback.CallbackHandler | javax.security.auth.callback.CallbackHandler$$Lambda): void
            public logout(): void
            public setCallbackHandler(arg0: javax.security.auth.callback.CallbackHandler | javax.security.auth.callback.CallbackHandler$$Lambda): void
            public static class: java.lang.Class<any>
        }
        abstract class BasicPermission extends java.security.Permission implements java.io.Serializable {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        interface Certificate {
            getGuarantor(): java.security.Principal
            getPrincipal(): java.security.Principal
            getPublicKey(): java.security.PublicKey
            encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
            decode(arg0: java.io.InputStream): void
            getFormat(): string
            toString(arg0: boolean): string
        }
        class CodeSigner implements java.io.Serializable {
            public constructor(arg0: java.security.cert.CertPath, arg1: java.security.Timestamp)
            public getSignerCertPath(): java.security.cert.CertPath
            public getTimestamp(): java.security.Timestamp
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class CodeSource implements java.io.Serializable {
            public constructor(arg0: java.net.URL, arg1: java.security.cert.Certificate[])
            public constructor(arg0: java.net.URL, arg1: java.security.CodeSigner[])
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public getLocation(): java.net.URL
            public getCertificates(): java.security.cert.Certificate[]
            public getCodeSigners(): java.security.CodeSigner[]
            public implies(arg0: java.security.CodeSource): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class CryptoPrimitive extends java.lang.Enum<java.security.CryptoPrimitive> {
            public static MESSAGE_DIGEST: java.security.CryptoPrimitive
            public static SECURE_RANDOM: java.security.CryptoPrimitive
            public static BLOCK_CIPHER: java.security.CryptoPrimitive
            public static STREAM_CIPHER: java.security.CryptoPrimitive
            public static MAC: java.security.CryptoPrimitive
            public static KEY_WRAP: java.security.CryptoPrimitive
            public static PUBLIC_KEY_ENCRYPTION: java.security.CryptoPrimitive
            public static SIGNATURE: java.security.CryptoPrimitive
            public static KEY_ENCAPSULATION: java.security.CryptoPrimitive
            public static KEY_AGREEMENT: java.security.CryptoPrimitive
            public static values(): java.security.CryptoPrimitive[]
            public static valueOf(arg0: java.lang.String | string): java.security.CryptoPrimitive
            public static class: java.lang.Class<any>
        }
        class DigestException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class DigestInputStream extends java.io.FilterInputStream {
            protected digest: java.security.MessageDigest
            public constructor(arg0: java.io.InputStream, arg1: java.security.MessageDigest)
            public getMessageDigest(): java.security.MessageDigest
            public setMessageDigest(arg0: java.security.MessageDigest): void
            public read(): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public on(arg0: boolean): void
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class DigestOutputStream extends java.io.FilterOutputStream {
            protected digest: java.security.MessageDigest
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.security.MessageDigest)
            public getMessageDigest(): java.security.MessageDigest
            public setMessageDigest(arg0: java.security.MessageDigest): void
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public on(arg0: boolean): void
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface DomainCombiner {
            combine(arg0: java.security.ProtectionDomain[], arg1: java.security.ProtectionDomain[]): java.security.ProtectionDomain[]
        }
        interface DomainCombiner$$Lambda {
            (arg0: java.security.ProtectionDomain[], arg1: java.security.ProtectionDomain[]): java.security.ProtectionDomain[]
        }
        class DomainLoadStoreParameter implements java.security.KeyStore$LoadStoreParameter {
            public constructor(arg0: java.net.URI, arg1: java.util.Map<java.lang.String, java.security.KeyStore$ProtectionParameter>)
            public getConfiguration(): java.net.URI
            public getProtectionParams(): java.util.Map<java.lang.String, java.security.KeyStore$ProtectionParameter>
            public getProtectionParameter(): java.security.KeyStore$ProtectionParameter
            public static class: java.lang.Class<any>
        }
        class GeneralSecurityException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        interface Guard {
            checkGuard(arg0: java.lang.Object): void
        }
        interface Guard$$Lambda {
            (arg0: java.lang.Object): void
        }
        class GuardedObject implements java.io.Serializable {
            public constructor(arg0: java.lang.Object, arg1: java.security.Guard | java.security.Guard$$Lambda)
            public getObject(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        abstract class Identity implements java.security.Principal , java.io.Serializable {
            protected constructor()
            public constructor(arg0: java.lang.String | string, arg1: java.security.IdentityScope)
            public constructor(arg0: java.lang.String | string)
            public getName(): string
            public getScope(): java.security.IdentityScope
            public getPublicKey(): java.security.PublicKey
            public setPublicKey(arg0: java.security.PublicKey): void
            public setInfo(arg0: java.lang.String | string): void
            public getInfo(): string
            public addCertificate(arg0: java.security.Certificate): void
            public removeCertificate(arg0: java.security.Certificate): void
            public certificates(): java.security.Certificate[]
            public equals(arg0: java.lang.Object): boolean
            protected identityEquals(arg0: java.security.Identity): boolean
            public toString(): string
            public toString(arg0: boolean): string
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        abstract class IdentityScope extends java.security.Identity {
            protected constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.security.IdentityScope)
            public static getSystemScope(): java.security.IdentityScope
            protected static setSystemScope(arg0: java.security.IdentityScope): void
            public size(): int
            public getIdentity(arg0: java.lang.String | string): java.security.Identity
            public getIdentity(arg0: java.security.Principal): java.security.Identity
            public getIdentity(arg0: java.security.PublicKey): java.security.Identity
            public addIdentity(arg0: java.security.Identity): void
            public removeIdentity(arg0: java.security.Identity): void
            public identities(): java.util.Enumeration<java.security.Identity>
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class InvalidAlgorithmParameterException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class InvalidKeyException extends java.security.KeyException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class InvalidParameterException extends java.lang.IllegalArgumentException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface Key extends java.io.Serializable {
            serialVersionUID: long
            getAlgorithm(): string
            getFormat(): string
            getEncoded(): byte[]
        }
        class KeyException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class KeyFactory {
            protected constructor(arg0: java.security.KeyFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public static getInstance(arg0: java.lang.String | string): java.security.KeyFactory
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.KeyFactory
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.KeyFactory
            public getProvider(): java.security.Provider
            public getAlgorithm(): string
            public generatePublic(arg0: java.security.spec.KeySpec): java.security.PublicKey
            public generatePrivate(arg0: java.security.spec.KeySpec): java.security.PrivateKey
            public getKeySpec<T extends java.security.spec.KeySpec>(arg0: java.security.Key, arg1: java.lang.Class<T>): T
            public translateKey(arg0: java.security.Key): java.security.Key
            public static class: java.lang.Class<any>
        }
        abstract class KeyFactorySpi {
            public constructor()
            protected engineGeneratePublic(arg0: java.security.spec.KeySpec): java.security.PublicKey
            protected engineGeneratePrivate(arg0: java.security.spec.KeySpec): java.security.PrivateKey
            protected engineGetKeySpec<T extends java.security.spec.KeySpec>(arg0: java.security.Key, arg1: java.lang.Class<T>): T
            protected engineTranslateKey(arg0: java.security.Key): java.security.Key
            public static class: java.lang.Class<any>
        }
        class KeyManagementException extends java.security.KeyException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class KeyPair implements java.io.Serializable {
            public constructor(arg0: java.security.PublicKey, arg1: java.security.PrivateKey)
            public getPublic(): java.security.PublicKey
            public getPrivate(): java.security.PrivateKey
            public static class: java.lang.Class<any>
        }
        abstract class KeyPairGenerator extends java.security.KeyPairGeneratorSpi {
            protected constructor(arg0: java.lang.String | string)
            public getAlgorithm(): string
            public static getInstance(arg0: java.lang.String | string): java.security.KeyPairGenerator
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.KeyPairGenerator
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.KeyPairGenerator
            public getProvider(): java.security.Provider
            public initialize(arg0: int): void
            public initialize(arg0: int, arg1: java.security.SecureRandom): void
            public initialize(arg0: java.security.spec.AlgorithmParameterSpec): void
            public initialize(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
            public genKeyPair(): java.security.KeyPair
            public generateKeyPair(): java.security.KeyPair
            public static class: java.lang.Class<any>
        }
        abstract class KeyPairGeneratorSpi {
            public constructor()
            public initialize(arg0: int, arg1: java.security.SecureRandom): void
            public initialize(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
            public generateKeyPair(): java.security.KeyPair
            public static class: java.lang.Class<any>
        }
        class KeyRep implements java.io.Serializable {
            public constructor(arg0: java.security.KeyRep$Type, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: byte[])
            protected readResolve(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class KeyStore {
            protected constructor(arg0: java.security.KeyStoreSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public static getInstance(arg0: java.lang.String | string): java.security.KeyStore
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.KeyStore
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.KeyStore
            public static getDefaultType(): string
            public getProvider(): java.security.Provider
            public getType(): string
            public getKey(arg0: java.lang.String | string, arg1: char[]): java.security.Key
            public getCertificateChain(arg0: java.lang.String | string): java.security.cert.Certificate[]
            public getCertificate(arg0: java.lang.String | string): java.security.cert.Certificate
            public getCreationDate(arg0: java.lang.String | string): java.util.Date
            public setKeyEntry(arg0: java.lang.String | string, arg1: java.security.Key, arg2: char[], arg3: java.security.cert.Certificate[]): void
            public setKeyEntry(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.cert.Certificate[]): void
            public setCertificateEntry(arg0: java.lang.String | string, arg1: java.security.cert.Certificate): void
            public deleteEntry(arg0: java.lang.String | string): void
            public aliases(): java.util.Enumeration<java.lang.String>
            public containsAlias(arg0: java.lang.String | string): boolean
            public size(): int
            public isKeyEntry(arg0: java.lang.String | string): boolean
            public isCertificateEntry(arg0: java.lang.String | string): boolean
            public getCertificateAlias(arg0: java.security.cert.Certificate): string
            public store(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: char[]): void
            public store(arg0: java.security.KeyStore$LoadStoreParameter): void
            public load(arg0: java.io.InputStream, arg1: char[]): void
            public load(arg0: java.security.KeyStore$LoadStoreParameter): void
            public getEntry(arg0: java.lang.String | string, arg1: java.security.KeyStore$ProtectionParameter): java.security.KeyStore$Entry
            public setEntry(arg0: java.lang.String | string, arg1: java.security.KeyStore$Entry, arg2: java.security.KeyStore$ProtectionParameter): void
            public entryInstanceOf(arg0: java.lang.String | string, arg1: java.lang.Class<java.security.KeyStore$Entry>): boolean
            public static class: java.lang.Class<any>
        }
        class KeyStoreException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        abstract class KeyStoreSpi {
            public constructor()
            public engineGetKey(arg0: java.lang.String | string, arg1: char[]): java.security.Key
            public engineGetCertificateChain(arg0: java.lang.String | string): java.security.cert.Certificate[]
            public engineGetCertificate(arg0: java.lang.String | string): java.security.cert.Certificate
            public engineGetCreationDate(arg0: java.lang.String | string): java.util.Date
            public engineSetKeyEntry(arg0: java.lang.String | string, arg1: java.security.Key, arg2: char[], arg3: java.security.cert.Certificate[]): void
            public engineSetKeyEntry(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.cert.Certificate[]): void
            public engineSetCertificateEntry(arg0: java.lang.String | string, arg1: java.security.cert.Certificate): void
            public engineDeleteEntry(arg0: java.lang.String | string): void
            public engineAliases(): java.util.Enumeration<java.lang.String>
            public engineContainsAlias(arg0: java.lang.String | string): boolean
            public engineSize(): int
            public engineIsKeyEntry(arg0: java.lang.String | string): boolean
            public engineIsCertificateEntry(arg0: java.lang.String | string): boolean
            public engineGetCertificateAlias(arg0: java.security.cert.Certificate): string
            public engineStore(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: char[]): void
            public engineStore(arg0: java.security.KeyStore$LoadStoreParameter): void
            public engineLoad(arg0: java.io.InputStream, arg1: char[]): void
            public engineLoad(arg0: java.security.KeyStore$LoadStoreParameter): void
            public engineGetEntry(arg0: java.lang.String | string, arg1: java.security.KeyStore$ProtectionParameter): java.security.KeyStore$Entry
            public engineSetEntry(arg0: java.lang.String | string, arg1: java.security.KeyStore$Entry, arg2: java.security.KeyStore$ProtectionParameter): void
            public engineEntryInstanceOf(arg0: java.lang.String | string, arg1: java.lang.Class<java.security.KeyStore$Entry>): boolean
            public static class: java.lang.Class<any>
        }
        abstract class MessageDigest extends java.security.MessageDigestSpi {
            protected constructor(arg0: java.lang.String | string)
            public static getInstance(arg0: java.lang.String | string): java.security.MessageDigest
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.MessageDigest
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.MessageDigest
            public getProvider(): java.security.Provider
            public update(arg0: byte): void
            public update(arg0: byte[], arg1: int, arg2: int): void
            public update(arg0: byte[]): void
            public update(arg0: java.nio.ByteBuffer): void
            public digest(): byte[]
            public digest(arg0: byte[], arg1: int, arg2: int): int
            public digest(arg0: byte[]): byte[]
            public toString(): string
            public static isEqual(arg0: byte[], arg1: byte[]): boolean
            public reset(): void
            public getAlgorithm(): string
            public getDigestLength(): int
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        abstract class MessageDigestSpi {
            public constructor()
            protected engineGetDigestLength(): int
            protected engineUpdate(arg0: byte): void
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
            protected engineUpdate(arg0: java.nio.ByteBuffer): void
            protected engineDigest(): byte[]
            protected engineDigest(arg0: byte[], arg1: int, arg2: int): int
            protected engineReset(): void
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class NoSuchAlgorithmException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class NoSuchProviderException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class PKCS12Attribute implements java.security.KeyStore$Entry$Attribute {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: byte[])
            public getName(): string
            public getValue(): string
            public getEncoded(): byte[]
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class Permission implements java.security.Guard , java.io.Serializable {
            public constructor(arg0: java.lang.String | string)
            public checkGuard(arg0: java.lang.Object): void
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getName(): string
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class PermissionCollection implements java.io.Serializable {
            public constructor()
            public add(arg0: java.security.Permission): void
            public implies(arg0: java.security.Permission): boolean
            public elements(): java.util.Enumeration<java.security.Permission>
            public setReadOnly(): void
            public isReadOnly(): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class Permissions extends java.security.PermissionCollection implements java.io.Serializable {
            public constructor()
            public add(arg0: java.security.Permission): void
            public implies(arg0: java.security.Permission): boolean
            public elements(): java.util.Enumeration<java.security.Permission>
            public static class: java.lang.Class<any>
        }
        abstract class Policy {
            public static UNSUPPORTED_EMPTY_COLLECTION: java.security.PermissionCollection
            public constructor()
            public static getPolicy(): java.security.Policy
            public static setPolicy(arg0: java.security.Policy): void
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Policy$Parameters): java.security.Policy
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Policy$Parameters, arg2: java.lang.String | string): java.security.Policy
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Policy$Parameters, arg2: java.security.Provider): java.security.Policy
            public getProvider(): java.security.Provider
            public getType(): string
            public getParameters(): java.security.Policy$Parameters
            public getPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
            public getPermissions(arg0: java.security.ProtectionDomain): java.security.PermissionCollection
            public implies(arg0: java.security.ProtectionDomain, arg1: java.security.Permission): boolean
            public refresh(): void
            public static class: java.lang.Class<any>
        }
        abstract class PolicySpi {
            public constructor()
            protected engineImplies(arg0: java.security.ProtectionDomain, arg1: java.security.Permission): boolean
            protected engineRefresh(): void
            protected engineGetPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
            protected engineGetPermissions(arg0: java.security.ProtectionDomain): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        interface Principal {
            equals(arg0: java.lang.Object): boolean
            toString(): string
            hashCode(): int
            getName(): string
            implies(arg0: javax.security.auth.Subject): boolean
        }
        interface PrivateKey extends java.security.Key , javax.security.auth.Destroyable {
            serialVersionUID: long
        }
        interface PrivilegedAction<T> {
            run(): T
        }
        interface PrivilegedAction$$Lambda<T> {
            (): T
        }
        class PrivilegedActionException extends java.lang.Exception {
            public constructor(arg0: java.lang.Exception)
            public getException(): java.lang.Exception
            public getCause(): java.lang.Throwable
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface PrivilegedExceptionAction<T> {
            run(): T
        }
        interface PrivilegedExceptionAction$$Lambda<T> {
            (): T
        }
        class ProtectionDomain {
            public constructor(arg0: java.security.CodeSource, arg1: java.security.PermissionCollection)
            public constructor(arg0: java.security.CodeSource, arg1: java.security.PermissionCollection, arg2: java.lang.ClassLoader, arg3: java.security.Principal[])
            public getCodeSource(): java.security.CodeSource
            public getClassLoader(): java.lang.ClassLoader
            public getPrincipals(): java.security.Principal[]
            public getPermissions(): java.security.PermissionCollection
            public implies(arg0: java.security.Permission): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class Provider extends java.util.Properties {
            protected constructor(arg0: java.lang.String | string, arg1: double, arg2: java.lang.String | string)
            public getName(): string
            public getVersion(): double
            public getInfo(): string
            public toString(): string
            public clear(): void
            public load(arg0: java.io.InputStream): void
            public putAll(arg0: java.util.Map<any, any>): void
            public entrySet(): java.util.Set<java.util.Map$Entry<java.lang.Object, java.lang.Object>>
            public keySet(): java.util.Set<java.lang.Object>
            public values(): java.util.Collection<java.lang.Object>
            public put(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
            public putIfAbsent(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
            public remove(arg0: java.lang.Object): java.lang.Object
            public remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
            public replace(arg0: java.lang.Object, arg1: java.lang.Object, arg2: java.lang.Object): boolean
            public replace(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
            public replaceAll(arg0: java.util.function$.BiFunction<java.lang.Object, java.lang.Object, java.lang.Object>): void
            public compute(arg0: java.lang.Object, arg1: java.util.function$.BiFunction<java.lang.Object, java.lang.Object, java.lang.Object>): java.lang.Object
            public computeIfAbsent(arg0: java.lang.Object, arg1: java.util.function$.Function<java.lang.Object, java.lang.Object>): java.lang.Object
            public computeIfPresent(arg0: java.lang.Object, arg1: java.util.function$.BiFunction<java.lang.Object, java.lang.Object, java.lang.Object>): java.lang.Object
            public merge(arg0: java.lang.Object, arg1: java.lang.Object, arg2: java.util.function$.BiFunction<java.lang.Object, java.lang.Object, java.lang.Object>): java.lang.Object
            public get(arg0: java.lang.Object): java.lang.Object
            public getOrDefault(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
            public forEach(arg0: java.util.function$.BiConsumer<java.lang.Object, java.lang.Object>): void
            public keys(): java.util.Enumeration<java.lang.Object>
            public elements(): java.util.Enumeration<java.lang.Object>
            public getProperty(arg0: java.lang.String | string): string
            public getService(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.Provider$Service
            public getServices(): java.util.Set<java.security.Provider$Service>
            protected putService(arg0: java.security.Provider$Service): void
            protected removeService(arg0: java.security.Provider$Service): void
            public static class: java.lang.Class<any>
        }
        class ProviderException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        interface PublicKey extends java.security.Key {
            serialVersionUID: long
        }
        class SecureClassLoader extends java.lang.ClassLoader {
            protected constructor(arg0: java.lang.ClassLoader)
            protected constructor()
            protected defineClass(arg0: java.lang.String | string, arg1: byte[], arg2: int, arg3: int, arg4: java.security.CodeSource): java.lang.Class<any>
            protected defineClass(arg0: java.lang.String | string, arg1: java.nio.ByteBuffer, arg2: java.security.CodeSource): java.lang.Class<any>
            protected getPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        class SecureRandom extends java.util.Random {
            public constructor()
            public constructor(arg0: byte[])
            protected constructor(arg0: java.security.SecureRandomSpi, arg1: java.security.Provider)
            public static getInstance(arg0: java.lang.String | string): java.security.SecureRandom
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.SecureRandom
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.SecureRandom
            public getProvider(): java.security.Provider
            public getAlgorithm(): string
            public setSeed(arg0: byte[]): void
            public setSeed(arg0: long): void
            public nextBytes(arg0: byte[]): void
            protected next(arg0: int): int
            public static getSeed(arg0: int): byte[]
            public generateSeed(arg0: int): byte[]
            public static getInstanceStrong(): java.security.SecureRandom
            public static class: java.lang.Class<any>
        }
        abstract class SecureRandomSpi implements java.io.Serializable {
            public constructor()
            protected engineSetSeed(arg0: byte[]): void
            protected engineNextBytes(arg0: byte[]): void
            protected engineGenerateSeed(arg0: int): byte[]
            public static class: java.lang.Class<any>
        }
        class Security {
            public static getAlgorithmProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public static insertProviderAt(arg0: java.security.Provider, arg1: int): int
            public static addProvider(arg0: java.security.Provider): int
            public static removeProvider(arg0: java.lang.String | string): void
            public static getProviders(): java.security.Provider[]
            public static getProvider(arg0: java.lang.String | string): java.security.Provider
            public static getProviders(arg0: java.lang.String | string): java.security.Provider[]
            public static getProviders(arg0: java.util.Map<java.lang.String, java.lang.String>): java.security.Provider[]
            public static getProperty(arg0: java.lang.String | string): string
            public static setProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
            public static getAlgorithms(arg0: java.lang.String | string): java.util.Set<java.lang.String>
            public static class: java.lang.Class<any>
        }
        class SecurityPermission extends java.security.BasicPermission {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        abstract class Signature extends java.security.SignatureSpi {
            protected static UNINITIALIZED: int
            protected static SIGN: int
            protected static VERIFY: int
            protected state: int
            protected constructor(arg0: java.lang.String | string)
            public static getInstance(arg0: java.lang.String | string): java.security.Signature
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.Signature
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): java.security.Signature
            public getProvider(): java.security.Provider
            public initVerify(arg0: java.security.PublicKey): void
            public initVerify(arg0: java.security.cert.Certificate): void
            public initSign(arg0: java.security.PrivateKey): void
            public initSign(arg0: java.security.PrivateKey, arg1: java.security.SecureRandom): void
            public sign(): byte[]
            public sign(arg0: byte[], arg1: int, arg2: int): int
            public verify(arg0: byte[]): boolean
            public verify(arg0: byte[], arg1: int, arg2: int): boolean
            public update(arg0: byte): void
            public update(arg0: byte[]): void
            public update(arg0: byte[], arg1: int, arg2: int): void
            public update(arg0: java.nio.ByteBuffer): void
            public getAlgorithm(): string
            public toString(): string
            public setParameter(arg0: java.lang.String | string, arg1: java.lang.Object): void
            public setParameter(arg0: java.security.spec.AlgorithmParameterSpec): void
            public getParameters(): java.security.AlgorithmParameters
            public getParameter(arg0: java.lang.String | string): java.lang.Object
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class SignatureException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public constructor(arg0: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        abstract class SignatureSpi {
            protected appRandom: java.security.SecureRandom
            public constructor()
            protected engineInitVerify(arg0: java.security.PublicKey): void
            protected engineInitSign(arg0: java.security.PrivateKey): void
            protected engineInitSign(arg0: java.security.PrivateKey, arg1: java.security.SecureRandom): void
            protected engineUpdate(arg0: byte): void
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
            protected engineUpdate(arg0: java.nio.ByteBuffer): void
            protected engineSign(): byte[]
            protected engineSign(arg0: byte[], arg1: int, arg2: int): int
            protected engineVerify(arg0: byte[]): boolean
            protected engineVerify(arg0: byte[], arg1: int, arg2: int): boolean
            protected engineSetParameter(arg0: java.lang.String | string, arg1: java.lang.Object): void
            protected engineSetParameter(arg0: java.security.spec.AlgorithmParameterSpec): void
            protected engineGetParameters(): java.security.AlgorithmParameters
            protected engineGetParameter(arg0: java.lang.String | string): java.lang.Object
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class SignedObject implements java.io.Serializable {
            public constructor(arg0: java.io.Serializable, arg1: java.security.PrivateKey, arg2: java.security.Signature)
            public getObject(): java.lang.Object
            public getSignature(): byte[]
            public getAlgorithm(): string
            public verify(arg0: java.security.PublicKey, arg1: java.security.Signature): boolean
            public static class: java.lang.Class<any>
        }
        abstract class Signer extends java.security.Identity {
            protected constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.security.IdentityScope)
            public getPrivateKey(): java.security.PrivateKey
            public setKeyPair(arg0: java.security.KeyPair): void
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class Timestamp implements java.io.Serializable {
            public constructor(arg0: java.util.Date, arg1: java.security.cert.CertPath)
            public getTimestamp(): java.util.Date
            public getSignerCertPath(): java.security.cert.CertPath
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class URIParameter implements java.security.Policy$Parameters , javax.security.auth.login.Configuration$Parameters {
            public constructor(arg0: java.net.URI)
            public getURI(): java.net.URI
            public static class: java.lang.Class<any>
        }
        class UnrecoverableEntryException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UnrecoverableKeyException extends java.security.UnrecoverableEntryException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class UnresolvedPermission extends java.security.Permission implements java.io.Serializable {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.security.cert.Certificate[])
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public getUnresolvedType(): string
            public getUnresolvedName(): string
            public getUnresolvedActions(): string
            public getUnresolvedCerts(): java.security.cert.Certificate[]
            public toString(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        class UnresolvedPermissionCollection extends java.security.PermissionCollection implements java.io.Serializable {
            public constructor()
            public add(arg0: java.security.Permission): void
            public implies(arg0: java.security.Permission): boolean
            public elements(): java.util.Enumeration<java.security.Permission>
            public static class: java.lang.Class<any>
        }
    }
    namespace text {
        namespace spi {
            abstract class BreakIteratorProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getWordInstance(arg0: java.util.Locale): java.text.BreakIterator
                public getLineInstance(arg0: java.util.Locale): java.text.BreakIterator
                public getCharacterInstance(arg0: java.util.Locale): java.text.BreakIterator
                public getSentenceInstance(arg0: java.util.Locale): java.text.BreakIterator
                public static class: java.lang.Class<any>
            }
            abstract class CollatorProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getInstance(arg0: java.util.Locale): java.text.Collator
                public static class: java.lang.Class<any>
            }
            abstract class DateFormatProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getTimeInstance(arg0: int, arg1: java.util.Locale): java.text.DateFormat
                public getDateInstance(arg0: int, arg1: java.util.Locale): java.text.DateFormat
                public getDateTimeInstance(arg0: int, arg1: int, arg2: java.util.Locale): java.text.DateFormat
                public static class: java.lang.Class<any>
            }
            abstract class DateFormatSymbolsProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getInstance(arg0: java.util.Locale): java.text.DateFormatSymbols
                public static class: java.lang.Class<any>
            }
            abstract class DecimalFormatSymbolsProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getInstance(arg0: java.util.Locale): java.text.DecimalFormatSymbols
                public static class: java.lang.Class<any>
            }
            abstract class NumberFormatProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getCurrencyInstance(arg0: java.util.Locale): java.text.NumberFormat
                public getIntegerInstance(arg0: java.util.Locale): java.text.NumberFormat
                public getNumberInstance(arg0: java.util.Locale): java.text.NumberFormat
                public getPercentInstance(arg0: java.util.Locale): java.text.NumberFormat
                public static class: java.lang.Class<any>
            }
        }
        class Annotation {
            public constructor(arg0: java.lang.Object)
            public getValue(): java.lang.Object
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface AttributedCharacterIterator extends java.text.CharacterIterator {
            getRunStart(): int
            getRunStart(arg0: java.text.AttributedCharacterIterator$Attribute): int
            getRunStart(arg0: java.util.Set<java.text.AttributedCharacterIterator$Attribute>): int
            getRunLimit(): int
            getRunLimit(arg0: java.text.AttributedCharacterIterator$Attribute): int
            getRunLimit(arg0: java.util.Set<java.text.AttributedCharacterIterator$Attribute>): int
            getAttributes(): java.util.Map<java.text.AttributedCharacterIterator$Attribute, java.lang.Object>
            getAttribute(arg0: java.text.AttributedCharacterIterator$Attribute): java.lang.Object
            getAllAttributeKeys(): java.util.Set<java.text.AttributedCharacterIterator$Attribute>
        }
        class AttributedString {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.util.Map<java.text.AttributedCharacterIterator$Attribute, any>)
            public constructor(arg0: java.text.AttributedCharacterIterator)
            public constructor(arg0: java.text.AttributedCharacterIterator, arg1: int, arg2: int)
            public constructor(arg0: java.text.AttributedCharacterIterator, arg1: int, arg2: int, arg3: java.text.AttributedCharacterIterator$Attribute[])
            public addAttribute(arg0: java.text.AttributedCharacterIterator$Attribute, arg1: java.lang.Object): void
            public addAttribute(arg0: java.text.AttributedCharacterIterator$Attribute, arg1: java.lang.Object, arg2: int, arg3: int): void
            public addAttributes(arg0: java.util.Map<java.text.AttributedCharacterIterator$Attribute, any>, arg1: int, arg2: int): void
            public getIterator(): java.text.AttributedCharacterIterator
            public getIterator(arg0: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator
            public getIterator(arg0: java.text.AttributedCharacterIterator$Attribute[], arg1: int, arg2: int): java.text.AttributedCharacterIterator
            public static class: java.lang.Class<any>
        }
        class Bidi {
            public static DIRECTION_LEFT_TO_RIGHT: int
            public static DIRECTION_RIGHT_TO_LEFT: int
            public static DIRECTION_DEFAULT_LEFT_TO_RIGHT: int
            public static DIRECTION_DEFAULT_RIGHT_TO_LEFT: int
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor(arg0: java.text.AttributedCharacterIterator)
            public constructor(arg0: char[], arg1: int, arg2: byte[], arg3: int, arg4: int, arg5: int)
            public createLineBidi(arg0: int, arg1: int): java.text.Bidi
            public isMixed(): boolean
            public isLeftToRight(): boolean
            public isRightToLeft(): boolean
            public getLength(): int
            public baseIsLeftToRight(): boolean
            public getBaseLevel(): int
            public getLevelAt(arg0: int): int
            public getRunCount(): int
            public getRunLevel(arg0: int): int
            public getRunStart(arg0: int): int
            public getRunLimit(arg0: int): int
            public static requiresBidi(arg0: char[], arg1: int, arg2: int): boolean
            public static reorderVisually(arg0: byte[], arg1: int, arg2: java.lang.Object[], arg3: int, arg4: int): void
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class BreakIterator implements java.lang.Cloneable {
            public static DONE: int
            protected constructor()
            public clone(): java.lang.Object
            public first(): int
            public last(): int
            public next(arg0: int): int
            public next(): int
            public previous(): int
            public following(arg0: int): int
            public preceding(arg0: int): int
            public isBoundary(arg0: int): boolean
            public current(): int
            public getText(): java.text.CharacterIterator
            public setText(arg0: java.lang.String | string): void
            public setText(arg0: java.text.CharacterIterator): void
            public static getWordInstance(): java.text.BreakIterator
            public static getWordInstance(arg0: java.util.Locale): java.text.BreakIterator
            public static getLineInstance(): java.text.BreakIterator
            public static getLineInstance(arg0: java.util.Locale): java.text.BreakIterator
            public static getCharacterInstance(): java.text.BreakIterator
            public static getCharacterInstance(arg0: java.util.Locale): java.text.BreakIterator
            public static getSentenceInstance(): java.text.BreakIterator
            public static getSentenceInstance(arg0: java.util.Locale): java.text.BreakIterator
            public static getAvailableLocales(): java.util.Locale[]
            public static class: java.lang.Class<any>
        }
        class CalendarBuilder {
            public static WEEK_YEAR: int
            public static ISO_DAY_OF_WEEK: int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface CharacterIterator extends java.lang.Cloneable {
            DONE: char
            first(): char
            last(): char
            current(): char
            next(): char
            previous(): char
            setIndex(arg0: int): char
            getBeginIndex(): int
            getEndIndex(): int
            getIndex(): int
            clone(): java.lang.Object
        }
        class CharacterIteratorFieldDelegate implements java.text.Format$FieldDelegate {
            public formatted(arg0: java.text.Format$Field, arg1: java.lang.Object, arg2: int, arg3: int, arg4: java.lang.StringBuffer): void
            public formatted(arg0: int, arg1: java.text.Format$Field, arg2: java.lang.Object, arg3: int, arg4: int, arg5: java.lang.StringBuffer): void
            public getIterator(arg0: java.lang.String | string): java.text.AttributedCharacterIterator
            public static class: java.lang.Class<any>
        }
        class ChoiceFormat extends java.text.NumberFormat {
            public applyPattern(arg0: java.lang.String | string): void
            public toPattern(): string
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: double[], arg1: java.lang.String[])
            public setChoices(arg0: double[], arg1: java.lang.String[]): void
            public getLimits(): double[]
            public getFormats(): java.lang.Object[]
            public format(arg0: long, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public format(arg0: double, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public parse(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Number
            public static nextDouble(arg0: double): double
            public static previousDouble(arg0: double): double
            public clone(): java.lang.Object
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public static nextDouble(arg0: double, arg1: boolean): double
            public static class: java.lang.Class<any>
        }
        class CollationElementIterator {
            public static NULLORDER: int
            public reset(): void
            public next(): int
            public previous(): int
            public static primaryOrder(arg0: int): int
            public static secondaryOrder(arg0: int): short
            public static tertiaryOrder(arg0: int): short
            public setOffset(arg0: int): void
            public getOffset(): int
            public getMaxExpansion(arg0: int): int
            public setText(arg0: java.lang.String | string): void
            public setText(arg0: java.text.CharacterIterator): void
            public static class: java.lang.Class<any>
        }
        abstract class CollationKey implements java.lang.Comparable<java.text.CollationKey> {
            public compareTo(arg0: java.text.CollationKey): int
            public getSourceString(): string
            public toByteArray(): byte[]
            protected constructor(arg0: java.lang.String | string)
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        abstract class Collator implements java.util.Comparator<java.lang.Object> , java.lang.Cloneable {
            public static PRIMARY: int
            public static SECONDARY: int
            public static TERTIARY: int
            public static IDENTICAL: int
            public static NO_DECOMPOSITION: int
            public static CANONICAL_DECOMPOSITION: int
            public static FULL_DECOMPOSITION: int
            public static getInstance(): java.text.Collator
            public static getInstance(arg0: java.util.Locale): java.text.Collator
            public compare(arg0: java.lang.String | string, arg1: java.lang.String | string): int
            public compare(arg0: java.lang.Object, arg1: java.lang.Object): int
            public getCollationKey(arg0: java.lang.String | string): java.text.CollationKey
            public equals(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
            public getStrength(): int
            public setStrength(arg0: int): void
            public getDecomposition(): int
            public setDecomposition(arg0: int): void
            public static getAvailableLocales(): java.util.Locale[]
            public clone(): java.lang.Object
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            protected constructor()
            public static class: java.lang.Class<any>
        }
        abstract class DateFormat extends java.text.Format {
            protected calendar: java.util.Calendar
            protected numberFormat: java.text.NumberFormat
            public static ERA_FIELD: int
            public static YEAR_FIELD: int
            public static MONTH_FIELD: int
            public static DATE_FIELD: int
            public static HOUR_OF_DAY1_FIELD: int
            public static HOUR_OF_DAY0_FIELD: int
            public static MINUTE_FIELD: int
            public static SECOND_FIELD: int
            public static MILLISECOND_FIELD: int
            public static DAY_OF_WEEK_FIELD: int
            public static DAY_OF_YEAR_FIELD: int
            public static DAY_OF_WEEK_IN_MONTH_FIELD: int
            public static WEEK_OF_YEAR_FIELD: int
            public static WEEK_OF_MONTH_FIELD: int
            public static AM_PM_FIELD: int
            public static HOUR1_FIELD: int
            public static HOUR0_FIELD: int
            public static TIMEZONE_FIELD: int
            public static FULL: int
            public static LONG: int
            public static MEDIUM: int
            public static SHORT: int
            public static DEFAULT: int
            public format(arg0: java.lang.Object, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public format(arg0: java.util.Date, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public format(arg0: java.util.Date): string
            public parse(arg0: java.lang.String | string): java.util.Date
            public parse(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.util.Date
            public parseObject(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Object
            public static getTimeInstance(): java.text.DateFormat
            public static getTimeInstance(arg0: int): java.text.DateFormat
            public static getTimeInstance(arg0: int, arg1: java.util.Locale): java.text.DateFormat
            public static getDateInstance(): java.text.DateFormat
            public static getDateInstance(arg0: int): java.text.DateFormat
            public static getDateInstance(arg0: int, arg1: java.util.Locale): java.text.DateFormat
            public static getDateTimeInstance(): java.text.DateFormat
            public static getDateTimeInstance(arg0: int, arg1: int): java.text.DateFormat
            public static getDateTimeInstance(arg0: int, arg1: int, arg2: java.util.Locale): java.text.DateFormat
            public static getInstance(): java.text.DateFormat
            public static getAvailableLocales(): java.util.Locale[]
            public setCalendar(arg0: java.util.Calendar): void
            public getCalendar(): java.util.Calendar
            public setNumberFormat(arg0: java.text.NumberFormat): void
            public getNumberFormat(): java.text.NumberFormat
            public setTimeZone(arg0: java.util.TimeZone): void
            public getTimeZone(): java.util.TimeZone
            public setLenient(arg0: boolean): void
            public isLenient(): boolean
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public clone(): java.lang.Object
            protected constructor()
            public static class: java.lang.Class<any>
        }
        class DateFormatSymbols implements java.io.Serializable , java.lang.Cloneable {
            public constructor()
            public constructor(arg0: java.util.Locale)
            public static getAvailableLocales(): java.util.Locale[]
            public static getInstance(): java.text.DateFormatSymbols
            public static getInstance(arg0: java.util.Locale): java.text.DateFormatSymbols
            public getEras(): java.lang.String[]
            public setEras(arg0: java.lang.String[]): void
            public getMonths(): java.lang.String[]
            public setMonths(arg0: java.lang.String[]): void
            public getShortMonths(): java.lang.String[]
            public setShortMonths(arg0: java.lang.String[]): void
            public getWeekdays(): java.lang.String[]
            public setWeekdays(arg0: java.lang.String[]): void
            public getShortWeekdays(): java.lang.String[]
            public setShortWeekdays(arg0: java.lang.String[]): void
            public getAmPmStrings(): java.lang.String[]
            public setAmPmStrings(arg0: java.lang.String[]): void
            public getZoneStrings(): java.lang.String[][]
            public setZoneStrings(arg0: java.lang.String[][]): void
            public getLocalPatternChars(): string
            public setLocalPatternChars(arg0: java.lang.String | string): void
            public clone(): java.lang.Object
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public static class: java.lang.Class<any>
        }
        class DecimalFormat extends java.text.NumberFormat {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.text.DecimalFormatSymbols)
            public format(arg0: java.lang.Object, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public format(arg0: double, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public format(arg0: long, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public formatToCharacterIterator(arg0: java.lang.Object): java.text.AttributedCharacterIterator
            public parse(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Number
            public getDecimalFormatSymbols(): java.text.DecimalFormatSymbols
            public setDecimalFormatSymbols(arg0: java.text.DecimalFormatSymbols): void
            public getPositivePrefix(): string
            public setPositivePrefix(arg0: java.lang.String | string): void
            public getNegativePrefix(): string
            public setNegativePrefix(arg0: java.lang.String | string): void
            public getPositiveSuffix(): string
            public setPositiveSuffix(arg0: java.lang.String | string): void
            public getNegativeSuffix(): string
            public setNegativeSuffix(arg0: java.lang.String | string): void
            public getMultiplier(): int
            public setMultiplier(arg0: int): void
            public setGroupingUsed(arg0: boolean): void
            public getGroupingSize(): int
            public setGroupingSize(arg0: int): void
            public isDecimalSeparatorAlwaysShown(): boolean
            public setDecimalSeparatorAlwaysShown(arg0: boolean): void
            public isParseBigDecimal(): boolean
            public setParseBigDecimal(arg0: boolean): void
            public clone(): java.lang.Object
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toPattern(): string
            public toLocalizedPattern(): string
            public applyPattern(arg0: java.lang.String | string): void
            public applyLocalizedPattern(arg0: java.lang.String | string): void
            public setMaximumIntegerDigits(arg0: int): void
            public setMinimumIntegerDigits(arg0: int): void
            public setMaximumFractionDigits(arg0: int): void
            public setMinimumFractionDigits(arg0: int): void
            public getMaximumIntegerDigits(): int
            public getMinimumIntegerDigits(): int
            public getMaximumFractionDigits(): int
            public getMinimumFractionDigits(): int
            public getCurrency(): java.util.Currency
            public setCurrency(arg0: java.util.Currency): void
            public getRoundingMode(): java.math.RoundingMode
            public setRoundingMode(arg0: java.math.RoundingMode): void
            public static class: java.lang.Class<any>
        }
        class DecimalFormatSymbols implements java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: java.util.Locale)
            public static getAvailableLocales(): java.util.Locale[]
            public static getInstance(): java.text.DecimalFormatSymbols
            public static getInstance(arg0: java.util.Locale): java.text.DecimalFormatSymbols
            public getZeroDigit(): char
            public setZeroDigit(arg0: char): void
            public getGroupingSeparator(): char
            public setGroupingSeparator(arg0: char): void
            public getDecimalSeparator(): char
            public setDecimalSeparator(arg0: char): void
            public getPerMill(): char
            public setPerMill(arg0: char): void
            public getPercent(): char
            public setPercent(arg0: char): void
            public getDigit(): char
            public setDigit(arg0: char): void
            public getPatternSeparator(): char
            public setPatternSeparator(arg0: char): void
            public getInfinity(): string
            public setInfinity(arg0: java.lang.String | string): void
            public getNaN(): string
            public setNaN(arg0: java.lang.String | string): void
            public getMinusSign(): char
            public setMinusSign(arg0: char): void
            public getCurrencySymbol(): string
            public setCurrencySymbol(arg0: java.lang.String | string): void
            public getInternationalCurrencySymbol(): string
            public setInternationalCurrencySymbol(arg0: java.lang.String | string): void
            public getCurrency(): java.util.Currency
            public setCurrency(arg0: java.util.Currency): void
            public getMonetaryDecimalSeparator(): char
            public setMonetaryDecimalSeparator(arg0: char): void
            public getExponentSeparator(): string
            public setExponentSeparator(arg0: java.lang.String | string): void
            public clone(): java.lang.Object
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        class DigitList implements java.lang.Cloneable {
            public static MAX_COUNT: int
            public decimalAt: int
            public count: int
            public digits: char[]
            public clear(): void
            public append(arg0: char): void
            public getDouble(): double
            public getLong(): long
            public getBigDecimal(): java.math.BigDecimal
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public clone(): java.lang.Object
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class DontCareFieldPosition extends java.text.FieldPosition {
            public static class: java.lang.Class<any>
        }
        class EntryPair {
            public entryName: string
            public value: int
            public fwd: boolean
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor(arg0: java.lang.String | string, arg1: int, arg2: boolean)
            public static class: java.lang.Class<any>
        }
        class FieldPosition {
            public constructor(arg0: int)
            public constructor(arg0: java.text.Format$Field)
            public constructor(arg0: java.text.Format$Field, arg1: int)
            public getFieldAttribute(): java.text.Format$Field
            public getField(): int
            public getBeginIndex(): int
            public getEndIndex(): int
            public setBeginIndex(arg0: int): void
            public setEndIndex(arg0: int): void
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class Format implements java.io.Serializable , java.lang.Cloneable {
            protected constructor()
            public format(arg0: java.lang.Object): string
            public format(arg0: java.lang.Object, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public formatToCharacterIterator(arg0: java.lang.Object): java.text.AttributedCharacterIterator
            public parseObject(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Object
            public parseObject(arg0: java.lang.String | string): java.lang.Object
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class MergeCollation {
            public constructor(arg0: java.lang.String | string)
            public getPattern(): string
            public getPattern(arg0: boolean): string
            public emitPattern(): string
            public emitPattern(arg0: boolean): string
            public setPattern(arg0: java.lang.String | string): void
            public addPattern(arg0: java.lang.String | string): void
            public getCount(): int
            public getItemAt(arg0: int): java.text.PatternEntry
            public static class: java.lang.Class<any>
        }
        class MessageFormat extends java.text.Format {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.util.Locale)
            public setLocale(arg0: java.util.Locale): void
            public getLocale(): java.util.Locale
            public applyPattern(arg0: java.lang.String | string): void
            public toPattern(): string
            public setFormatsByArgumentIndex(arg0: java.text.Format[]): void
            public setFormats(arg0: java.text.Format[]): void
            public setFormatByArgumentIndex(arg0: int, arg1: java.text.Format): void
            public setFormat(arg0: int, arg1: java.text.Format): void
            public getFormatsByArgumentIndex(): java.text.Format[]
            public getFormats(): java.text.Format[]
            public format(arg0: java.lang.Object[], arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public static format(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): string
            public format(arg0: java.lang.Object, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public formatToCharacterIterator(arg0: java.lang.Object): java.text.AttributedCharacterIterator
            public parse(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Object[]
            public parse(arg0: java.lang.String | string): java.lang.Object[]
            public parseObject(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Object
            public clone(): java.lang.Object
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        class Normalizer {
            public static normalize(arg0: java.lang.CharSequence, arg1: java.text.Normalizer$Form): string
            public static isNormalized(arg0: java.lang.CharSequence, arg1: java.text.Normalizer$Form): boolean
            public static class: java.lang.Class<any>
        }
        abstract class NumberFormat extends java.text.Format {
            public static INTEGER_FIELD: int
            public static FRACTION_FIELD: int
            protected constructor()
            public format(arg0: java.lang.Object, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public parseObject(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Object
            public format(arg0: double): string
            public format(arg0: long): string
            public format(arg0: double, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public format(arg0: long, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public parse(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.lang.Number
            public parse(arg0: java.lang.String | string): java.lang.Number
            public isParseIntegerOnly(): boolean
            public setParseIntegerOnly(arg0: boolean): void
            public static getInstance(): java.text.NumberFormat
            public static getInstance(arg0: java.util.Locale): java.text.NumberFormat
            public static getNumberInstance(): java.text.NumberFormat
            public static getNumberInstance(arg0: java.util.Locale): java.text.NumberFormat
            public static getIntegerInstance(): java.text.NumberFormat
            public static getIntegerInstance(arg0: java.util.Locale): java.text.NumberFormat
            public static getCurrencyInstance(): java.text.NumberFormat
            public static getCurrencyInstance(arg0: java.util.Locale): java.text.NumberFormat
            public static getPercentInstance(): java.text.NumberFormat
            public static getPercentInstance(arg0: java.util.Locale): java.text.NumberFormat
            public static getAvailableLocales(): java.util.Locale[]
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public clone(): java.lang.Object
            public isGroupingUsed(): boolean
            public setGroupingUsed(arg0: boolean): void
            public getMaximumIntegerDigits(): int
            public setMaximumIntegerDigits(arg0: int): void
            public getMinimumIntegerDigits(): int
            public setMinimumIntegerDigits(arg0: int): void
            public getMaximumFractionDigits(): int
            public setMaximumFractionDigits(arg0: int): void
            public getMinimumFractionDigits(): int
            public setMinimumFractionDigits(arg0: int): void
            public getCurrency(): java.util.Currency
            public setCurrency(arg0: java.util.Currency): void
            public getRoundingMode(): java.math.RoundingMode
            public setRoundingMode(arg0: java.math.RoundingMode): void
            public static class: java.lang.Class<any>
        }
        class ParseException extends java.lang.Exception {
            public constructor(arg0: java.lang.String | string, arg1: int)
            public getErrorOffset(): int
            public static class: java.lang.Class<any>
        }
        class ParsePosition {
            public getIndex(): int
            public setIndex(arg0: int): void
            public constructor(arg0: int)
            public setErrorIndex(arg0: int): void
            public getErrorIndex(): int
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class PatternEntry {
            public appendQuotedExtension(arg0: java.lang.StringBuffer): void
            public appendQuotedChars(arg0: java.lang.StringBuffer): void
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class RBCollationTables {
            public constructor(arg0: java.lang.String | string, arg1: int)
            public getRules(): string
            public isFrenchSec(): boolean
            public isSEAsianSwapping(): boolean
            public static class: java.lang.Class<any>
        }
        class RBTableBuilder {
            public constructor(arg0: java.text.RBCollationTables$BuildAPI)
            public build(arg0: java.lang.String | string, arg1: int): void
            public static class: java.lang.Class<any>
        }
        class RuleBasedCollationKey extends java.text.CollationKey {
            public compareTo(arg0: java.text.CollationKey): int
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toByteArray(): byte[]
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class RuleBasedCollator extends java.text.Collator {
            public constructor(arg0: java.lang.String | string)
            public getRules(): string
            public getCollationElementIterator(arg0: java.lang.String | string): java.text.CollationElementIterator
            public getCollationElementIterator(arg0: java.text.CharacterIterator): java.text.CollationElementIterator
            public compare(arg0: java.lang.String | string, arg1: java.lang.String | string): int
            public getCollationKey(arg0: java.lang.String | string): java.text.CollationKey
            public clone(): java.lang.Object
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        class SimpleDateFormat extends java.text.DateFormat {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.util.Locale)
            public constructor(arg0: java.lang.String | string, arg1: java.text.DateFormatSymbols)
            public set2DigitYearStart(arg0: java.util.Date): void
            public get2DigitYearStart(): java.util.Date
            public format(arg0: java.util.Date, arg1: java.lang.StringBuffer, arg2: java.text.FieldPosition): java.lang.StringBuffer
            public formatToCharacterIterator(arg0: java.lang.Object): java.text.AttributedCharacterIterator
            public parse(arg0: java.lang.String | string, arg1: java.text.ParsePosition): java.util.Date
            public toPattern(): string
            public toLocalizedPattern(): string
            public applyPattern(arg0: java.lang.String | string): void
            public applyLocalizedPattern(arg0: java.lang.String | string): void
            public getDateFormatSymbols(): java.text.DateFormatSymbols
            public setDateFormatSymbols(arg0: java.text.DateFormatSymbols): void
            public clone(): java.lang.Object
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public static class: java.lang.Class<any>
        }
        class StringCharacterIterator implements java.text.CharacterIterator {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int)
            public setText(arg0: java.lang.String | string): void
            public first(): char
            public last(): char
            public setIndex(arg0: int): char
            public current(): char
            public next(): char
            public previous(): char
            public getBeginIndex(): int
            public getEndIndex(): int
            public getIndex(): int
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
    }
    namespace time {
        namespace chrono {
            abstract class AbstractChronology implements java.time.chrono.Chronology {
                protected constructor()
                public resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                public compareTo(arg0: java.time.chrono.Chronology): int
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public compareTo(arg0: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            interface ChronoLocalDate extends java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.chrono.ChronoLocalDate> {
                timeLineOrder(): java.util.Comparator<java.time.chrono.ChronoLocalDate>
                from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                getChronology(): java.time.chrono.Chronology
                getEra(): java.time.chrono.Era
                isLeapYear(): boolean
                lengthOfMonth(): int
                lengthOfYear(): int
                isSupported(arg0: java.time.temporal.TemporalField): boolean
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean
                with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDate
                with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDate
                plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
                adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                until<R>(arg0: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
                format<R>(arg0: java.time.format.DateTimeFormatter): string
                atTime<R>(arg0: java.time.LocalTime): java.time.chrono.ChronoLocalDateTime<any>
                toEpochDay<R>(): long
                compareTo<R>(arg0: java.time.chrono.ChronoLocalDate): int
                isAfter<R>(arg0: java.time.chrono.ChronoLocalDate): boolean
                isBefore<R>(arg0: java.time.chrono.ChronoLocalDate): boolean
                isEqual<R>(arg0: java.time.chrono.ChronoLocalDate): boolean
                equals<R>(arg0: java.lang.Object): boolean
                hashCode<R>(): int
                toString<R>(): string
                minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                compareTo<R>(arg0: java.lang.Object): int
            }
            abstract class ChronoLocalDateImpl<D extends java.time.chrono.ChronoLocalDate> implements java.time.chrono.ChronoLocalDate , java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.io.Serializable {
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): D
                public with(arg0: java.time.temporal.TemporalField, arg1: long): D
                public plus(arg0: java.time.temporal.TemporalAmount): D
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): D
                public minus(arg0: java.time.temporal.TemporalAmount): D
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): D
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            interface ChronoLocalDateTime<D extends java.time.chrono.ChronoLocalDate> extends java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.chrono.ChronoLocalDateTime<any>> {
                timeLineOrder(): java.util.Comparator<java.time.chrono.ChronoLocalDateTime<any>>
                from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime<any>
                getChronology(): java.time.chrono.Chronology
                toLocalDate(): D
                toLocalTime(): java.time.LocalTime
                isSupported(arg0: java.time.temporal.TemporalField): boolean
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean
                with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDateTime<D>
                with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDateTime<D>
                plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDateTime<D>
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDateTime<D>
                minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDateTime<D>
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDateTime<D>
                query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
                adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                format<R>(arg0: java.time.format.DateTimeFormatter): string
                atZone<R>(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<D>
                toInstant<R>(arg0: java.time.ZoneOffset): java.time.Instant
                toEpochSecond<R>(arg0: java.time.ZoneOffset): long
                compareTo<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): int
                isAfter<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean
                isBefore<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean
                isEqual<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean
                equals<R>(arg0: java.lang.Object): boolean
                hashCode<R>(): int
                toString<R>(): string
                minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                compareTo<R>(arg0: java.lang.Object): int
            }
            class ChronoLocalDateTimeImpl<D extends java.time.chrono.ChronoLocalDate> implements java.time.chrono.ChronoLocalDateTime<D> , java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.io.Serializable {
                public toLocalDate(): D
                public toLocalTime(): java.time.LocalTime
                public isSupported(arg0: java.time.temporal.TemporalField): boolean
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public get(arg0: java.time.temporal.TemporalField): int
                public getLong(arg0: java.time.temporal.TemporalField): long
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDateTimeImpl<D>
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDateTimeImpl<D>
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDateTimeImpl<D>
                public atZone(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<D>
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDateTime
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDateTime
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDateTime
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            interface ChronoPeriod extends java.time.temporal.TemporalAmount {
                between(arg0: java.time.chrono.ChronoLocalDate, arg1: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
                get(arg0: java.time.temporal.TemporalUnit): long
                getUnits(): java.util.List<java.time.temporal.TemporalUnit>
                getChronology(): java.time.chrono.Chronology
                isZero(): boolean
                isNegative(): boolean
                plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoPeriod
                minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoPeriod
                multipliedBy(arg0: int): java.time.chrono.ChronoPeriod
                negated(): java.time.chrono.ChronoPeriod
                normalized(): java.time.chrono.ChronoPeriod
                addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                equals(arg0: java.lang.Object): boolean
                hashCode(): int
                toString(): string
            }
            class ChronoPeriodImpl implements java.time.chrono.ChronoPeriod , java.io.Serializable {
                public get(arg0: java.time.temporal.TemporalUnit): long
                public getUnits(): java.util.List<java.time.temporal.TemporalUnit>
                public getChronology(): java.time.chrono.Chronology
                public isZero(): boolean
                public isNegative(): boolean
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoPeriod
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoPeriod
                public multipliedBy(arg0: int): java.time.chrono.ChronoPeriod
                public normalized(): java.time.chrono.ChronoPeriod
                public addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                public subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                protected writeReplace(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            interface ChronoZonedDateTime<D extends java.time.chrono.ChronoLocalDate> extends java.time.temporal.Temporal , java.lang.Comparable<java.time.chrono.ChronoZonedDateTime<any>> {
                timeLineOrder(): java.util.Comparator<java.time.chrono.ChronoZonedDateTime<any>>
                from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime<any>
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                get(arg0: java.time.temporal.TemporalField): int
                getLong(arg0: java.time.temporal.TemporalField): long
                toLocalDate(): D
                toLocalTime(): java.time.LocalTime
                toLocalDateTime(): java.time.chrono.ChronoLocalDateTime<D>
                getChronology(): java.time.chrono.Chronology
                getOffset(): java.time.ZoneOffset
                getZone(): java.time.ZoneId
                withEarlierOffsetAtOverlap(): java.time.chrono.ChronoZonedDateTime<D>
                withLaterOffsetAtOverlap(): java.time.chrono.ChronoZonedDateTime<D>
                withZoneSameLocal(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<D>
                withZoneSameInstant(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<D>
                isSupported(arg0: java.time.temporal.TemporalField): boolean
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean
                with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoZonedDateTime<D>
                with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoZonedDateTime<D>
                plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoZonedDateTime<D>
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoZonedDateTime<D>
                minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoZonedDateTime<D>
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoZonedDateTime<D>
                query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
                format<R>(arg0: java.time.format.DateTimeFormatter): string
                toInstant<R>(): java.time.Instant
                toEpochSecond<R>(): long
                compareTo<R>(arg0: java.time.chrono.ChronoZonedDateTime<any>): int
                isBefore<R>(arg0: java.time.chrono.ChronoZonedDateTime<any>): boolean
                isAfter<R>(arg0: java.time.chrono.ChronoZonedDateTime<any>): boolean
                isEqual<R>(arg0: java.time.chrono.ChronoZonedDateTime<any>): boolean
                equals<R>(arg0: java.lang.Object): boolean
                hashCode<R>(): int
                toString<R>(): string
                minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                compareTo<R>(arg0: java.lang.Object): int
            }
            class ChronoZonedDateTimeImpl<D extends java.time.chrono.ChronoLocalDate> implements java.time.chrono.ChronoZonedDateTime<D> , java.io.Serializable {
                public getOffset(): java.time.ZoneOffset
                public withEarlierOffsetAtOverlap(): java.time.chrono.ChronoZonedDateTime<D>
                public withLaterOffsetAtOverlap(): java.time.chrono.ChronoZonedDateTime<D>
                public toLocalDateTime(): java.time.chrono.ChronoLocalDateTime<D>
                public getZone(): java.time.ZoneId
                public withZoneSameLocal(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<D>
                public withZoneSameInstant(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<D>
                public isSupported(arg0: java.time.temporal.TemporalField): boolean
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoZonedDateTime<D>
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoZonedDateTime<D>
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            interface Chronology extends java.lang.Comparable<java.time.chrono.Chronology> {
                from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.Chronology
                ofLocale(arg0: java.util.Locale): java.time.chrono.Chronology
                of(arg0: java.lang.String | string): java.time.chrono.Chronology
                getAvailableChronologies(): java.util.Set<java.time.chrono.Chronology>
                getId(): string
                getCalendarType(): string
                date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ChronoLocalDate
                date(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                dateYearDay(arg0: int, arg1: int): java.time.chrono.ChronoLocalDate
                dateEpochDay(arg0: long): java.time.chrono.ChronoLocalDate
                dateNow(): java.time.chrono.ChronoLocalDate
                dateNow(arg0: java.time.ZoneId): java.time.chrono.ChronoLocalDate
                dateNow(arg0: java.time.Clock): java.time.chrono.ChronoLocalDate
                date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime<java.time.chrono.ChronoLocalDate>
                zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime<java.time.chrono.ChronoLocalDate>
                zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<java.time.chrono.ChronoLocalDate>
                isLeapYear(arg0: long): boolean
                prolepticYear(arg0: java.time.chrono.Era, arg1: int): int
                eraOf(arg0: int): java.time.chrono.Era
                eras(): java.util.List<java.time.chrono.Era>
                range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string
                resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                period(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoPeriod
                compareTo(arg0: java.time.chrono.Chronology): int
                equals(arg0: java.lang.Object): boolean
                hashCode(): int
                toString(): string
                compareTo(arg0: java.lang.Object): int
            }
            interface Era extends java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster {
                getValue(): int
                isSupported(arg0: java.time.temporal.TemporalField): boolean
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                get(arg0: java.time.temporal.TemporalField): int
                getLong(arg0: java.time.temporal.TemporalField): long
                query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
                adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                getDisplayName<R>(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string
            }
            class HijrahChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
                public static INSTANCE: java.time.chrono.HijrahChronology
                public getId(): string
                public getCalendarType(): string
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.HijrahDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.HijrahDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.HijrahDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.HijrahDate
                public dateEpochDay(arg0: long): java.time.chrono.HijrahDate
                public dateNow(): java.time.chrono.HijrahDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.HijrahDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.HijrahDate
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.HijrahDate
                public localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime<java.time.chrono.HijrahDate>
                public zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime<java.time.chrono.HijrahDate>
                public zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<java.time.chrono.HijrahDate>
                public isLeapYear(arg0: long): boolean
                public prolepticYear(arg0: java.time.chrono.Era, arg1: int): int
                public eraOf(arg0: int): java.time.chrono.HijrahEra
                public eras(): java.util.List<java.time.chrono.Era>
                public range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange
                public resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.chrono.HijrahDate
                public resolveDate(arg0: java.util.Map, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                public eraOf(arg0: int): java.time.chrono.Era
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.ChronoLocalDate
                public dateNow(): java.time.chrono.ChronoLocalDate
                public dateEpochDay(arg0: long): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ChronoLocalDate
                public static class: java.lang.Class<any>
            }
            class HijrahDate extends java.time.chrono.ChronoLocalDateImpl<java.time.chrono.HijrahDate> implements java.time.chrono.ChronoLocalDate , java.io.Serializable {
                public static now(): java.time.chrono.HijrahDate
                public static now(arg0: java.time.ZoneId): java.time.chrono.HijrahDate
                public static now(arg0: java.time.Clock): java.time.chrono.HijrahDate
                public static of(arg0: int, arg1: int, arg2: int): java.time.chrono.HijrahDate
                public static from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.HijrahDate
                public getChronology(): java.time.chrono.HijrahChronology
                public getEra(): java.time.chrono.HijrahEra
                public lengthOfMonth(): int
                public lengthOfYear(): int
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public getLong(arg0: java.time.temporal.TemporalField): long
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.HijrahDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.HijrahDate
                public withVariant(arg0: java.time.chrono.HijrahChronology): java.time.chrono.HijrahDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.HijrahDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.HijrahDate
                public toEpochDay(): long
                public isLeapYear(): boolean
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.HijrahDate
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.HijrahDate
                public atTime(arg0: java.time.LocalTime): java.time.chrono.ChronoLocalDateTime<java.time.chrono.HijrahDate>
                public until(arg0: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDate
                public getEra(): java.time.chrono.Era
                public getChronology(): java.time.chrono.Chronology
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            class HijrahEra extends java.lang.Enum<java.time.chrono.HijrahEra> implements java.time.chrono.Era {
                public static AH: java.time.chrono.HijrahEra
                public static values(): java.time.chrono.HijrahEra[]
                public static valueOf(arg0: java.lang.String | string): java.time.chrono.HijrahEra
                public static of(arg0: int): java.time.chrono.HijrahEra
                public getValue(): int
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public static class: java.lang.Class<any>
            }
            class IsoChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
                public static INSTANCE: java.time.chrono.IsoChronology
                public getId(): string
                public getCalendarType(): string
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.LocalDate
                public date(arg0: int, arg1: int, arg2: int): java.time.LocalDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.LocalDate
                public dateYearDay(arg0: int, arg1: int): java.time.LocalDate
                public dateEpochDay(arg0: long): java.time.LocalDate
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDate
                public localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDateTime
                public zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.ZonedDateTime
                public zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.ZonedDateTime
                public dateNow(): java.time.LocalDate
                public dateNow(arg0: java.time.ZoneId): java.time.LocalDate
                public dateNow(arg0: java.time.Clock): java.time.LocalDate
                public isLeapYear(arg0: long): boolean
                public prolepticYear(arg0: java.time.chrono.Era, arg1: int): int
                public eraOf(arg0: int): java.time.chrono.IsoEra
                public eras(): java.util.List<java.time.chrono.Era>
                public resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.LocalDate
                public range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange
                public period(arg0: int, arg1: int, arg2: int): java.time.Period
                public resolveDate(arg0: java.util.Map, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                public period(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoPeriod
                public eraOf(arg0: int): java.time.chrono.Era
                public zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime
                public zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime
                public localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.ChronoLocalDate
                public dateNow(): java.time.chrono.ChronoLocalDate
                public dateEpochDay(arg0: long): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ChronoLocalDate
                public static class: java.lang.Class<any>
            }
            class IsoEra extends java.lang.Enum<java.time.chrono.IsoEra> implements java.time.chrono.Era {
                public static BCE: java.time.chrono.IsoEra
                public static CE: java.time.chrono.IsoEra
                public static values(): java.time.chrono.IsoEra[]
                public static valueOf(arg0: java.lang.String | string): java.time.chrono.IsoEra
                public static of(arg0: int): java.time.chrono.IsoEra
                public getValue(): int
                public static class: java.lang.Class<any>
            }
            class JapaneseChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
                public static INSTANCE: java.time.chrono.JapaneseChronology
                public getId(): string
                public getCalendarType(): string
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.JapaneseDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.JapaneseDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.JapaneseDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.JapaneseDate
                public dateEpochDay(arg0: long): java.time.chrono.JapaneseDate
                public dateNow(): java.time.chrono.JapaneseDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.JapaneseDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.JapaneseDate
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.JapaneseDate
                public localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime<java.time.chrono.JapaneseDate>
                public zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime<java.time.chrono.JapaneseDate>
                public zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<java.time.chrono.JapaneseDate>
                public isLeapYear(arg0: long): boolean
                public prolepticYear(arg0: java.time.chrono.Era, arg1: int): int
                public eraOf(arg0: int): java.time.chrono.JapaneseEra
                public eras(): java.util.List<java.time.chrono.Era>
                public range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange
                public resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.chrono.JapaneseDate
                public resolveDate(arg0: java.util.Map, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                public eraOf(arg0: int): java.time.chrono.Era
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.ChronoLocalDate
                public dateNow(): java.time.chrono.ChronoLocalDate
                public dateEpochDay(arg0: long): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ChronoLocalDate
                public static class: java.lang.Class<any>
            }
            class JapaneseDate extends java.time.chrono.ChronoLocalDateImpl<java.time.chrono.JapaneseDate> implements java.time.chrono.ChronoLocalDate , java.io.Serializable {
                public static now(): java.time.chrono.JapaneseDate
                public static now(arg0: java.time.ZoneId): java.time.chrono.JapaneseDate
                public static now(arg0: java.time.Clock): java.time.chrono.JapaneseDate
                public static of(arg0: java.time.chrono.JapaneseEra, arg1: int, arg2: int, arg3: int): java.time.chrono.JapaneseDate
                public static of(arg0: int, arg1: int, arg2: int): java.time.chrono.JapaneseDate
                public static from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.JapaneseDate
                public getChronology(): java.time.chrono.JapaneseChronology
                public getEra(): java.time.chrono.JapaneseEra
                public lengthOfMonth(): int
                public lengthOfYear(): int
                public isSupported(arg0: java.time.temporal.TemporalField): boolean
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public getLong(arg0: java.time.temporal.TemporalField): long
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.JapaneseDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.JapaneseDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.JapaneseDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.JapaneseDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.JapaneseDate
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.JapaneseDate
                public atTime(arg0: java.time.LocalTime): java.time.chrono.ChronoLocalDateTime<java.time.chrono.JapaneseDate>
                public until(arg0: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
                public toEpochDay(): long
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDate
                public getEra(): java.time.chrono.Era
                public getChronology(): java.time.chrono.Chronology
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            class JapaneseEra implements java.time.chrono.Era , java.io.Serializable {
                public static MEIJI: java.time.chrono.JapaneseEra
                public static TAISHO: java.time.chrono.JapaneseEra
                public static SHOWA: java.time.chrono.JapaneseEra
                public static HEISEI: java.time.chrono.JapaneseEra
                public static of(arg0: int): java.time.chrono.JapaneseEra
                public static valueOf(arg0: java.lang.String | string): java.time.chrono.JapaneseEra
                public static values(): java.time.chrono.JapaneseEra[]
                public getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string
                public getValue(): int
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class MinguoChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
                public static INSTANCE: java.time.chrono.MinguoChronology
                public getId(): string
                public getCalendarType(): string
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.MinguoDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.MinguoDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.MinguoDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.MinguoDate
                public dateEpochDay(arg0: long): java.time.chrono.MinguoDate
                public dateNow(): java.time.chrono.MinguoDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.MinguoDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.MinguoDate
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.MinguoDate
                public localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime<java.time.chrono.MinguoDate>
                public zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime<java.time.chrono.MinguoDate>
                public zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<java.time.chrono.MinguoDate>
                public isLeapYear(arg0: long): boolean
                public prolepticYear(arg0: java.time.chrono.Era, arg1: int): int
                public eraOf(arg0: int): java.time.chrono.MinguoEra
                public eras(): java.util.List<java.time.chrono.Era>
                public range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange
                public resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.chrono.MinguoDate
                public resolveDate(arg0: java.util.Map, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                public eraOf(arg0: int): java.time.chrono.Era
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.ChronoLocalDate
                public dateNow(): java.time.chrono.ChronoLocalDate
                public dateEpochDay(arg0: long): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ChronoLocalDate
                public static class: java.lang.Class<any>
            }
            class MinguoDate extends java.time.chrono.ChronoLocalDateImpl<java.time.chrono.MinguoDate> implements java.time.chrono.ChronoLocalDate , java.io.Serializable {
                public static now(): java.time.chrono.MinguoDate
                public static now(arg0: java.time.ZoneId): java.time.chrono.MinguoDate
                public static now(arg0: java.time.Clock): java.time.chrono.MinguoDate
                public static of(arg0: int, arg1: int, arg2: int): java.time.chrono.MinguoDate
                public static from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.MinguoDate
                public getChronology(): java.time.chrono.MinguoChronology
                public getEra(): java.time.chrono.MinguoEra
                public lengthOfMonth(): int
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public getLong(arg0: java.time.temporal.TemporalField): long
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.MinguoDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.MinguoDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.MinguoDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.MinguoDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.MinguoDate
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.MinguoDate
                public atTime(arg0: java.time.LocalTime): java.time.chrono.ChronoLocalDateTime<java.time.chrono.MinguoDate>
                public until(arg0: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
                public toEpochDay(): long
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDate
                public getEra(): java.time.chrono.Era
                public getChronology(): java.time.chrono.Chronology
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            class MinguoEra extends java.lang.Enum<java.time.chrono.MinguoEra> implements java.time.chrono.Era {
                public static BEFORE_ROC: java.time.chrono.MinguoEra
                public static ROC: java.time.chrono.MinguoEra
                public static values(): java.time.chrono.MinguoEra[]
                public static valueOf(arg0: java.lang.String | string): java.time.chrono.MinguoEra
                public static of(arg0: int): java.time.chrono.MinguoEra
                public getValue(): int
                public static class: java.lang.Class<any>
            }
            class Ser implements java.io.Externalizable {
                public constructor()
                public writeExternal(arg0: java.io.ObjectOutput): void
                public readExternal(arg0: java.io.ObjectInput): void
                public static class: java.lang.Class<any>
            }
            class ThaiBuddhistChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
                public static INSTANCE: java.time.chrono.ThaiBuddhistChronology
                public getId(): string
                public getCalendarType(): string
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ThaiBuddhistDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.ThaiBuddhistDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ThaiBuddhistDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.ThaiBuddhistDate
                public dateEpochDay(arg0: long): java.time.chrono.ThaiBuddhistDate
                public dateNow(): java.time.chrono.ThaiBuddhistDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.ThaiBuddhistDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.ThaiBuddhistDate
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ThaiBuddhistDate
                public localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDateTime<java.time.chrono.ThaiBuddhistDate>
                public zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoZonedDateTime<java.time.chrono.ThaiBuddhistDate>
                public zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime<java.time.chrono.ThaiBuddhistDate>
                public isLeapYear(arg0: long): boolean
                public prolepticYear(arg0: java.time.chrono.Era, arg1: int): int
                public eraOf(arg0: int): java.time.chrono.ThaiBuddhistEra
                public eras(): java.util.List<java.time.chrono.Era>
                public range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange
                public resolveDate(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.format.ResolverStyle): java.time.chrono.ThaiBuddhistDate
                public resolveDate(arg0: java.util.Map, arg1: java.time.format.ResolverStyle): java.time.chrono.ChronoLocalDate
                public eraOf(arg0: int): java.time.chrono.Era
                public date(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.Clock): java.time.chrono.ChronoLocalDate
                public dateNow(arg0: java.time.ZoneId): java.time.chrono.ChronoLocalDate
                public dateNow(): java.time.chrono.ChronoLocalDate
                public dateEpochDay(arg0: long): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: int, arg1: int): java.time.chrono.ChronoLocalDate
                public dateYearDay(arg0: java.time.chrono.Era, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: int, arg1: int, arg2: int): java.time.chrono.ChronoLocalDate
                public date(arg0: java.time.chrono.Era, arg1: int, arg2: int, arg3: int): java.time.chrono.ChronoLocalDate
                public static class: java.lang.Class<any>
            }
            class ThaiBuddhistDate extends java.time.chrono.ChronoLocalDateImpl<java.time.chrono.ThaiBuddhistDate> implements java.time.chrono.ChronoLocalDate , java.io.Serializable {
                public static now(): java.time.chrono.ThaiBuddhistDate
                public static now(arg0: java.time.ZoneId): java.time.chrono.ThaiBuddhistDate
                public static now(arg0: java.time.Clock): java.time.chrono.ThaiBuddhistDate
                public static of(arg0: int, arg1: int, arg2: int): java.time.chrono.ThaiBuddhistDate
                public static from(arg0: java.time.temporal.TemporalAccessor): java.time.chrono.ThaiBuddhistDate
                public getChronology(): java.time.chrono.ThaiBuddhistChronology
                public getEra(): java.time.chrono.ThaiBuddhistEra
                public lengthOfMonth(): int
                public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                public getLong(arg0: java.time.temporal.TemporalField): long
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ThaiBuddhistDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ThaiBuddhistDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ThaiBuddhistDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ThaiBuddhistDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ThaiBuddhistDate
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ThaiBuddhistDate
                public atTime(arg0: java.time.LocalTime): java.time.chrono.ChronoLocalDateTime<java.time.chrono.ThaiBuddhistDate>
                public until(arg0: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
                public toEpochDay(): long
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDate
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDate
                public getEra(): java.time.chrono.Era
                public getChronology(): java.time.chrono.Chronology
                public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public minus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                public plus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                public static class: java.lang.Class<any>
            }
            class ThaiBuddhistEra extends java.lang.Enum<java.time.chrono.ThaiBuddhistEra> implements java.time.chrono.Era {
                public static BEFORE_BE: java.time.chrono.ThaiBuddhistEra
                public static BE: java.time.chrono.ThaiBuddhistEra
                public static values(): java.time.chrono.ThaiBuddhistEra[]
                public static valueOf(arg0: java.lang.String | string): java.time.chrono.ThaiBuddhistEra
                public static of(arg0: int): java.time.chrono.ThaiBuddhistEra
                public getValue(): int
                public static class: java.lang.Class<any>
            }
        }
        namespace format {
            class DateTimeFormatter {
                public static ISO_LOCAL_DATE: java.time.format.DateTimeFormatter
                public static ISO_OFFSET_DATE: java.time.format.DateTimeFormatter
                public static ISO_DATE: java.time.format.DateTimeFormatter
                public static ISO_LOCAL_TIME: java.time.format.DateTimeFormatter
                public static ISO_OFFSET_TIME: java.time.format.DateTimeFormatter
                public static ISO_TIME: java.time.format.DateTimeFormatter
                public static ISO_LOCAL_DATE_TIME: java.time.format.DateTimeFormatter
                public static ISO_OFFSET_DATE_TIME: java.time.format.DateTimeFormatter
                public static ISO_ZONED_DATE_TIME: java.time.format.DateTimeFormatter
                public static ISO_DATE_TIME: java.time.format.DateTimeFormatter
                public static ISO_ORDINAL_DATE: java.time.format.DateTimeFormatter
                public static ISO_WEEK_DATE: java.time.format.DateTimeFormatter
                public static ISO_INSTANT: java.time.format.DateTimeFormatter
                public static BASIC_ISO_DATE: java.time.format.DateTimeFormatter
                public static RFC_1123_DATE_TIME: java.time.format.DateTimeFormatter
                public static ofPattern(arg0: java.lang.String | string): java.time.format.DateTimeFormatter
                public static ofPattern(arg0: java.lang.String | string, arg1: java.util.Locale): java.time.format.DateTimeFormatter
                public static ofLocalizedDate(arg0: java.time.format.FormatStyle): java.time.format.DateTimeFormatter
                public static ofLocalizedTime(arg0: java.time.format.FormatStyle): java.time.format.DateTimeFormatter
                public static ofLocalizedDateTime(arg0: java.time.format.FormatStyle): java.time.format.DateTimeFormatter
                public static ofLocalizedDateTime(arg0: java.time.format.FormatStyle, arg1: java.time.format.FormatStyle): java.time.format.DateTimeFormatter
                public static parsedExcessDays(): java.time.temporal.TemporalQuery<java.time.Period>
                public static parsedLeapSecond(): java.time.temporal.TemporalQuery<java.lang.Boolean>
                public getLocale(): java.util.Locale
                public withLocale(arg0: java.util.Locale): java.time.format.DateTimeFormatter
                public getDecimalStyle(): java.time.format.DecimalStyle
                public withDecimalStyle(arg0: java.time.format.DecimalStyle): java.time.format.DateTimeFormatter
                public getChronology(): java.time.chrono.Chronology
                public withChronology(arg0: java.time.chrono.Chronology): java.time.format.DateTimeFormatter
                public getZone(): java.time.ZoneId
                public withZone(arg0: java.time.ZoneId): java.time.format.DateTimeFormatter
                public getResolverStyle(): java.time.format.ResolverStyle
                public withResolverStyle(arg0: java.time.format.ResolverStyle): java.time.format.DateTimeFormatter
                public getResolverFields(): java.util.Set<java.time.temporal.TemporalField>
                public withResolverFields(...arg0: java.time.temporal.TemporalField[]): java.time.format.DateTimeFormatter
                public withResolverFields(arg0: java.util.Set<java.time.temporal.TemporalField>): java.time.format.DateTimeFormatter
                public format(arg0: java.time.temporal.TemporalAccessor): string
                public formatTo(arg0: java.time.temporal.TemporalAccessor, arg1: java.lang.Appendable): void
                public parse(arg0: java.lang.CharSequence): java.time.temporal.TemporalAccessor
                public parse(arg0: java.lang.CharSequence, arg1: java.text.ParsePosition): java.time.temporal.TemporalAccessor
                public parse<T>(arg0: java.lang.CharSequence, arg1: java.time.temporal.TemporalQuery<T> | java.time.temporal.TemporalQuery$$Lambda<T>): T
                public parseBest<T>(arg0: java.lang.CharSequence, ...arg1: java.time.temporal.TemporalQuery<any>[]): java.time.temporal.TemporalAccessor
                public parseUnresolved<T>(arg0: java.lang.CharSequence, arg1: java.text.ParsePosition): java.time.temporal.TemporalAccessor
                public toFormat<T>(): java.text.Format
                public toFormat<T>(arg0: java.time.temporal.TemporalQuery<any> | java.time.temporal.TemporalQuery$$Lambda<any>): java.text.Format
                public toString<T>(): string
                public static class: java.lang.Class<any>
            }
            class DateTimeFormatterBuilder {
                public static getLocalizedDateTimePattern(arg0: java.time.format.FormatStyle, arg1: java.time.format.FormatStyle, arg2: java.time.chrono.Chronology, arg3: java.util.Locale): string
                public constructor()
                public parseCaseSensitive(): java.time.format.DateTimeFormatterBuilder
                public parseCaseInsensitive(): java.time.format.DateTimeFormatterBuilder
                public parseStrict(): java.time.format.DateTimeFormatterBuilder
                public parseLenient(): java.time.format.DateTimeFormatterBuilder
                public parseDefaulting(arg0: java.time.temporal.TemporalField, arg1: long): java.time.format.DateTimeFormatterBuilder
                public appendValue(arg0: java.time.temporal.TemporalField): java.time.format.DateTimeFormatterBuilder
                public appendValue(arg0: java.time.temporal.TemporalField, arg1: int): java.time.format.DateTimeFormatterBuilder
                public appendValue(arg0: java.time.temporal.TemporalField, arg1: int, arg2: int, arg3: java.time.format.SignStyle): java.time.format.DateTimeFormatterBuilder
                public appendValueReduced(arg0: java.time.temporal.TemporalField, arg1: int, arg2: int, arg3: int): java.time.format.DateTimeFormatterBuilder
                public appendValueReduced(arg0: java.time.temporal.TemporalField, arg1: int, arg2: int, arg3: java.time.chrono.ChronoLocalDate): java.time.format.DateTimeFormatterBuilder
                public appendFraction(arg0: java.time.temporal.TemporalField, arg1: int, arg2: int, arg3: boolean): java.time.format.DateTimeFormatterBuilder
                public appendText(arg0: java.time.temporal.TemporalField): java.time.format.DateTimeFormatterBuilder
                public appendText(arg0: java.time.temporal.TemporalField, arg1: java.time.format.TextStyle): java.time.format.DateTimeFormatterBuilder
                public appendText(arg0: java.time.temporal.TemporalField, arg1: java.util.Map<java.lang.Long, java.lang.String>): java.time.format.DateTimeFormatterBuilder
                public appendInstant(): java.time.format.DateTimeFormatterBuilder
                public appendInstant(arg0: int): java.time.format.DateTimeFormatterBuilder
                public appendOffsetId(): java.time.format.DateTimeFormatterBuilder
                public appendOffset(arg0: java.lang.String | string, arg1: java.lang.String | string): java.time.format.DateTimeFormatterBuilder
                public appendLocalizedOffset(arg0: java.time.format.TextStyle): java.time.format.DateTimeFormatterBuilder
                public appendZoneId(): java.time.format.DateTimeFormatterBuilder
                public appendZoneRegionId(): java.time.format.DateTimeFormatterBuilder
                public appendZoneOrOffsetId(): java.time.format.DateTimeFormatterBuilder
                public appendZoneText(arg0: java.time.format.TextStyle): java.time.format.DateTimeFormatterBuilder
                public appendZoneText(arg0: java.time.format.TextStyle, arg1: java.util.Set<java.time.ZoneId>): java.time.format.DateTimeFormatterBuilder
                public appendChronologyId(): java.time.format.DateTimeFormatterBuilder
                public appendChronologyText(arg0: java.time.format.TextStyle): java.time.format.DateTimeFormatterBuilder
                public appendLocalized(arg0: java.time.format.FormatStyle, arg1: java.time.format.FormatStyle): java.time.format.DateTimeFormatterBuilder
                public appendLiteral(arg0: char): java.time.format.DateTimeFormatterBuilder
                public appendLiteral(arg0: java.lang.String | string): java.time.format.DateTimeFormatterBuilder
                public append(arg0: java.time.format.DateTimeFormatter): java.time.format.DateTimeFormatterBuilder
                public appendOptional(arg0: java.time.format.DateTimeFormatter): java.time.format.DateTimeFormatterBuilder
                public appendPattern(arg0: java.lang.String | string): java.time.format.DateTimeFormatterBuilder
                public padNext(arg0: int): java.time.format.DateTimeFormatterBuilder
                public padNext(arg0: int, arg1: char): java.time.format.DateTimeFormatterBuilder
                public optionalStart(): java.time.format.DateTimeFormatterBuilder
                public optionalEnd(): java.time.format.DateTimeFormatterBuilder
                public toFormatter(): java.time.format.DateTimeFormatter
                public toFormatter(arg0: java.util.Locale): java.time.format.DateTimeFormatter
                public static class: java.lang.Class<any>
            }
            class DateTimeParseContext {
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class DateTimeParseException extends java.time.DateTimeException {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.CharSequence, arg2: int)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.CharSequence, arg2: int, arg3: java.lang.Throwable)
                public getParsedString(): string
                public getErrorIndex(): int
                public static class: java.lang.Class<any>
            }
            class DateTimePrintContext {
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class DateTimeTextProvider {
                public getText(arg0: java.time.temporal.TemporalField, arg1: long, arg2: java.time.format.TextStyle, arg3: java.util.Locale): string
                public getText(arg0: java.time.chrono.Chronology, arg1: java.time.temporal.TemporalField, arg2: long, arg3: java.time.format.TextStyle, arg4: java.util.Locale): string
                public getTextIterator(arg0: java.time.temporal.TemporalField, arg1: java.time.format.TextStyle, arg2: java.util.Locale): java.util.Iterator<java.util.Map$Entry<java.lang.String, java.lang.Long>>
                public getTextIterator(arg0: java.time.chrono.Chronology, arg1: java.time.temporal.TemporalField, arg2: java.time.format.TextStyle, arg3: java.util.Locale): java.util.Iterator<java.util.Map$Entry<java.lang.String, java.lang.Long>>
                public static class: java.lang.Class<any>
            }
            class DecimalStyle {
                public static STANDARD: java.time.format.DecimalStyle
                public static getAvailableLocales(): java.util.Set<java.util.Locale>
                public static ofDefaultLocale(): java.time.format.DecimalStyle
                public static of(arg0: java.util.Locale): java.time.format.DecimalStyle
                public getZeroDigit(): char
                public withZeroDigit(arg0: char): java.time.format.DecimalStyle
                public getPositiveSign(): char
                public withPositiveSign(arg0: char): java.time.format.DecimalStyle
                public getNegativeSign(): char
                public withNegativeSign(arg0: char): java.time.format.DecimalStyle
                public getDecimalSeparator(): char
                public withDecimalSeparator(arg0: char): java.time.format.DecimalStyle
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class FormatStyle extends java.lang.Enum<java.time.format.FormatStyle> {
                public static FULL: java.time.format.FormatStyle
                public static LONG: java.time.format.FormatStyle
                public static MEDIUM: java.time.format.FormatStyle
                public static SHORT: java.time.format.FormatStyle
                public static values(): java.time.format.FormatStyle[]
                public static valueOf(arg0: java.lang.String | string): java.time.format.FormatStyle
                public static class: java.lang.Class<any>
            }
            class Parsed implements java.time.temporal.TemporalAccessor {
                public isSupported(arg0: java.time.temporal.TemporalField): boolean
                public getLong(arg0: java.time.temporal.TemporalField): long
                public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
                public toString<R>(): string
                public static class: java.lang.Class<any>
            }
            class ResolverStyle extends java.lang.Enum<java.time.format.ResolverStyle> {
                public static STRICT: java.time.format.ResolverStyle
                public static SMART: java.time.format.ResolverStyle
                public static LENIENT: java.time.format.ResolverStyle
                public static values(): java.time.format.ResolverStyle[]
                public static valueOf(arg0: java.lang.String | string): java.time.format.ResolverStyle
                public static class: java.lang.Class<any>
            }
            class SignStyle extends java.lang.Enum<java.time.format.SignStyle> {
                public static NORMAL: java.time.format.SignStyle
                public static ALWAYS: java.time.format.SignStyle
                public static NEVER: java.time.format.SignStyle
                public static NOT_NEGATIVE: java.time.format.SignStyle
                public static EXCEEDS_PAD: java.time.format.SignStyle
                public static values(): java.time.format.SignStyle[]
                public static valueOf(arg0: java.lang.String | string): java.time.format.SignStyle
                public static class: java.lang.Class<any>
            }
            class TextStyle extends java.lang.Enum<java.time.format.TextStyle> {
                public static FULL: java.time.format.TextStyle
                public static FULL_STANDALONE: java.time.format.TextStyle
                public static SHORT: java.time.format.TextStyle
                public static SHORT_STANDALONE: java.time.format.TextStyle
                public static NARROW: java.time.format.TextStyle
                public static NARROW_STANDALONE: java.time.format.TextStyle
                public static values(): java.time.format.TextStyle[]
                public static valueOf(arg0: java.lang.String | string): java.time.format.TextStyle
                public isStandalone(): boolean
                public asStandalone(): java.time.format.TextStyle
                public asNormal(): java.time.format.TextStyle
                public static class: java.lang.Class<any>
            }
        }
        namespace temporal {
            class ChronoField extends java.lang.Enum<java.time.temporal.ChronoField> implements java.time.temporal.TemporalField {
                public static NANO_OF_SECOND: java.time.temporal.ChronoField
                public static NANO_OF_DAY: java.time.temporal.ChronoField
                public static MICRO_OF_SECOND: java.time.temporal.ChronoField
                public static MICRO_OF_DAY: java.time.temporal.ChronoField
                public static MILLI_OF_SECOND: java.time.temporal.ChronoField
                public static MILLI_OF_DAY: java.time.temporal.ChronoField
                public static SECOND_OF_MINUTE: java.time.temporal.ChronoField
                public static SECOND_OF_DAY: java.time.temporal.ChronoField
                public static MINUTE_OF_HOUR: java.time.temporal.ChronoField
                public static MINUTE_OF_DAY: java.time.temporal.ChronoField
                public static HOUR_OF_AMPM: java.time.temporal.ChronoField
                public static CLOCK_HOUR_OF_AMPM: java.time.temporal.ChronoField
                public static HOUR_OF_DAY: java.time.temporal.ChronoField
                public static CLOCK_HOUR_OF_DAY: java.time.temporal.ChronoField
                public static AMPM_OF_DAY: java.time.temporal.ChronoField
                public static DAY_OF_WEEK: java.time.temporal.ChronoField
                public static ALIGNED_DAY_OF_WEEK_IN_MONTH: java.time.temporal.ChronoField
                public static ALIGNED_DAY_OF_WEEK_IN_YEAR: java.time.temporal.ChronoField
                public static DAY_OF_MONTH: java.time.temporal.ChronoField
                public static DAY_OF_YEAR: java.time.temporal.ChronoField
                public static EPOCH_DAY: java.time.temporal.ChronoField
                public static ALIGNED_WEEK_OF_MONTH: java.time.temporal.ChronoField
                public static ALIGNED_WEEK_OF_YEAR: java.time.temporal.ChronoField
                public static MONTH_OF_YEAR: java.time.temporal.ChronoField
                public static PROLEPTIC_MONTH: java.time.temporal.ChronoField
                public static YEAR_OF_ERA: java.time.temporal.ChronoField
                public static YEAR: java.time.temporal.ChronoField
                public static ERA: java.time.temporal.ChronoField
                public static INSTANT_SECONDS: java.time.temporal.ChronoField
                public static OFFSET_SECONDS: java.time.temporal.ChronoField
                public static values(): java.time.temporal.ChronoField[]
                public static valueOf(arg0: java.lang.String | string): java.time.temporal.ChronoField
                public getDisplayName(arg0: java.util.Locale): string
                public getBaseUnit(): java.time.temporal.TemporalUnit
                public getRangeUnit(): java.time.temporal.TemporalUnit
                public range(): java.time.temporal.ValueRange
                public isDateBased(): boolean
                public isTimeBased(): boolean
                public checkValidValue(arg0: long): long
                public checkValidIntValue(arg0: long): int
                public isSupportedBy(arg0: java.time.temporal.TemporalAccessor): boolean
                public rangeRefinedBy(arg0: java.time.temporal.TemporalAccessor): java.time.temporal.ValueRange
                public getFrom(arg0: java.time.temporal.TemporalAccessor): long
                public adjustInto<R extends java.time.temporal.Temporal>(arg0: R, arg1: long): R
                public toString<R extends java.time.temporal.Temporal>(): string
                public static class: java.lang.Class<any>
            }
            class ChronoUnit extends java.lang.Enum<java.time.temporal.ChronoUnit> implements java.time.temporal.TemporalUnit {
                public static NANOS: java.time.temporal.ChronoUnit
                public static MICROS: java.time.temporal.ChronoUnit
                public static MILLIS: java.time.temporal.ChronoUnit
                public static SECONDS: java.time.temporal.ChronoUnit
                public static MINUTES: java.time.temporal.ChronoUnit
                public static HOURS: java.time.temporal.ChronoUnit
                public static HALF_DAYS: java.time.temporal.ChronoUnit
                public static DAYS: java.time.temporal.ChronoUnit
                public static WEEKS: java.time.temporal.ChronoUnit
                public static MONTHS: java.time.temporal.ChronoUnit
                public static YEARS: java.time.temporal.ChronoUnit
                public static DECADES: java.time.temporal.ChronoUnit
                public static CENTURIES: java.time.temporal.ChronoUnit
                public static MILLENNIA: java.time.temporal.ChronoUnit
                public static ERAS: java.time.temporal.ChronoUnit
                public static FOREVER: java.time.temporal.ChronoUnit
                public static values(): java.time.temporal.ChronoUnit[]
                public static valueOf(arg0: java.lang.String | string): java.time.temporal.ChronoUnit
                public getDuration(): java.time.Duration
                public isDurationEstimated(): boolean
                public isDateBased(): boolean
                public isTimeBased(): boolean
                public isSupportedBy(arg0: java.time.temporal.Temporal): boolean
                public addTo<R extends java.time.temporal.Temporal>(arg0: R, arg1: long): R
                public between<R extends java.time.temporal.Temporal>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.Temporal): long
                public toString<R extends java.time.temporal.Temporal>(): string
                public static class: java.lang.Class<any>
            }
            class IsoFields {
                public static DAY_OF_QUARTER: java.time.temporal.TemporalField
                public static QUARTER_OF_YEAR: java.time.temporal.TemporalField
                public static WEEK_OF_WEEK_BASED_YEAR: java.time.temporal.TemporalField
                public static WEEK_BASED_YEAR: java.time.temporal.TemporalField
                public static WEEK_BASED_YEARS: java.time.temporal.TemporalUnit
                public static QUARTER_YEARS: java.time.temporal.TemporalUnit
                public static class: java.lang.Class<any>
            }
            class JulianFields {
                public static JULIAN_DAY: java.time.temporal.TemporalField
                public static MODIFIED_JULIAN_DAY: java.time.temporal.TemporalField
                public static RATA_DIE: java.time.temporal.TemporalField
                public static class: java.lang.Class<any>
            }
            interface Temporal extends java.time.temporal.TemporalAccessor {
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean
                with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
                with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
                plus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                minus(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            }
            interface TemporalAccessor {
                isSupported(arg0: java.time.temporal.TemporalField): boolean
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
                get(arg0: java.time.temporal.TemporalField): int
                getLong(arg0: java.time.temporal.TemporalField): long
                query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            }
            interface TemporalAdjuster {
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            }
            interface TemporalAdjuster$$Lambda {
                (arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            }
            class TemporalAdjusters {
                public static ofDateAdjuster(arg0: java.util.function$.UnaryOperator<java.time.LocalDate>): java.time.temporal.TemporalAdjuster
                public static firstDayOfMonth(): java.time.temporal.TemporalAdjuster
                public static lastDayOfMonth(): java.time.temporal.TemporalAdjuster
                public static firstDayOfNextMonth(): java.time.temporal.TemporalAdjuster
                public static firstDayOfYear(): java.time.temporal.TemporalAdjuster
                public static lastDayOfYear(): java.time.temporal.TemporalAdjuster
                public static firstDayOfNextYear(): java.time.temporal.TemporalAdjuster
                public static firstInMonth(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static lastInMonth(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static dayOfWeekInMonth(arg0: int, arg1: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static next(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static nextOrSame(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static previous(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static previousOrSame(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda): java.time.temporal.TemporalAdjuster
                public static class: java.lang.Class<any>
            }
            interface TemporalAmount {
                get(arg0: java.time.temporal.TemporalUnit): long
                getUnits(): java.util.List<java.time.temporal.TemporalUnit>
                addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
                subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            }
            interface TemporalField {
                getDisplayName(arg0: java.util.Locale): string
                getBaseUnit(): java.time.temporal.TemporalUnit
                getRangeUnit(): java.time.temporal.TemporalUnit
                range(): java.time.temporal.ValueRange
                isDateBased(): boolean
                isTimeBased(): boolean
                isSupportedBy(arg0: java.time.temporal.TemporalAccessor): boolean
                rangeRefinedBy(arg0: java.time.temporal.TemporalAccessor): java.time.temporal.ValueRange
                getFrom(arg0: java.time.temporal.TemporalAccessor): long
                adjustInto<R extends java.time.temporal.Temporal>(arg0: R, arg1: long): R
                resolve(arg0: java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, arg1: java.time.temporal.TemporalAccessor, arg2: java.time.format.ResolverStyle): java.time.temporal.TemporalAccessor
                toString(): string
            }
            class TemporalQueries {
                public static zoneId(): java.time.temporal.TemporalQuery<java.time.ZoneId>
                public static chronology(): java.time.temporal.TemporalQuery<java.time.chrono.Chronology>
                public static precision(): java.time.temporal.TemporalQuery<java.time.temporal.TemporalUnit>
                public static zone(): java.time.temporal.TemporalQuery<java.time.ZoneId>
                public static offset(): java.time.temporal.TemporalQuery<java.time.ZoneOffset>
                public static localDate(): java.time.temporal.TemporalQuery<java.time.LocalDate>
                public static localTime(): java.time.temporal.TemporalQuery<java.time.LocalTime>
                public static class: java.lang.Class<any>
            }
            interface TemporalQuery<R> {
                queryFrom(arg0: java.time.temporal.TemporalAccessor): R
            }
            interface TemporalQuery$$Lambda<R> {
                (arg0: java.time.temporal.TemporalAccessor): R
            }
            interface TemporalUnit {
                getDuration(): java.time.Duration
                isDurationEstimated(): boolean
                isDateBased(): boolean
                isTimeBased(): boolean
                isSupportedBy(arg0: java.time.temporal.Temporal): boolean
                addTo<R extends java.time.temporal.Temporal>(arg0: R, arg1: long): R
                between(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.Temporal): long
                toString(): string
            }
            class UnsupportedTemporalTypeException extends java.time.DateTimeException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class ValueRange implements java.io.Serializable {
                public static of(arg0: long, arg1: long): java.time.temporal.ValueRange
                public static of(arg0: long, arg1: long, arg2: long): java.time.temporal.ValueRange
                public static of(arg0: long, arg1: long, arg2: long, arg3: long): java.time.temporal.ValueRange
                public isFixed(): boolean
                public getMinimum(): long
                public getLargestMinimum(): long
                public getSmallestMaximum(): long
                public getMaximum(): long
                public isIntValue(): boolean
                public isValidValue(arg0: long): boolean
                public isValidIntValue(arg0: long): boolean
                public checkValidValue(arg0: long, arg1: java.time.temporal.TemporalField): long
                public checkValidIntValue(arg0: long, arg1: java.time.temporal.TemporalField): int
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class WeekFields implements java.io.Serializable {
                public static ISO: java.time.temporal.WeekFields
                public static SUNDAY_START: java.time.temporal.WeekFields
                public static WEEK_BASED_YEARS: java.time.temporal.TemporalUnit
                public static of(arg0: java.util.Locale): java.time.temporal.WeekFields
                public static of(arg0: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda, arg1: int): java.time.temporal.WeekFields
                public getFirstDayOfWeek(): java.time.DayOfWeek
                public getMinimalDaysInFirstWeek(): int
                public dayOfWeek(): java.time.temporal.TemporalField
                public weekOfMonth(): java.time.temporal.TemporalField
                public weekOfYear(): java.time.temporal.TemporalField
                public weekOfWeekBasedYear(): java.time.temporal.TemporalField
                public weekBasedYear(): java.time.temporal.TemporalField
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
        }
        namespace zone {
            class Ser implements java.io.Externalizable {
                public constructor()
                public writeExternal(arg0: java.io.ObjectOutput): void
                public readExternal(arg0: java.io.ObjectInput): void
                public static class: java.lang.Class<any>
            }
            class TzdbZoneRulesProvider extends java.time.zone.ZoneRulesProvider {
                public constructor()
                protected provideZoneIds(): java.util.Set<java.lang.String>
                protected provideRules(arg0: java.lang.String | string, arg1: boolean): java.time.zone.ZoneRules
                protected provideVersions(arg0: java.lang.String | string): java.util.NavigableMap<java.lang.String, java.time.zone.ZoneRules>
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class ZoneOffsetTransition implements java.lang.Comparable<java.time.zone.ZoneOffsetTransition> , java.io.Serializable {
                public static of(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneOffset): java.time.zone.ZoneOffsetTransition
                public getInstant(): java.time.Instant
                public toEpochSecond(): long
                public getDateTimeBefore(): java.time.LocalDateTime
                public getDateTimeAfter(): java.time.LocalDateTime
                public getOffsetBefore(): java.time.ZoneOffset
                public getOffsetAfter(): java.time.ZoneOffset
                public getDuration(): java.time.Duration
                public isGap(): boolean
                public isOverlap(): boolean
                public isValidOffset(arg0: java.time.ZoneOffset): boolean
                public compareTo(arg0: java.time.zone.ZoneOffsetTransition): int
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public compareTo(arg0: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            class ZoneOffsetTransitionRule implements java.io.Serializable {
                public static of(arg0: java.time.Month | java.time.Month$$Lambda, arg1: int, arg2: java.time.DayOfWeek | java.time.DayOfWeek$$Lambda, arg3: java.time.LocalTime, arg4: boolean, arg5: java.time.zone.ZoneOffsetTransitionRule$TimeDefinition, arg6: java.time.ZoneOffset, arg7: java.time.ZoneOffset, arg8: java.time.ZoneOffset): java.time.zone.ZoneOffsetTransitionRule
                public getMonth(): java.time.Month
                public getDayOfMonthIndicator(): int
                public getDayOfWeek(): java.time.DayOfWeek
                public getLocalTime(): java.time.LocalTime
                public isMidnightEndOfDay(): boolean
                public getTimeDefinition(): java.time.zone.ZoneOffsetTransitionRule$TimeDefinition
                public getStandardOffset(): java.time.ZoneOffset
                public getOffsetBefore(): java.time.ZoneOffset
                public getOffsetAfter(): java.time.ZoneOffset
                public createTransition(arg0: int): java.time.zone.ZoneOffsetTransition
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class ZoneRules implements java.io.Serializable {
                public static of(arg0: java.time.ZoneOffset, arg1: java.time.ZoneOffset, arg2: java.util.List<java.time.zone.ZoneOffsetTransition>, arg3: java.util.List<java.time.zone.ZoneOffsetTransition>, arg4: java.util.List<java.time.zone.ZoneOffsetTransitionRule>): java.time.zone.ZoneRules
                public static of(arg0: java.time.ZoneOffset): java.time.zone.ZoneRules
                public isFixedOffset(): boolean
                public getOffset(arg0: java.time.Instant): java.time.ZoneOffset
                public getOffset(arg0: java.time.LocalDateTime): java.time.ZoneOffset
                public getValidOffsets(arg0: java.time.LocalDateTime): java.util.List<java.time.ZoneOffset>
                public getTransition(arg0: java.time.LocalDateTime): java.time.zone.ZoneOffsetTransition
                public getStandardOffset(arg0: java.time.Instant): java.time.ZoneOffset
                public getDaylightSavings(arg0: java.time.Instant): java.time.Duration
                public isDaylightSavings(arg0: java.time.Instant): boolean
                public isValidOffset(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset): boolean
                public nextTransition(arg0: java.time.Instant): java.time.zone.ZoneOffsetTransition
                public previousTransition(arg0: java.time.Instant): java.time.zone.ZoneOffsetTransition
                public getTransitions(): java.util.List<java.time.zone.ZoneOffsetTransition>
                public getTransitionRules(): java.util.List<java.time.zone.ZoneOffsetTransitionRule>
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class ZoneRulesException extends java.time.DateTimeException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            abstract class ZoneRulesProvider {
                public static getAvailableZoneIds(): java.util.Set<java.lang.String>
                public static getRules(arg0: java.lang.String | string, arg1: boolean): java.time.zone.ZoneRules
                public static getVersions(arg0: java.lang.String | string): java.util.NavigableMap<java.lang.String, java.time.zone.ZoneRules>
                public static registerProvider(arg0: java.time.zone.ZoneRulesProvider): void
                public static refresh(): boolean
                protected constructor()
                protected provideZoneIds(): java.util.Set<java.lang.String>
                protected provideRules(arg0: java.lang.String | string, arg1: boolean): java.time.zone.ZoneRules
                protected provideVersions(arg0: java.lang.String | string): java.util.NavigableMap<java.lang.String, java.time.zone.ZoneRules>
                protected provideRefresh(): boolean
                public static class: java.lang.Class<any>
            }
        }
        abstract class Clock {
            public static systemUTC(): java.time.Clock
            public static systemDefaultZone(): java.time.Clock
            public static system(arg0: java.time.ZoneId): java.time.Clock
            public static tickSeconds(arg0: java.time.ZoneId): java.time.Clock
            public static tickMinutes(arg0: java.time.ZoneId): java.time.Clock
            public static tick(arg0: java.time.Clock, arg1: java.time.Duration): java.time.Clock
            public static fixed(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.Clock
            public static offset(arg0: java.time.Clock, arg1: java.time.Duration): java.time.Clock
            protected constructor()
            public getZone(): java.time.ZoneId
            public withZone(arg0: java.time.ZoneId): java.time.Clock
            public millis(): long
            public instant(): java.time.Instant
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        class DateTimeException extends java.lang.RuntimeException {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class DayOfWeek extends java.lang.Enum<java.time.DayOfWeek> implements java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster {
            public static MONDAY: java.time.DayOfWeek
            public static TUESDAY: java.time.DayOfWeek
            public static WEDNESDAY: java.time.DayOfWeek
            public static THURSDAY: java.time.DayOfWeek
            public static FRIDAY: java.time.DayOfWeek
            public static SATURDAY: java.time.DayOfWeek
            public static SUNDAY: java.time.DayOfWeek
            public static values(): java.time.DayOfWeek[]
            public static valueOf(arg0: java.lang.String | string): java.time.DayOfWeek
            public static of(arg0: int): java.time.DayOfWeek
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.DayOfWeek
            public getValue(): int
            public getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public plus(arg0: long): java.time.DayOfWeek
            public minus(arg0: long): java.time.DayOfWeek
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public static class: java.lang.Class<any>
        }
        class DayOfWeek$$Lambda extends java.lang.Enum<java.time.DayOfWeek> implements java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster {
            public static MONDAY: java.time.DayOfWeek
        }
        class Duration implements java.time.temporal.TemporalAmount , java.lang.Comparable<java.time.Duration> , java.io.Serializable {
            public static ZERO: java.time.Duration
            public static ofDays(arg0: long): java.time.Duration
            public static ofHours(arg0: long): java.time.Duration
            public static ofMinutes(arg0: long): java.time.Duration
            public static ofSeconds(arg0: long): java.time.Duration
            public static ofSeconds(arg0: long, arg1: long): java.time.Duration
            public static ofMillis(arg0: long): java.time.Duration
            public static ofNanos(arg0: long): java.time.Duration
            public static of(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Duration
            public static from(arg0: java.time.temporal.TemporalAmount): java.time.Duration
            public static parse(arg0: java.lang.CharSequence): java.time.Duration
            public static between(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.Temporal): java.time.Duration
            public get(arg0: java.time.temporal.TemporalUnit): long
            public getUnits(): java.util.List<java.time.temporal.TemporalUnit>
            public isZero(): boolean
            public isNegative(): boolean
            public getSeconds(): long
            public getNano(): int
            public withSeconds(arg0: long): java.time.Duration
            public withNanos(arg0: int): java.time.Duration
            public plus(arg0: java.time.Duration): java.time.Duration
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Duration
            public plusDays(arg0: long): java.time.Duration
            public plusHours(arg0: long): java.time.Duration
            public plusMinutes(arg0: long): java.time.Duration
            public plusSeconds(arg0: long): java.time.Duration
            public plusMillis(arg0: long): java.time.Duration
            public plusNanos(arg0: long): java.time.Duration
            public minus(arg0: java.time.Duration): java.time.Duration
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Duration
            public minusDays(arg0: long): java.time.Duration
            public minusHours(arg0: long): java.time.Duration
            public minusMinutes(arg0: long): java.time.Duration
            public minusSeconds(arg0: long): java.time.Duration
            public minusMillis(arg0: long): java.time.Duration
            public minusNanos(arg0: long): java.time.Duration
            public multipliedBy(arg0: long): java.time.Duration
            public dividedBy(arg0: long): java.time.Duration
            public negated(): java.time.Duration
            public abs(): java.time.Duration
            public addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public toDays(): long
            public toHours(): long
            public toMinutes(): long
            public toMillis(): long
            public toNanos(): long
            public compareTo(arg0: java.time.Duration): int
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class Instant implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.Instant> , java.io.Serializable {
            public static EPOCH: java.time.Instant
            public static MIN: java.time.Instant
            public static MAX: java.time.Instant
            public static now(): java.time.Instant
            public static now(arg0: java.time.Clock): java.time.Instant
            public static ofEpochSecond(arg0: long): java.time.Instant
            public static ofEpochSecond(arg0: long, arg1: long): java.time.Instant
            public static ofEpochMilli(arg0: long): java.time.Instant
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.Instant
            public static parse(arg0: java.lang.CharSequence): java.time.Instant
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getEpochSecond(): long
            public getNano(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.Instant
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.Instant
            public truncatedTo(arg0: java.time.temporal.TemporalUnit): java.time.Instant
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.Instant
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Instant
            public plusSeconds(arg0: long): java.time.Instant
            public plusMillis(arg0: long): java.time.Instant
            public plusNanos(arg0: long): java.time.Instant
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.Instant
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Instant
            public minusSeconds(arg0: long): java.time.Instant
            public minusMillis(arg0: long): java.time.Instant
            public minusNanos(arg0: long): java.time.Instant
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public atOffset<R>(arg0: java.time.ZoneOffset): java.time.OffsetDateTime
            public atZone<R>(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public toEpochMilli<R>(): long
            public compareTo<R>(arg0: java.time.Instant): int
            public isAfter<R>(arg0: java.time.Instant): boolean
            public isBefore<R>(arg0: java.time.Instant): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class LocalDate implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.time.chrono.ChronoLocalDate , java.io.Serializable {
            public static MIN: java.time.LocalDate
            public static MAX: java.time.LocalDate
            public static now(): java.time.LocalDate
            public static now(arg0: java.time.ZoneId): java.time.LocalDate
            public static now(arg0: java.time.Clock): java.time.LocalDate
            public static of(arg0: int, arg1: java.time.Month | java.time.Month$$Lambda, arg2: int): java.time.LocalDate
            public static of(arg0: int, arg1: int, arg2: int): java.time.LocalDate
            public static ofYearDay(arg0: int, arg1: int): java.time.LocalDate
            public static ofEpochDay(arg0: long): java.time.LocalDate
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDate
            public static parse(arg0: java.lang.CharSequence): java.time.LocalDate
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.LocalDate
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getChronology(): java.time.chrono.IsoChronology
            public getEra(): java.time.chrono.Era
            public getYear(): int
            public getMonthValue(): int
            public getMonth(): java.time.Month
            public getDayOfMonth(): int
            public getDayOfYear(): int
            public getDayOfWeek(): java.time.DayOfWeek
            public isLeapYear(): boolean
            public lengthOfMonth(): int
            public lengthOfYear(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.LocalDate
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.LocalDate
            public withYear(arg0: int): java.time.LocalDate
            public withMonth(arg0: int): java.time.LocalDate
            public withDayOfMonth(arg0: int): java.time.LocalDate
            public withDayOfYear(arg0: int): java.time.LocalDate
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.LocalDate
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.LocalDate
            public plusYears(arg0: long): java.time.LocalDate
            public plusMonths(arg0: long): java.time.LocalDate
            public plusWeeks(arg0: long): java.time.LocalDate
            public plusDays(arg0: long): java.time.LocalDate
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.LocalDate
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.LocalDate
            public minusYears(arg0: long): java.time.LocalDate
            public minusMonths(arg0: long): java.time.LocalDate
            public minusWeeks(arg0: long): java.time.LocalDate
            public minusDays(arg0: long): java.time.LocalDate
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public until<R>(arg0: java.time.chrono.ChronoLocalDate): java.time.Period
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atTime<R>(arg0: java.time.LocalTime): java.time.LocalDateTime
            public atTime<R>(arg0: int, arg1: int): java.time.LocalDateTime
            public atTime<R>(arg0: int, arg1: int, arg2: int): java.time.LocalDateTime
            public atTime<R>(arg0: int, arg1: int, arg2: int, arg3: int): java.time.LocalDateTime
            public atTime<R>(arg0: java.time.OffsetTime): java.time.OffsetDateTime
            public atStartOfDay<R>(): java.time.LocalDateTime
            public atStartOfDay<R>(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public toEpochDay<R>(): long
            public compareTo<R>(arg0: java.time.chrono.ChronoLocalDate): int
            public isAfter<R>(arg0: java.time.chrono.ChronoLocalDate): boolean
            public isBefore<R>(arg0: java.time.chrono.ChronoLocalDate): boolean
            public isEqual<R>(arg0: java.time.chrono.ChronoLocalDate): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public atTime<R>(arg0: java.time.LocalTime): java.time.chrono.ChronoLocalDateTime
            public until<R>(arg0: java.time.chrono.ChronoLocalDate): java.time.chrono.ChronoPeriod
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDate
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDate
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDate
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDate
            public getChronology<R>(): java.time.chrono.Chronology
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class LocalDateTime implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.time.chrono.ChronoLocalDateTime<java.time.LocalDate> , java.io.Serializable {
            public static MIN: java.time.LocalDateTime
            public static MAX: java.time.LocalDateTime
            public static now(): java.time.LocalDateTime
            public static now(arg0: java.time.ZoneId): java.time.LocalDateTime
            public static now(arg0: java.time.Clock): java.time.LocalDateTime
            public static of(arg0: int, arg1: java.time.Month | java.time.Month$$Lambda, arg2: int, arg3: int, arg4: int): java.time.LocalDateTime
            public static of(arg0: int, arg1: java.time.Month | java.time.Month$$Lambda, arg2: int, arg3: int, arg4: int, arg5: int): java.time.LocalDateTime
            public static of(arg0: int, arg1: java.time.Month | java.time.Month$$Lambda, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): java.time.LocalDateTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): java.time.LocalDateTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): java.time.LocalDateTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): java.time.LocalDateTime
            public static of(arg0: java.time.LocalDate, arg1: java.time.LocalTime): java.time.LocalDateTime
            public static ofInstant(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.LocalDateTime
            public static ofEpochSecond(arg0: long, arg1: int, arg2: java.time.ZoneOffset): java.time.LocalDateTime
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDateTime
            public static parse(arg0: java.lang.CharSequence): java.time.LocalDateTime
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.LocalDateTime
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public toLocalDate(): java.time.LocalDate
            public getYear(): int
            public getMonthValue(): int
            public getMonth(): java.time.Month
            public getDayOfMonth(): int
            public getDayOfYear(): int
            public getDayOfWeek(): java.time.DayOfWeek
            public toLocalTime(): java.time.LocalTime
            public getHour(): int
            public getMinute(): int
            public getSecond(): int
            public getNano(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.LocalDateTime
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.LocalDateTime
            public withYear(arg0: int): java.time.LocalDateTime
            public withMonth(arg0: int): java.time.LocalDateTime
            public withDayOfMonth(arg0: int): java.time.LocalDateTime
            public withDayOfYear(arg0: int): java.time.LocalDateTime
            public withHour(arg0: int): java.time.LocalDateTime
            public withMinute(arg0: int): java.time.LocalDateTime
            public withSecond(arg0: int): java.time.LocalDateTime
            public withNano(arg0: int): java.time.LocalDateTime
            public truncatedTo(arg0: java.time.temporal.TemporalUnit): java.time.LocalDateTime
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.LocalDateTime
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.LocalDateTime
            public plusYears(arg0: long): java.time.LocalDateTime
            public plusMonths(arg0: long): java.time.LocalDateTime
            public plusWeeks(arg0: long): java.time.LocalDateTime
            public plusDays(arg0: long): java.time.LocalDateTime
            public plusHours(arg0: long): java.time.LocalDateTime
            public plusMinutes(arg0: long): java.time.LocalDateTime
            public plusSeconds(arg0: long): java.time.LocalDateTime
            public plusNanos(arg0: long): java.time.LocalDateTime
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.LocalDateTime
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.LocalDateTime
            public minusYears(arg0: long): java.time.LocalDateTime
            public minusMonths(arg0: long): java.time.LocalDateTime
            public minusWeeks(arg0: long): java.time.LocalDateTime
            public minusDays(arg0: long): java.time.LocalDateTime
            public minusHours(arg0: long): java.time.LocalDateTime
            public minusMinutes(arg0: long): java.time.LocalDateTime
            public minusSeconds(arg0: long): java.time.LocalDateTime
            public minusNanos(arg0: long): java.time.LocalDateTime
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atOffset<R>(arg0: java.time.ZoneOffset): java.time.OffsetDateTime
            public atZone<R>(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public compareTo<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): int
            public isAfter<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean
            public isBefore<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean
            public isEqual<R>(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public atZone<R>(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDateTime
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDateTime
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoLocalDateTime
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoLocalDateTime
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoLocalDateTime
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoLocalDateTime
            public toLocalDate<R>(): java.time.chrono.ChronoLocalDate
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class LocalTime implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.LocalTime> , java.io.Serializable {
            public static MIN: java.time.LocalTime
            public static MAX: java.time.LocalTime
            public static MIDNIGHT: java.time.LocalTime
            public static NOON: java.time.LocalTime
            public static now(): java.time.LocalTime
            public static now(arg0: java.time.ZoneId): java.time.LocalTime
            public static now(arg0: java.time.Clock): java.time.LocalTime
            public static of(arg0: int, arg1: int): java.time.LocalTime
            public static of(arg0: int, arg1: int, arg2: int): java.time.LocalTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int): java.time.LocalTime
            public static ofSecondOfDay(arg0: long): java.time.LocalTime
            public static ofNanoOfDay(arg0: long): java.time.LocalTime
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.LocalTime
            public static parse(arg0: java.lang.CharSequence): java.time.LocalTime
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.LocalTime
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getHour(): int
            public getMinute(): int
            public getSecond(): int
            public getNano(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.LocalTime
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.LocalTime
            public withHour(arg0: int): java.time.LocalTime
            public withMinute(arg0: int): java.time.LocalTime
            public withSecond(arg0: int): java.time.LocalTime
            public withNano(arg0: int): java.time.LocalTime
            public truncatedTo(arg0: java.time.temporal.TemporalUnit): java.time.LocalTime
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.LocalTime
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.LocalTime
            public plusHours(arg0: long): java.time.LocalTime
            public plusMinutes(arg0: long): java.time.LocalTime
            public plusSeconds(arg0: long): java.time.LocalTime
            public plusNanos(arg0: long): java.time.LocalTime
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.LocalTime
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.LocalTime
            public minusHours(arg0: long): java.time.LocalTime
            public minusMinutes(arg0: long): java.time.LocalTime
            public minusSeconds(arg0: long): java.time.LocalTime
            public minusNanos(arg0: long): java.time.LocalTime
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atDate<R>(arg0: java.time.LocalDate): java.time.LocalDateTime
            public atOffset<R>(arg0: java.time.ZoneOffset): java.time.OffsetTime
            public toSecondOfDay<R>(): int
            public toNanoOfDay<R>(): long
            public compareTo<R>(arg0: java.time.LocalTime): int
            public isAfter<R>(arg0: java.time.LocalTime): boolean
            public isBefore<R>(arg0: java.time.LocalTime): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class Month extends java.lang.Enum<java.time.Month> implements java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster {
            public static JANUARY: java.time.Month
            public static FEBRUARY: java.time.Month
            public static MARCH: java.time.Month
            public static APRIL: java.time.Month
            public static MAY: java.time.Month
            public static JUNE: java.time.Month
            public static JULY: java.time.Month
            public static AUGUST: java.time.Month
            public static SEPTEMBER: java.time.Month
            public static OCTOBER: java.time.Month
            public static NOVEMBER: java.time.Month
            public static DECEMBER: java.time.Month
            public static values(): java.time.Month[]
            public static valueOf(arg0: java.lang.String | string): java.time.Month
            public static of(arg0: int): java.time.Month
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.Month
            public getValue(): int
            public getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public plus(arg0: long): java.time.Month
            public minus(arg0: long): java.time.Month
            public length(arg0: boolean): int
            public minLength(): int
            public maxLength(): int
            public firstDayOfYear(arg0: boolean): int
            public firstMonthOfQuarter(): java.time.Month
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public static class: java.lang.Class<any>
        }
        class Month$$Lambda extends java.lang.Enum<java.time.Month> implements java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster {
            public static JANUARY: java.time.Month
        }
        class MonthDay implements java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.MonthDay> , java.io.Serializable {
            public static now(): java.time.MonthDay
            public static now(arg0: java.time.ZoneId): java.time.MonthDay
            public static now(arg0: java.time.Clock): java.time.MonthDay
            public static of(arg0: java.time.Month | java.time.Month$$Lambda, arg1: int): java.time.MonthDay
            public static of(arg0: int, arg1: int): java.time.MonthDay
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.MonthDay
            public static parse(arg0: java.lang.CharSequence): java.time.MonthDay
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.MonthDay
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getMonthValue(): int
            public getMonth(): java.time.Month
            public getDayOfMonth(): int
            public isValidYear(arg0: int): boolean
            public withMonth(arg0: int): java.time.MonthDay
            public with(arg0: java.time.Month | java.time.Month$$Lambda): java.time.MonthDay
            public withDayOfMonth(arg0: int): java.time.MonthDay
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atYear<R>(arg0: int): java.time.LocalDate
            public compareTo<R>(arg0: java.time.MonthDay): int
            public isAfter<R>(arg0: java.time.MonthDay): boolean
            public isBefore<R>(arg0: java.time.MonthDay): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class OffsetDateTime implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.OffsetDateTime> , java.io.Serializable {
            public static MIN: java.time.OffsetDateTime
            public static MAX: java.time.OffsetDateTime
            public static timeLineOrder(): java.util.Comparator<java.time.OffsetDateTime>
            public static now(): java.time.OffsetDateTime
            public static now(arg0: java.time.ZoneId): java.time.OffsetDateTime
            public static now(arg0: java.time.Clock): java.time.OffsetDateTime
            public static of(arg0: java.time.LocalDate, arg1: java.time.LocalTime, arg2: java.time.ZoneOffset): java.time.OffsetDateTime
            public static of(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset): java.time.OffsetDateTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: java.time.ZoneOffset): java.time.OffsetDateTime
            public static ofInstant(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.OffsetDateTime
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.OffsetDateTime
            public static parse(arg0: java.lang.CharSequence): java.time.OffsetDateTime
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.OffsetDateTime
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getOffset(): java.time.ZoneOffset
            public withOffsetSameLocal(arg0: java.time.ZoneOffset): java.time.OffsetDateTime
            public withOffsetSameInstant(arg0: java.time.ZoneOffset): java.time.OffsetDateTime
            public toLocalDateTime(): java.time.LocalDateTime
            public toLocalDate(): java.time.LocalDate
            public getYear(): int
            public getMonthValue(): int
            public getMonth(): java.time.Month
            public getDayOfMonth(): int
            public getDayOfYear(): int
            public getDayOfWeek(): java.time.DayOfWeek
            public toLocalTime(): java.time.LocalTime
            public getHour(): int
            public getMinute(): int
            public getSecond(): int
            public getNano(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.OffsetDateTime
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.OffsetDateTime
            public withYear(arg0: int): java.time.OffsetDateTime
            public withMonth(arg0: int): java.time.OffsetDateTime
            public withDayOfMonth(arg0: int): java.time.OffsetDateTime
            public withDayOfYear(arg0: int): java.time.OffsetDateTime
            public withHour(arg0: int): java.time.OffsetDateTime
            public withMinute(arg0: int): java.time.OffsetDateTime
            public withSecond(arg0: int): java.time.OffsetDateTime
            public withNano(arg0: int): java.time.OffsetDateTime
            public truncatedTo(arg0: java.time.temporal.TemporalUnit): java.time.OffsetDateTime
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.OffsetDateTime
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.OffsetDateTime
            public plusYears(arg0: long): java.time.OffsetDateTime
            public plusMonths(arg0: long): java.time.OffsetDateTime
            public plusWeeks(arg0: long): java.time.OffsetDateTime
            public plusDays(arg0: long): java.time.OffsetDateTime
            public plusHours(arg0: long): java.time.OffsetDateTime
            public plusMinutes(arg0: long): java.time.OffsetDateTime
            public plusSeconds(arg0: long): java.time.OffsetDateTime
            public plusNanos(arg0: long): java.time.OffsetDateTime
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.OffsetDateTime
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.OffsetDateTime
            public minusYears(arg0: long): java.time.OffsetDateTime
            public minusMonths(arg0: long): java.time.OffsetDateTime
            public minusWeeks(arg0: long): java.time.OffsetDateTime
            public minusDays(arg0: long): java.time.OffsetDateTime
            public minusHours(arg0: long): java.time.OffsetDateTime
            public minusMinutes(arg0: long): java.time.OffsetDateTime
            public minusSeconds(arg0: long): java.time.OffsetDateTime
            public minusNanos(arg0: long): java.time.OffsetDateTime
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atZoneSameInstant<R>(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public atZoneSimilarLocal<R>(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public toOffsetTime<R>(): java.time.OffsetTime
            public toZonedDateTime<R>(): java.time.ZonedDateTime
            public toInstant<R>(): java.time.Instant
            public toEpochSecond<R>(): long
            public compareTo<R>(arg0: java.time.OffsetDateTime): int
            public isAfter<R>(arg0: java.time.OffsetDateTime): boolean
            public isBefore<R>(arg0: java.time.OffsetDateTime): boolean
            public isEqual<R>(arg0: java.time.OffsetDateTime): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class OffsetTime implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.OffsetTime> , java.io.Serializable {
            public static MIN: java.time.OffsetTime
            public static MAX: java.time.OffsetTime
            public static now(): java.time.OffsetTime
            public static now(arg0: java.time.ZoneId): java.time.OffsetTime
            public static now(arg0: java.time.Clock): java.time.OffsetTime
            public static of(arg0: java.time.LocalTime, arg1: java.time.ZoneOffset): java.time.OffsetTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: java.time.ZoneOffset): java.time.OffsetTime
            public static ofInstant(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.OffsetTime
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.OffsetTime
            public static parse(arg0: java.lang.CharSequence): java.time.OffsetTime
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.OffsetTime
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getOffset(): java.time.ZoneOffset
            public withOffsetSameLocal(arg0: java.time.ZoneOffset): java.time.OffsetTime
            public withOffsetSameInstant(arg0: java.time.ZoneOffset): java.time.OffsetTime
            public toLocalTime(): java.time.LocalTime
            public getHour(): int
            public getMinute(): int
            public getSecond(): int
            public getNano(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.OffsetTime
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.OffsetTime
            public withHour(arg0: int): java.time.OffsetTime
            public withMinute(arg0: int): java.time.OffsetTime
            public withSecond(arg0: int): java.time.OffsetTime
            public withNano(arg0: int): java.time.OffsetTime
            public truncatedTo(arg0: java.time.temporal.TemporalUnit): java.time.OffsetTime
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.OffsetTime
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.OffsetTime
            public plusHours(arg0: long): java.time.OffsetTime
            public plusMinutes(arg0: long): java.time.OffsetTime
            public plusSeconds(arg0: long): java.time.OffsetTime
            public plusNanos(arg0: long): java.time.OffsetTime
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.OffsetTime
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.OffsetTime
            public minusHours(arg0: long): java.time.OffsetTime
            public minusMinutes(arg0: long): java.time.OffsetTime
            public minusSeconds(arg0: long): java.time.OffsetTime
            public minusNanos(arg0: long): java.time.OffsetTime
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atDate<R>(arg0: java.time.LocalDate): java.time.OffsetDateTime
            public compareTo<R>(arg0: java.time.OffsetTime): int
            public isAfter<R>(arg0: java.time.OffsetTime): boolean
            public isBefore<R>(arg0: java.time.OffsetTime): boolean
            public isEqual<R>(arg0: java.time.OffsetTime): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class Period implements java.time.chrono.ChronoPeriod , java.io.Serializable {
            public static ZERO: java.time.Period
            public static ofYears(arg0: int): java.time.Period
            public static ofMonths(arg0: int): java.time.Period
            public static ofWeeks(arg0: int): java.time.Period
            public static ofDays(arg0: int): java.time.Period
            public static of(arg0: int, arg1: int, arg2: int): java.time.Period
            public static from(arg0: java.time.temporal.TemporalAmount): java.time.Period
            public static parse(arg0: java.lang.CharSequence): java.time.Period
            public static between(arg0: java.time.LocalDate, arg1: java.time.LocalDate): java.time.Period
            public get(arg0: java.time.temporal.TemporalUnit): long
            public getUnits(): java.util.List<java.time.temporal.TemporalUnit>
            public getChronology(): java.time.chrono.IsoChronology
            public isZero(): boolean
            public isNegative(): boolean
            public getYears(): int
            public getMonths(): int
            public getDays(): int
            public withYears(arg0: int): java.time.Period
            public withMonths(arg0: int): java.time.Period
            public withDays(arg0: int): java.time.Period
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.Period
            public plusYears(arg0: long): java.time.Period
            public plusMonths(arg0: long): java.time.Period
            public plusDays(arg0: long): java.time.Period
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.Period
            public minusYears(arg0: long): java.time.Period
            public minusMonths(arg0: long): java.time.Period
            public minusDays(arg0: long): java.time.Period
            public multipliedBy(arg0: int): java.time.Period
            public negated(): java.time.Period
            public normalized(): java.time.Period
            public toTotalMonths(): long
            public addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public normalized(): java.time.chrono.ChronoPeriod
            public negated(): java.time.chrono.ChronoPeriod
            public multipliedBy(arg0: int): java.time.chrono.ChronoPeriod
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoPeriod
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoPeriod
            public getChronology(): java.time.chrono.Chronology
            public static class: java.lang.Class<any>
        }
        class Ser implements java.io.Externalizable {
            public constructor()
            public writeExternal(arg0: java.io.ObjectOutput): void
            public readExternal(arg0: java.io.ObjectInput): void
            public static class: java.lang.Class<any>
        }
        class Year implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.Year> , java.io.Serializable {
            public static MIN_VALUE: int
            public static MAX_VALUE: int
            public static now(): java.time.Year
            public static now(arg0: java.time.ZoneId): java.time.Year
            public static now(arg0: java.time.Clock): java.time.Year
            public static of(arg0: int): java.time.Year
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.Year
            public static parse(arg0: java.lang.CharSequence): java.time.Year
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.Year
            public static isLeap(arg0: long): boolean
            public getValue(): int
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public isLeap(): boolean
            public isValidMonthDay(arg0: java.time.MonthDay): boolean
            public length(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.Year
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.Year
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.Year
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Year
            public plusYears(arg0: long): java.time.Year
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.Year
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.Year
            public minusYears(arg0: long): java.time.Year
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atDay<R>(arg0: int): java.time.LocalDate
            public atMonth<R>(arg0: java.time.Month | java.time.Month$$Lambda): java.time.YearMonth
            public atMonth<R>(arg0: int): java.time.YearMonth
            public atMonthDay<R>(arg0: java.time.MonthDay): java.time.LocalDate
            public compareTo<R>(arg0: java.time.Year): int
            public isAfter<R>(arg0: java.time.Year): boolean
            public isBefore<R>(arg0: java.time.Year): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class YearMonth implements java.time.temporal.Temporal , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.YearMonth> , java.io.Serializable {
            public static now(): java.time.YearMonth
            public static now(arg0: java.time.ZoneId): java.time.YearMonth
            public static now(arg0: java.time.Clock): java.time.YearMonth
            public static of(arg0: int, arg1: java.time.Month | java.time.Month$$Lambda): java.time.YearMonth
            public static of(arg0: int, arg1: int): java.time.YearMonth
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.YearMonth
            public static parse(arg0: java.lang.CharSequence): java.time.YearMonth
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.YearMonth
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getYear(): int
            public getMonthValue(): int
            public getMonth(): java.time.Month
            public isLeapYear(): boolean
            public isValidDay(arg0: int): boolean
            public lengthOfMonth(): int
            public lengthOfYear(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.YearMonth
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.YearMonth
            public withYear(arg0: int): java.time.YearMonth
            public withMonth(arg0: int): java.time.YearMonth
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.YearMonth
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.YearMonth
            public plusYears(arg0: long): java.time.YearMonth
            public plusMonths(arg0: long): java.time.YearMonth
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.YearMonth
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.YearMonth
            public minusYears(arg0: long): java.time.YearMonth
            public minusMonths(arg0: long): java.time.YearMonth
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public atDay<R>(arg0: int): java.time.LocalDate
            public atEndOfMonth<R>(): java.time.LocalDate
            public compareTo<R>(arg0: java.time.YearMonth): int
            public isAfter<R>(arg0: java.time.YearMonth): boolean
            public isBefore<R>(arg0: java.time.YearMonth): boolean
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        abstract class ZoneId implements java.io.Serializable {
            public static SHORT_IDS: java.util.Map<java.lang.String, java.lang.String>
            public static systemDefault(): java.time.ZoneId
            public static getAvailableZoneIds(): java.util.Set<java.lang.String>
            public static of(arg0: java.lang.String | string, arg1: java.util.Map<java.lang.String, java.lang.String>): java.time.ZoneId
            public static of(arg0: java.lang.String | string): java.time.ZoneId
            public static ofOffset(arg0: java.lang.String | string, arg1: java.time.ZoneOffset): java.time.ZoneId
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.ZoneId
            public getId(): string
            public getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string
            public getRules(): java.time.zone.ZoneRules
            public normalized(): java.time.ZoneId
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class ZoneOffset extends java.time.ZoneId implements java.time.temporal.TemporalAccessor , java.time.temporal.TemporalAdjuster , java.lang.Comparable<java.time.ZoneOffset> , java.io.Serializable {
            public static UTC: java.time.ZoneOffset
            public static MIN: java.time.ZoneOffset
            public static MAX: java.time.ZoneOffset
            public static of(arg0: java.lang.String | string): java.time.ZoneOffset
            public static ofHours(arg0: int): java.time.ZoneOffset
            public static ofHoursMinutes(arg0: int, arg1: int): java.time.ZoneOffset
            public static ofHoursMinutesSeconds(arg0: int, arg1: int, arg2: int): java.time.ZoneOffset
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.ZoneOffset
            public static ofTotalSeconds(arg0: int): java.time.ZoneOffset
            public getTotalSeconds(): int
            public getId(): string
            public getRules(): java.time.zone.ZoneRules
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public adjustInto<R>(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal
            public compareTo<R>(arg0: java.time.ZoneOffset): int
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public compareTo<R>(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class ZoneRegion extends java.time.ZoneId implements java.io.Serializable {
            public getId(): string
            public getRules(): java.time.zone.ZoneRules
            public static class: java.lang.Class<any>
        }
        class ZonedDateTime implements java.time.temporal.Temporal , java.time.chrono.ChronoZonedDateTime<java.time.LocalDate> , java.io.Serializable {
            public static now(): java.time.ZonedDateTime
            public static now(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public static now(arg0: java.time.Clock): java.time.ZonedDateTime
            public static of(arg0: java.time.LocalDate, arg1: java.time.LocalTime, arg2: java.time.ZoneId): java.time.ZonedDateTime
            public static of(arg0: java.time.LocalDateTime, arg1: java.time.ZoneId): java.time.ZonedDateTime
            public static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: java.time.ZoneId): java.time.ZonedDateTime
            public static ofLocal(arg0: java.time.LocalDateTime, arg1: java.time.ZoneId, arg2: java.time.ZoneOffset): java.time.ZonedDateTime
            public static ofInstant(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.ZonedDateTime
            public static ofInstant(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneId): java.time.ZonedDateTime
            public static ofStrict(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneId): java.time.ZonedDateTime
            public static from(arg0: java.time.temporal.TemporalAccessor): java.time.ZonedDateTime
            public static parse(arg0: java.lang.CharSequence): java.time.ZonedDateTime
            public static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): java.time.ZonedDateTime
            public isSupported(arg0: java.time.temporal.TemporalField): boolean
            public isSupported(arg0: java.time.temporal.TemporalUnit): boolean
            public range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange
            public get(arg0: java.time.temporal.TemporalField): int
            public getLong(arg0: java.time.temporal.TemporalField): long
            public getOffset(): java.time.ZoneOffset
            public withEarlierOffsetAtOverlap(): java.time.ZonedDateTime
            public withLaterOffsetAtOverlap(): java.time.ZonedDateTime
            public getZone(): java.time.ZoneId
            public withZoneSameLocal(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public withZoneSameInstant(arg0: java.time.ZoneId): java.time.ZonedDateTime
            public withFixedOffsetZone(): java.time.ZonedDateTime
            public toLocalDateTime(): java.time.LocalDateTime
            public toLocalDate(): java.time.LocalDate
            public getYear(): int
            public getMonthValue(): int
            public getMonth(): java.time.Month
            public getDayOfMonth(): int
            public getDayOfYear(): int
            public getDayOfWeek(): java.time.DayOfWeek
            public toLocalTime(): java.time.LocalTime
            public getHour(): int
            public getMinute(): int
            public getSecond(): int
            public getNano(): int
            public with(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.ZonedDateTime
            public with(arg0: java.time.temporal.TemporalField, arg1: long): java.time.ZonedDateTime
            public withYear(arg0: int): java.time.ZonedDateTime
            public withMonth(arg0: int): java.time.ZonedDateTime
            public withDayOfMonth(arg0: int): java.time.ZonedDateTime
            public withDayOfYear(arg0: int): java.time.ZonedDateTime
            public withHour(arg0: int): java.time.ZonedDateTime
            public withMinute(arg0: int): java.time.ZonedDateTime
            public withSecond(arg0: int): java.time.ZonedDateTime
            public withNano(arg0: int): java.time.ZonedDateTime
            public truncatedTo(arg0: java.time.temporal.TemporalUnit): java.time.ZonedDateTime
            public plus(arg0: java.time.temporal.TemporalAmount): java.time.ZonedDateTime
            public plus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.ZonedDateTime
            public plusYears(arg0: long): java.time.ZonedDateTime
            public plusMonths(arg0: long): java.time.ZonedDateTime
            public plusWeeks(arg0: long): java.time.ZonedDateTime
            public plusDays(arg0: long): java.time.ZonedDateTime
            public plusHours(arg0: long): java.time.ZonedDateTime
            public plusMinutes(arg0: long): java.time.ZonedDateTime
            public plusSeconds(arg0: long): java.time.ZonedDateTime
            public plusNanos(arg0: long): java.time.ZonedDateTime
            public minus(arg0: java.time.temporal.TemporalAmount): java.time.ZonedDateTime
            public minus(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.ZonedDateTime
            public minusYears(arg0: long): java.time.ZonedDateTime
            public minusMonths(arg0: long): java.time.ZonedDateTime
            public minusWeeks(arg0: long): java.time.ZonedDateTime
            public minusDays(arg0: long): java.time.ZonedDateTime
            public minusHours(arg0: long): java.time.ZonedDateTime
            public minusMinutes(arg0: long): java.time.ZonedDateTime
            public minusSeconds(arg0: long): java.time.ZonedDateTime
            public minusNanos(arg0: long): java.time.ZonedDateTime
            public query<R>(arg0: java.time.temporal.TemporalQuery<R> | java.time.temporal.TemporalQuery$$Lambda<R>): R
            public until<R>(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): long
            public format<R>(arg0: java.time.format.DateTimeFormatter): string
            public toOffsetDateTime<R>(): java.time.OffsetDateTime
            public equals<R>(arg0: java.lang.Object): boolean
            public hashCode<R>(): int
            public toString<R>(): string
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.temporal.Temporal
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.temporal.Temporal
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.temporal.Temporal
            public minus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoZonedDateTime
            public minus<R>(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoZonedDateTime
            public plus<R>(arg0: long, arg1: java.time.temporal.TemporalUnit): java.time.chrono.ChronoZonedDateTime
            public plus<R>(arg0: java.time.temporal.TemporalAmount): java.time.chrono.ChronoZonedDateTime
            public with<R>(arg0: java.time.temporal.TemporalField, arg1: long): java.time.chrono.ChronoZonedDateTime
            public with<R>(arg0: java.time.temporal.TemporalAdjuster | java.time.temporal.TemporalAdjuster$$Lambda): java.time.chrono.ChronoZonedDateTime
            public withZoneSameInstant<R>(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime
            public withZoneSameLocal<R>(arg0: java.time.ZoneId): java.time.chrono.ChronoZonedDateTime
            public withLaterOffsetAtOverlap<R>(): java.time.chrono.ChronoZonedDateTime
            public withEarlierOffsetAtOverlap<R>(): java.time.chrono.ChronoZonedDateTime
            public toLocalDateTime<R>(): java.time.chrono.ChronoLocalDateTime
            public toLocalDate<R>(): java.time.chrono.ChronoLocalDate
            public static class: java.lang.Class<any>
        }
    }
    namespace util {
        namespace concurrent {
            namespace atomic {
                class AtomicBoolean implements java.io.Serializable {
                    public constructor(arg0: boolean)
                    public constructor()
                    public get(): boolean
                    public compareAndSet(arg0: boolean, arg1: boolean): boolean
                    public weakCompareAndSet(arg0: boolean, arg1: boolean): boolean
                    public set(arg0: boolean): void
                    public lazySet(arg0: boolean): void
                    public getAndSet(arg0: boolean): boolean
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class AtomicInteger extends java.lang.Number implements java.io.Serializable {
                    public constructor(arg0: int)
                    public constructor()
                    public get(): int
                    public set(arg0: int): void
                    public lazySet(arg0: int): void
                    public getAndSet(arg0: int): int
                    public compareAndSet(arg0: int, arg1: int): boolean
                    public weakCompareAndSet(arg0: int, arg1: int): boolean
                    public getAndIncrement(): int
                    public getAndDecrement(): int
                    public getAndAdd(arg0: int): int
                    public incrementAndGet(): int
                    public decrementAndGet(): int
                    public addAndGet(arg0: int): int
                    public getAndUpdate(arg0: java.util.function$.IntUnaryOperator): int
                    public updateAndGet(arg0: java.util.function$.IntUnaryOperator): int
                    public getAndAccumulate(arg0: int, arg1: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                    public accumulateAndGet(arg0: int, arg1: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                    public toString(): string
                    public intValue(): int
                    public longValue(): long
                    public floatValue(): float
                    public doubleValue(): double
                    public static class: java.lang.Class<any>
                }
                class AtomicIntegerArray implements java.io.Serializable {
                    public constructor(arg0: int)
                    public constructor(arg0: int[])
                    public length(): int
                    public get(arg0: int): int
                    public set(arg0: int, arg1: int): void
                    public lazySet(arg0: int, arg1: int): void
                    public getAndSet(arg0: int, arg1: int): int
                    public compareAndSet(arg0: int, arg1: int, arg2: int): boolean
                    public weakCompareAndSet(arg0: int, arg1: int, arg2: int): boolean
                    public getAndIncrement(arg0: int): int
                    public getAndDecrement(arg0: int): int
                    public getAndAdd(arg0: int, arg1: int): int
                    public incrementAndGet(arg0: int): int
                    public decrementAndGet(arg0: int): int
                    public addAndGet(arg0: int, arg1: int): int
                    public getAndUpdate(arg0: int, arg1: java.util.function$.IntUnaryOperator): int
                    public updateAndGet(arg0: int, arg1: java.util.function$.IntUnaryOperator): int
                    public getAndAccumulate(arg0: int, arg1: int, arg2: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                    public accumulateAndGet(arg0: int, arg1: int, arg2: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                abstract class AtomicIntegerFieldUpdater<T> {
                    public static newUpdater<U>(arg0: java.lang.Class<U>, arg1: java.lang.String | string): java.util.concurrent.atomic.AtomicIntegerFieldUpdater<U>
                    protected constructor()
                    public compareAndSet(arg0: T, arg1: int, arg2: int): boolean
                    public weakCompareAndSet(arg0: T, arg1: int, arg2: int): boolean
                    public set(arg0: T, arg1: int): void
                    public lazySet(arg0: T, arg1: int): void
                    public get(arg0: T): int
                    public getAndSet(arg0: T, arg1: int): int
                    public getAndIncrement(arg0: T): int
                    public getAndDecrement(arg0: T): int
                    public getAndAdd(arg0: T, arg1: int): int
                    public incrementAndGet(arg0: T): int
                    public decrementAndGet(arg0: T): int
                    public addAndGet(arg0: T, arg1: int): int
                    public getAndUpdate(arg0: T, arg1: java.util.function$.IntUnaryOperator): int
                    public updateAndGet(arg0: T, arg1: java.util.function$.IntUnaryOperator): int
                    public getAndAccumulate(arg0: T, arg1: int, arg2: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                    public accumulateAndGet(arg0: T, arg1: int, arg2: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                    public static class: java.lang.Class<any>
                }
                class AtomicLong extends java.lang.Number implements java.io.Serializable {
                    public constructor(arg0: long)
                    public constructor()
                    public get(): long
                    public set(arg0: long): void
                    public lazySet(arg0: long): void
                    public getAndSet(arg0: long): long
                    public compareAndSet(arg0: long, arg1: long): boolean
                    public weakCompareAndSet(arg0: long, arg1: long): boolean
                    public getAndIncrement(): long
                    public getAndDecrement(): long
                    public getAndAdd(arg0: long): long
                    public incrementAndGet(): long
                    public decrementAndGet(): long
                    public addAndGet(arg0: long): long
                    public getAndUpdate(arg0: java.util.function$.LongUnaryOperator): long
                    public updateAndGet(arg0: java.util.function$.LongUnaryOperator): long
                    public getAndAccumulate(arg0: long, arg1: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                    public accumulateAndGet(arg0: long, arg1: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                    public toString(): string
                    public intValue(): int
                    public longValue(): long
                    public floatValue(): float
                    public doubleValue(): double
                    public static class: java.lang.Class<any>
                }
                class AtomicLongArray implements java.io.Serializable {
                    public constructor(arg0: int)
                    public constructor(arg0: long[])
                    public length(): int
                    public get(arg0: int): long
                    public set(arg0: int, arg1: long): void
                    public lazySet(arg0: int, arg1: long): void
                    public getAndSet(arg0: int, arg1: long): long
                    public compareAndSet(arg0: int, arg1: long, arg2: long): boolean
                    public weakCompareAndSet(arg0: int, arg1: long, arg2: long): boolean
                    public getAndIncrement(arg0: int): long
                    public getAndDecrement(arg0: int): long
                    public getAndAdd(arg0: int, arg1: long): long
                    public incrementAndGet(arg0: int): long
                    public decrementAndGet(arg0: int): long
                    public addAndGet(arg0: int, arg1: long): long
                    public getAndUpdate(arg0: int, arg1: java.util.function$.LongUnaryOperator): long
                    public updateAndGet(arg0: int, arg1: java.util.function$.LongUnaryOperator): long
                    public getAndAccumulate(arg0: int, arg1: long, arg2: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                    public accumulateAndGet(arg0: int, arg1: long, arg2: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                abstract class AtomicLongFieldUpdater<T> {
                    public static newUpdater<U>(arg0: java.lang.Class<U>, arg1: java.lang.String | string): java.util.concurrent.atomic.AtomicLongFieldUpdater<U>
                    protected constructor()
                    public compareAndSet(arg0: T, arg1: long, arg2: long): boolean
                    public weakCompareAndSet(arg0: T, arg1: long, arg2: long): boolean
                    public set(arg0: T, arg1: long): void
                    public lazySet(arg0: T, arg1: long): void
                    public get(arg0: T): long
                    public getAndSet(arg0: T, arg1: long): long
                    public getAndIncrement(arg0: T): long
                    public getAndDecrement(arg0: T): long
                    public getAndAdd(arg0: T, arg1: long): long
                    public incrementAndGet(arg0: T): long
                    public decrementAndGet(arg0: T): long
                    public addAndGet(arg0: T, arg1: long): long
                    public getAndUpdate(arg0: T, arg1: java.util.function$.LongUnaryOperator): long
                    public updateAndGet(arg0: T, arg1: java.util.function$.LongUnaryOperator): long
                    public getAndAccumulate(arg0: T, arg1: long, arg2: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                    public accumulateAndGet(arg0: T, arg1: long, arg2: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                    public static class: java.lang.Class<any>
                }
                class AtomicMarkableReference<V> {
                    public constructor(arg0: V, arg1: boolean)
                    public getReference(): V
                    public isMarked(): boolean
                    public get(arg0: boolean[]): V
                    public weakCompareAndSet(arg0: V, arg1: V, arg2: boolean, arg3: boolean): boolean
                    public compareAndSet(arg0: V, arg1: V, arg2: boolean, arg3: boolean): boolean
                    public set(arg0: V, arg1: boolean): void
                    public attemptMark(arg0: V, arg1: boolean): boolean
                    public static class: java.lang.Class<any>
                }
                class AtomicReference<V> implements java.io.Serializable {
                    public constructor(arg0: V)
                    public constructor()
                    public get(): V
                    public set(arg0: V): void
                    public lazySet(arg0: V): void
                    public compareAndSet(arg0: V, arg1: V): boolean
                    public weakCompareAndSet(arg0: V, arg1: V): boolean
                    public getAndSet(arg0: V): V
                    public getAndUpdate(arg0: java.util.function$.UnaryOperator<V>): V
                    public updateAndGet(arg0: java.util.function$.UnaryOperator<V>): V
                    public getAndAccumulate(arg0: V, arg1: java.util.function$.BinaryOperator<V>): V
                    public accumulateAndGet(arg0: V, arg1: java.util.function$.BinaryOperator<V>): V
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class AtomicReferenceArray<E> implements java.io.Serializable {
                    public constructor(arg0: int)
                    public constructor(arg0: E[])
                    public length(): int
                    public get(arg0: int): E
                    public set(arg0: int, arg1: E): void
                    public lazySet(arg0: int, arg1: E): void
                    public getAndSet(arg0: int, arg1: E): E
                    public compareAndSet(arg0: int, arg1: E, arg2: E): boolean
                    public weakCompareAndSet(arg0: int, arg1: E, arg2: E): boolean
                    public getAndUpdate(arg0: int, arg1: java.util.function$.UnaryOperator<E>): E
                    public updateAndGet(arg0: int, arg1: java.util.function$.UnaryOperator<E>): E
                    public getAndAccumulate(arg0: int, arg1: E, arg2: java.util.function$.BinaryOperator<E>): E
                    public accumulateAndGet(arg0: int, arg1: E, arg2: java.util.function$.BinaryOperator<E>): E
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                abstract class AtomicReferenceFieldUpdater<T, V> {
                    public static newUpdater<U, W>(arg0: java.lang.Class<U>, arg1: java.lang.Class<W>, arg2: java.lang.String | string): java.util.concurrent.atomic.AtomicReferenceFieldUpdater<U, W>
                    protected constructor()
                    public compareAndSet(arg0: T, arg1: V, arg2: V): boolean
                    public weakCompareAndSet(arg0: T, arg1: V, arg2: V): boolean
                    public set(arg0: T, arg1: V): void
                    public lazySet(arg0: T, arg1: V): void
                    public get(arg0: T): V
                    public getAndSet(arg0: T, arg1: V): V
                    public getAndUpdate(arg0: T, arg1: java.util.function$.UnaryOperator<V>): V
                    public updateAndGet(arg0: T, arg1: java.util.function$.UnaryOperator<V>): V
                    public getAndAccumulate(arg0: T, arg1: V, arg2: java.util.function$.BinaryOperator<V>): V
                    public accumulateAndGet(arg0: T, arg1: V, arg2: java.util.function$.BinaryOperator<V>): V
                    public static class: java.lang.Class<any>
                }
                class AtomicStampedReference<V> {
                    public constructor(arg0: V, arg1: int)
                    public getReference(): V
                    public getStamp(): int
                    public get(arg0: int[]): V
                    public weakCompareAndSet(arg0: V, arg1: V, arg2: int, arg3: int): boolean
                    public compareAndSet(arg0: V, arg1: V, arg2: int, arg3: int): boolean
                    public set(arg0: V, arg1: int): void
                    public attemptStamp(arg0: V, arg1: int): boolean
                    public static class: java.lang.Class<any>
                }
                class DoubleAccumulator extends java.util.concurrent.atomic.Striped64 implements java.io.Serializable {
                    public constructor(arg0: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda, arg1: double)
                    public accumulate(arg0: double): void
                    public get(): double
                    public reset(): void
                    public getThenReset(): double
                    public toString(): string
                    public doubleValue(): double
                    public longValue(): long
                    public intValue(): int
                    public floatValue(): float
                    public static class: java.lang.Class<any>
                }
                class DoubleAdder extends java.util.concurrent.atomic.Striped64 implements java.io.Serializable {
                    public constructor()
                    public add(arg0: double): void
                    public sum(): double
                    public reset(): void
                    public sumThenReset(): double
                    public toString(): string
                    public doubleValue(): double
                    public longValue(): long
                    public intValue(): int
                    public floatValue(): float
                    public static class: java.lang.Class<any>
                }
                class LongAccumulator extends java.util.concurrent.atomic.Striped64 implements java.io.Serializable {
                    public constructor(arg0: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda, arg1: long)
                    public accumulate(arg0: long): void
                    public get(): long
                    public reset(): void
                    public getThenReset(): long
                    public toString(): string
                    public longValue(): long
                    public intValue(): int
                    public floatValue(): float
                    public doubleValue(): double
                    public static class: java.lang.Class<any>
                }
                class LongAdder extends java.util.concurrent.atomic.Striped64 implements java.io.Serializable {
                    public constructor()
                    public add(arg0: long): void
                    public increment(): void
                    public decrement(): void
                    public sum(): long
                    public reset(): void
                    public sumThenReset(): long
                    public toString(): string
                    public longValue(): long
                    public intValue(): int
                    public floatValue(): float
                    public doubleValue(): double
                    public static class: java.lang.Class<any>
                }
                abstract class Striped64 extends java.lang.Number {
                    public static class: java.lang.Class<any>
                }
            }
            namespace locks {
                abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
                    protected constructor()
                    protected setExclusiveOwnerThread(arg0: java.lang.Thread | java.lang.Thread$$Lambda): void
                    protected getExclusiveOwnerThread(): java.lang.Thread
                    public static class: java.lang.Class<any>
                }
                abstract class AbstractQueuedLongSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
                    protected constructor()
                    protected getState(): long
                    protected setState(arg0: long): void
                    protected compareAndSetState(arg0: long, arg1: long): boolean
                    protected tryAcquire(arg0: long): boolean
                    protected tryRelease(arg0: long): boolean
                    protected tryAcquireShared(arg0: long): long
                    protected tryReleaseShared(arg0: long): boolean
                    protected isHeldExclusively(): boolean
                    public acquire(arg0: long): void
                    public acquireInterruptibly(arg0: long): void
                    public tryAcquireNanos(arg0: long, arg1: long): boolean
                    public release(arg0: long): boolean
                    public acquireShared(arg0: long): void
                    public acquireSharedInterruptibly(arg0: long): void
                    public tryAcquireSharedNanos(arg0: long, arg1: long): boolean
                    public releaseShared(arg0: long): boolean
                    public hasQueuedThreads(): boolean
                    public hasContended(): boolean
                    public getFirstQueuedThread(): java.lang.Thread
                    public isQueued(arg0: java.lang.Thread | java.lang.Thread$$Lambda): boolean
                    public hasQueuedPredecessors(): boolean
                    public getQueueLength(): int
                    public getQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public getExclusiveQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public getSharedQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public toString(): string
                    public owns(arg0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): boolean
                    public hasWaiters(arg0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): boolean
                    public getWaitQueueLength(arg0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): int
                    public getWaitingThreads(arg0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): java.util.Collection<java.lang.Thread>
                    public static class: java.lang.Class<any>
                }
                abstract class AbstractQueuedSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
                    protected constructor()
                    protected getState(): int
                    protected setState(arg0: int): void
                    protected compareAndSetState(arg0: int, arg1: int): boolean
                    protected tryAcquire(arg0: int): boolean
                    protected tryRelease(arg0: int): boolean
                    protected tryAcquireShared(arg0: int): int
                    protected tryReleaseShared(arg0: int): boolean
                    protected isHeldExclusively(): boolean
                    public acquire(arg0: int): void
                    public acquireInterruptibly(arg0: int): void
                    public tryAcquireNanos(arg0: int, arg1: long): boolean
                    public release(arg0: int): boolean
                    public acquireShared(arg0: int): void
                    public acquireSharedInterruptibly(arg0: int): void
                    public tryAcquireSharedNanos(arg0: int, arg1: long): boolean
                    public releaseShared(arg0: int): boolean
                    public hasQueuedThreads(): boolean
                    public hasContended(): boolean
                    public getFirstQueuedThread(): java.lang.Thread
                    public isQueued(arg0: java.lang.Thread | java.lang.Thread$$Lambda): boolean
                    public hasQueuedPredecessors(): boolean
                    public getQueueLength(): int
                    public getQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public getExclusiveQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public getSharedQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public toString(): string
                    public owns(arg0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean
                    public hasWaiters(arg0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean
                    public getWaitQueueLength(arg0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): int
                    public getWaitingThreads(arg0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection<java.lang.Thread>
                    public static class: java.lang.Class<any>
                }
                interface Condition {
                    await(): void
                    awaitUninterruptibly(): void
                    awaitNanos(arg0: long): long
                    await(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                    awaitUntil(arg0: java.util.Date): boolean
                    signal(): void
                    signalAll(): void
                }
                interface Lock {
                    lock(): void
                    lockInterruptibly(): void
                    tryLock(): boolean
                    tryLock(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                    unlock(): void
                    newCondition(): java.util.concurrent.locks.Condition
                }
                class LockSupport {
                    public static unpark(arg0: java.lang.Thread | java.lang.Thread$$Lambda): void
                    public static park(arg0: java.lang.Object): void
                    public static parkNanos(arg0: java.lang.Object, arg1: long): void
                    public static parkUntil(arg0: java.lang.Object, arg1: long): void
                    public static getBlocker(arg0: java.lang.Thread | java.lang.Thread$$Lambda): java.lang.Object
                    public static park(): void
                    public static parkNanos(arg0: long): void
                    public static parkUntil(arg0: long): void
                    public static class: java.lang.Class<any>
                }
                interface ReadWriteLock {
                    readLock(): java.util.concurrent.locks.Lock
                    writeLock(): java.util.concurrent.locks.Lock
                }
                class ReentrantLock implements java.util.concurrent.locks.Lock , java.io.Serializable {
                    public constructor()
                    public constructor(arg0: boolean)
                    public lock(): void
                    public lockInterruptibly(): void
                    public tryLock(): boolean
                    public tryLock(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                    public unlock(): void
                    public newCondition(): java.util.concurrent.locks.Condition
                    public getHoldCount(): int
                    public isHeldByCurrentThread(): boolean
                    public isLocked(): boolean
                    public isFair(): boolean
                    protected getOwner(): java.lang.Thread
                    public hasQueuedThreads(): boolean
                    public hasQueuedThread(arg0: java.lang.Thread | java.lang.Thread$$Lambda): boolean
                    public getQueueLength(): int
                    protected getQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public hasWaiters(arg0: java.util.concurrent.locks.Condition): boolean
                    public getWaitQueueLength(arg0: java.util.concurrent.locks.Condition): int
                    protected getWaitingThreads(arg0: java.util.concurrent.locks.Condition): java.util.Collection<java.lang.Thread>
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class ReentrantReadWriteLock implements java.util.concurrent.locks.ReadWriteLock , java.io.Serializable {
                    public constructor()
                    public constructor(arg0: boolean)
                    public writeLock(): java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock
                    public readLock(): java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock
                    public isFair(): boolean
                    protected getOwner(): java.lang.Thread
                    public getReadLockCount(): int
                    public isWriteLocked(): boolean
                    public isWriteLockedByCurrentThread(): boolean
                    public getWriteHoldCount(): int
                    public getReadHoldCount(): int
                    protected getQueuedWriterThreads(): java.util.Collection<java.lang.Thread>
                    protected getQueuedReaderThreads(): java.util.Collection<java.lang.Thread>
                    public hasQueuedThreads(): boolean
                    public hasQueuedThread(arg0: java.lang.Thread | java.lang.Thread$$Lambda): boolean
                    public getQueueLength(): int
                    protected getQueuedThreads(): java.util.Collection<java.lang.Thread>
                    public hasWaiters(arg0: java.util.concurrent.locks.Condition): boolean
                    public getWaitQueueLength(arg0: java.util.concurrent.locks.Condition): int
                    protected getWaitingThreads(arg0: java.util.concurrent.locks.Condition): java.util.Collection<java.lang.Thread>
                    public toString(): string
                    public writeLock(): java.util.concurrent.locks.Lock
                    public readLock(): java.util.concurrent.locks.Lock
                    public static class: java.lang.Class<any>
                }
                class StampedLock implements java.io.Serializable {
                    public constructor()
                    public writeLock(): long
                    public tryWriteLock(): long
                    public tryWriteLock(arg0: long, arg1: java.util.concurrent.TimeUnit): long
                    public writeLockInterruptibly(): long
                    public readLock(): long
                    public tryReadLock(): long
                    public tryReadLock(arg0: long, arg1: java.util.concurrent.TimeUnit): long
                    public readLockInterruptibly(): long
                    public tryOptimisticRead(): long
                    public validate(arg0: long): boolean
                    public unlockWrite(arg0: long): void
                    public unlockRead(arg0: long): void
                    public unlock(arg0: long): void
                    public tryConvertToWriteLock(arg0: long): long
                    public tryConvertToReadLock(arg0: long): long
                    public tryConvertToOptimisticRead(arg0: long): long
                    public tryUnlockWrite(): boolean
                    public tryUnlockRead(): boolean
                    public isWriteLocked(): boolean
                    public isReadLocked(): boolean
                    public getReadLockCount(): int
                    public toString(): string
                    public asReadLock(): java.util.concurrent.locks.Lock
                    public asWriteLock(): java.util.concurrent.locks.Lock
                    public asReadWriteLock(): java.util.concurrent.locks.ReadWriteLock
                    public static class: java.lang.Class<any>
                }
            }
            abstract class AbstractExecutorService implements java.util.concurrent.ExecutorService {
                public constructor()
                protected newTaskFor<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.RunnableFuture<T>
                protected newTaskFor<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.RunnableFuture<T>
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.Future<any>
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.Future<T>
                public submit<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.Future<T>
                public invokeAny<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>): T
                public invokeAny<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>, arg1: long, arg2: java.util.concurrent.TimeUnit): T
                public invokeAll<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>): java.util.List<java.util.concurrent.Future<T>>
                public invokeAll<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>, arg1: long, arg2: java.util.concurrent.TimeUnit): java.util.List<java.util.concurrent.Future<T>>
                public static class: java.lang.Class<any>
            }
            class ArrayBlockingQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> , java.io.Serializable {
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: boolean)
                public constructor(arg0: int, arg1: boolean, arg2: java.util.Collection<E>)
                public add(arg0: E): boolean
                public offer(arg0: E): boolean
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public poll(): E
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public peek(): E
                public size(): int
                public remainingCapacity(): int
                public remove(arg0: java.lang.Object): boolean
                public contains(arg0: java.lang.Object): boolean
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public toString<T>(): string
                public clear<T>(): void
                public drainTo<T>(arg0: java.util.Collection<E>): int
                public drainTo<T>(arg0: java.util.Collection<E>, arg1: int): int
                public iterator<T>(): java.util.Iterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            interface BlockingDeque<E> extends java.util.concurrent.BlockingQueue<E> , java.util.Deque<E> {
                addFirst(arg0: E): void
                addLast(arg0: E): void
                offerFirst(arg0: E): boolean
                offerLast(arg0: E): boolean
                putFirst(arg0: E): void
                putLast(arg0: E): void
                offerFirst(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                offerLast(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                takeFirst(): E
                takeLast(): E
                pollFirst(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                pollLast(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                removeFirstOccurrence(arg0: java.lang.Object): boolean
                removeLastOccurrence(arg0: java.lang.Object): boolean
                add(arg0: E): boolean
                offer(arg0: E): boolean
                put(arg0: E): void
                offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                remove(): E
                poll(): E
                take(): E
                poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                element(): E
                peek(): E
                remove(arg0: java.lang.Object): boolean
                contains(arg0: java.lang.Object): boolean
                size(): int
                iterator(): java.util.Iterator<E>
                push(arg0: E): void
            }
            interface BlockingQueue<E> extends java.util.Queue<E> {
                add(arg0: E): boolean
                offer(arg0: E): boolean
                put(arg0: E): void
                offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                take(): E
                poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                remainingCapacity(): int
                remove(arg0: java.lang.Object): boolean
                contains(arg0: java.lang.Object): boolean
                drainTo(arg0: java.util.Collection<E>): int
                drainTo(arg0: java.util.Collection<E>, arg1: int): int
            }
            class BrokenBarrierException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface Callable<V> {
                call(): V
            }
            interface Callable$$Lambda<V> {
                (): V
            }
            class CancellationException extends java.lang.IllegalStateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CompletableFuture<T> implements java.util.concurrent.Future<T> , java.util.concurrent.CompletionStage<T> {
                public constructor()
                public static supplyAsync<U>(arg0: java.util.function$.Supplier<U> | java.util.function$.Supplier$$Lambda<U>): java.util.concurrent.CompletableFuture<U>
                public static supplyAsync<U>(arg0: java.util.function$.Supplier<U> | java.util.function$.Supplier$$Lambda<U>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<U>
                public static runAsync(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public static runAsync(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public static completedFuture<U>(arg0: U): java.util.concurrent.CompletableFuture<U>
                public isDone(): boolean
                public get(): T
                public get(arg0: long, arg1: java.util.concurrent.TimeUnit): T
                public join(): T
                public getNow(arg0: T): T
                public complete(arg0: T): boolean
                public completeExceptionally(arg0: java.lang.Throwable): boolean
                public thenApply<U>(arg0: java.util.function$.Function<T, U>): java.util.concurrent.CompletableFuture<U>
                public thenApplyAsync<U>(arg0: java.util.function$.Function<T, U>): java.util.concurrent.CompletableFuture<U>
                public thenApplyAsync<U>(arg0: java.util.function$.Function<T, U>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<U>
                public thenAccept<U>(arg0: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenAcceptAsync<U>(arg0: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenAcceptAsync<U>(arg0: java.util.function$.Consumer$$TypeScript<T>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenRun<U>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenRunAsync<U>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenRunAsync<U>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenCombine<U, V>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiFunction<T, U, V>): java.util.concurrent.CompletableFuture<V>
                public thenCombineAsync<U, V>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiFunction<T, U, V>): java.util.concurrent.CompletableFuture<V>
                public thenCombineAsync<U, V>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiFunction<T, U, V>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<V>
                public thenAcceptBoth<U>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiConsumer<T, U>): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenAcceptBothAsync<U>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiConsumer<T, U>): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenAcceptBothAsync<U>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiConsumer<T, U>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public runAfterBoth<U>(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public runAfterBothAsync<U>(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public runAfterBothAsync<U>(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public applyToEither<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Function<T, U>): java.util.concurrent.CompletableFuture<U>
                public applyToEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Function<T, U>): java.util.concurrent.CompletableFuture<U>
                public applyToEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Function<T, U>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<U>
                public acceptEither<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletableFuture<java.lang.Void>
                public acceptEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletableFuture<java.lang.Void>
                public acceptEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Consumer$$TypeScript<T>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public runAfterEither<U>(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public runAfterEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public runAfterEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<java.lang.Void>
                public thenCompose<U>(arg0: java.util.function$.Function<T, java.util.concurrent.CompletionStage<U>>): java.util.concurrent.CompletableFuture<U>
                public thenComposeAsync<U>(arg0: java.util.function$.Function<T, java.util.concurrent.CompletionStage<U>>): java.util.concurrent.CompletableFuture<U>
                public thenComposeAsync<U>(arg0: java.util.function$.Function<T, java.util.concurrent.CompletionStage<U>>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<U>
                public whenComplete<U>(arg0: java.util.function$.BiConsumer<T, java.lang.Throwable>): java.util.concurrent.CompletableFuture<T>
                public whenCompleteAsync<U>(arg0: java.util.function$.BiConsumer<T, java.lang.Throwable>): java.util.concurrent.CompletableFuture<T>
                public whenCompleteAsync<U>(arg0: java.util.function$.BiConsumer<T, java.lang.Throwable>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<T>
                public handle<U>(arg0: java.util.function$.BiFunction<T, java.lang.Throwable, U>): java.util.concurrent.CompletableFuture<U>
                public handleAsync<U>(arg0: java.util.function$.BiFunction<T, java.lang.Throwable, U>): java.util.concurrent.CompletableFuture<U>
                public handleAsync<U>(arg0: java.util.function$.BiFunction<T, java.lang.Throwable, U>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletableFuture<U>
                public toCompletableFuture<U>(): java.util.concurrent.CompletableFuture<T>
                public exceptionally<U>(arg0: java.util.function$.Function<java.lang.Throwable, T>): java.util.concurrent.CompletableFuture<T>
                public static allOf<U>(...arg0: java.util.concurrent.CompletableFuture<any>[]): java.util.concurrent.CompletableFuture<java.lang.Void>
                public static anyOf<U>(...arg0: java.util.concurrent.CompletableFuture<any>[]): java.util.concurrent.CompletableFuture<java.lang.Object>
                public cancel<U>(arg0: boolean): boolean
                public isCancelled<U>(): boolean
                public isCompletedExceptionally<U>(): boolean
                public obtrudeValue<U>(arg0: T): void
                public obtrudeException<U>(arg0: java.lang.Throwable): void
                public getNumberOfDependents<U>(): int
                public toString<U>(): string
                public handleAsync<U>(arg0: java.util.function$.BiFunction, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public handleAsync<U>(arg0: java.util.function$.BiFunction): java.util.concurrent.CompletionStage
                public handle<U>(arg0: java.util.function$.BiFunction): java.util.concurrent.CompletionStage
                public whenCompleteAsync<U>(arg0: java.util.function$.BiConsumer, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public whenCompleteAsync<U>(arg0: java.util.function$.BiConsumer): java.util.concurrent.CompletionStage
                public whenComplete<U>(arg0: java.util.function$.BiConsumer): java.util.concurrent.CompletionStage
                public exceptionally<U>(arg0: java.util.function$.Function): java.util.concurrent.CompletionStage
                public thenComposeAsync<U>(arg0: java.util.function$.Function, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public thenComposeAsync<U>(arg0: java.util.function$.Function): java.util.concurrent.CompletionStage
                public thenCompose<U>(arg0: java.util.function$.Function): java.util.concurrent.CompletionStage
                public runAfterEitherAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public runAfterEitherAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage
                public runAfterEither<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage
                public acceptEitherAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.Consumer, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public acceptEitherAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.Consumer): java.util.concurrent.CompletionStage
                public acceptEither<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.Consumer): java.util.concurrent.CompletionStage
                public applyToEitherAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.Function, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public applyToEitherAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.Function): java.util.concurrent.CompletionStage
                public applyToEither<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.Function): java.util.concurrent.CompletionStage
                public runAfterBothAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public runAfterBothAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage
                public runAfterBoth<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage
                public thenAcceptBothAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.BiConsumer, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public thenAcceptBothAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.BiConsumer): java.util.concurrent.CompletionStage
                public thenAcceptBoth<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.BiConsumer): java.util.concurrent.CompletionStage
                public thenCombineAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.BiFunction, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public thenCombineAsync<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.BiFunction): java.util.concurrent.CompletionStage
                public thenCombine<U>(arg0: java.util.concurrent.CompletionStage, arg1: java.util.function$.BiFunction): java.util.concurrent.CompletionStage
                public thenRunAsync<U>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public thenRunAsync<U>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage
                public thenRun<U>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage
                public thenAcceptAsync<U>(arg0: java.util.function$.Consumer, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public thenAcceptAsync<U>(arg0: java.util.function$.Consumer): java.util.concurrent.CompletionStage
                public thenAccept<U>(arg0: java.util.function$.Consumer): java.util.concurrent.CompletionStage
                public thenApplyAsync<U>(arg0: java.util.function$.Function, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage
                public thenApplyAsync<U>(arg0: java.util.function$.Function): java.util.concurrent.CompletionStage
                public thenApply<U>(arg0: java.util.function$.Function): java.util.concurrent.CompletionStage
                public static class: java.lang.Class<any>
            }
            class CompletionException extends java.lang.RuntimeException {
                protected constructor()
                protected constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            interface CompletionService<V> {
                submit(arg0: java.util.concurrent.Callable<V> | java.util.concurrent.Callable$$Lambda<V>): java.util.concurrent.Future<V>
                submit(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: V): java.util.concurrent.Future<V>
                take(): java.util.concurrent.Future<V>
                poll(): java.util.concurrent.Future<V>
                poll(arg0: long, arg1: java.util.concurrent.TimeUnit): java.util.concurrent.Future<V>
            }
            interface CompletionStage<T> {
                thenApply<U>(arg0: java.util.function$.Function<T, U>): java.util.concurrent.CompletionStage<U>
                thenApplyAsync<U>(arg0: java.util.function$.Function<T, U>): java.util.concurrent.CompletionStage<U>
                thenApplyAsync<U>(arg0: java.util.function$.Function<T, U>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<U>
                thenAccept(arg0: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletionStage<java.lang.Void>
                thenAcceptAsync(arg0: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletionStage<java.lang.Void>
                thenAcceptAsync(arg0: java.util.function$.Consumer$$TypeScript<T>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                thenRun(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                thenRunAsync(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                thenRunAsync(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                thenCombine<U, V>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiFunction<T, U, V>): java.util.concurrent.CompletionStage<V>
                thenCombineAsync<U, V>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiFunction<T, U, V>): java.util.concurrent.CompletionStage<V>
                thenCombineAsync<U, V>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiFunction<T, U, V>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<V>
                thenAcceptBoth<U>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiConsumer<T, U>): java.util.concurrent.CompletionStage<java.lang.Void>
                thenAcceptBothAsync<U>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiConsumer<T, U>): java.util.concurrent.CompletionStage<java.lang.Void>
                thenAcceptBothAsync<U>(arg0: java.util.concurrent.CompletionStage<U>, arg1: java.util.function$.BiConsumer<T, U>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                runAfterBoth(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                runAfterBothAsync(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                runAfterBothAsync(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                applyToEither<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Function<T, U>): java.util.concurrent.CompletionStage<U>
                applyToEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Function<T, U>): java.util.concurrent.CompletionStage<U>
                applyToEitherAsync<U>(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Function<T, U>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<U>
                acceptEither(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletionStage<java.lang.Void>
                acceptEitherAsync(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Consumer$$TypeScript<T>): java.util.concurrent.CompletionStage<java.lang.Void>
                acceptEitherAsync(arg0: java.util.concurrent.CompletionStage<T>, arg1: java.util.function$.Consumer$$TypeScript<T>, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                runAfterEither(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                runAfterEitherAsync(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                runAfterEitherAsync(arg0: java.util.concurrent.CompletionStage<any>, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda, arg2: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<java.lang.Void>
                thenCompose<U>(arg0: java.util.function$.Function<T, java.util.concurrent.CompletionStage<U>>): java.util.concurrent.CompletionStage<U>
                thenComposeAsync<U>(arg0: java.util.function$.Function<T, java.util.concurrent.CompletionStage<U>>): java.util.concurrent.CompletionStage<U>
                thenComposeAsync<U>(arg0: java.util.function$.Function<T, java.util.concurrent.CompletionStage<U>>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<U>
                exceptionally(arg0: java.util.function$.Function<java.lang.Throwable, T>): java.util.concurrent.CompletionStage<T>
                whenComplete(arg0: java.util.function$.BiConsumer<T, java.lang.Throwable>): java.util.concurrent.CompletionStage<T>
                whenCompleteAsync(arg0: java.util.function$.BiConsumer<T, java.lang.Throwable>): java.util.concurrent.CompletionStage<T>
                whenCompleteAsync(arg0: java.util.function$.BiConsumer<T, java.lang.Throwable>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<T>
                handle<U>(arg0: java.util.function$.BiFunction<T, java.lang.Throwable, U>): java.util.concurrent.CompletionStage<U>
                handleAsync<U>(arg0: java.util.function$.BiFunction<T, java.lang.Throwable, U>): java.util.concurrent.CompletionStage<U>
                handleAsync<U>(arg0: java.util.function$.BiFunction<T, java.lang.Throwable, U>, arg1: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda): java.util.concurrent.CompletionStage<U>
                toCompletableFuture(): java.util.concurrent.CompletableFuture<T>
            }
            class ConcurrentHashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.concurrent.ConcurrentMap<K, V> , java.io.Serializable {
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: java.util.Map<K, V>)
                public constructor(arg0: int, arg1: float)
                public constructor(arg0: int, arg1: float, arg2: int)
                public size(): int
                public isEmpty(): boolean
                public get(arg0: java.lang.Object): V
                public containsKey(arg0: java.lang.Object): boolean
                public containsValue(arg0: java.lang.Object): boolean
                public put(arg0: K, arg1: V): V
                public putAll(arg0: java.util.Map<K, V>): void
                public remove(arg0: java.lang.Object): V
                public clear(): void
                public keySet(): java.util.concurrent.ConcurrentHashMap$KeySetView<K, V>
                public values(): java.util.Collection<V>
                public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
                public hashCode(): int
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public putIfAbsent(arg0: K, arg1: V): V
                public remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
                public replace(arg0: K, arg1: V, arg2: V): boolean
                public replace(arg0: K, arg1: V): V
                public getOrDefault(arg0: java.lang.Object, arg1: V): V
                public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
                public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
                public computeIfAbsent(arg0: K, arg1: java.util.function$.Function<K, V>): V
                public computeIfPresent(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
                public compute(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
                public merge(arg0: K, arg1: V, arg2: java.util.function$.BiFunction<V, V, V>): V
                public contains(arg0: java.lang.Object): boolean
                public keys(): java.util.Enumeration<K>
                public elements(): java.util.Enumeration<V>
                public mappingCount(): long
                public static newKeySet<K>(): java.util.concurrent.ConcurrentHashMap$KeySetView<K, java.lang.Boolean>
                public static newKeySet<K>(arg0: int): java.util.concurrent.ConcurrentHashMap$KeySetView<K, java.lang.Boolean>
                public keySet(arg0: V): java.util.concurrent.ConcurrentHashMap$KeySetView<K, V>
                public forEach(arg0: long, arg1: java.util.function$.BiConsumer<K, V>): void
                public forEach<U>(arg0: long, arg1: java.util.function$.BiFunction<K, V, U>, arg2: java.util.function$.Consumer$$TypeScript<U>): void
                public search<U>(arg0: long, arg1: java.util.function$.BiFunction<K, V, U>): U
                public reduce<U>(arg0: long, arg1: java.util.function$.BiFunction<K, V, U>, arg2: java.util.function$.BiFunction<U, U, U>): U
                public reduceToDouble<U>(arg0: long, arg1: java.util.function$.ToDoubleBiFunction<K, V> | java.util.function$.ToDoubleBiFunction$$Lambda<K, V>, arg2: double, arg3: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): double
                public reduceToLong<U>(arg0: long, arg1: java.util.function$.ToLongBiFunction<K, V> | java.util.function$.ToLongBiFunction$$Lambda<K, V>, arg2: long, arg3: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                public reduceToInt<U>(arg0: long, arg1: java.util.function$.ToIntBiFunction<K, V> | java.util.function$.ToIntBiFunction$$Lambda<K, V>, arg2: int, arg3: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                public forEachKey<U>(arg0: long, arg1: java.util.function$.Consumer$$TypeScript<K>): void
                public forEachKey<U>(arg0: long, arg1: java.util.function$.Function<K, U>, arg2: java.util.function$.Consumer$$TypeScript<U>): void
                public searchKeys<U>(arg0: long, arg1: java.util.function$.Function<K, U>): U
                public reduceKeys<U>(arg0: long, arg1: java.util.function$.BiFunction<K, K, K>): K
                public reduceKeys<U>(arg0: long, arg1: java.util.function$.Function<K, U>, arg2: java.util.function$.BiFunction<U, U, U>): U
                public reduceKeysToDouble<U>(arg0: long, arg1: java.util.function$.ToDoubleFunction<K> | java.util.function$.ToDoubleFunction$$Lambda<K>, arg2: double, arg3: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): double
                public reduceKeysToLong<U>(arg0: long, arg1: java.util.function$.ToLongFunction<K> | java.util.function$.ToLongFunction$$Lambda<K>, arg2: long, arg3: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                public reduceKeysToInt<U>(arg0: long, arg1: java.util.function$.ToIntFunction<K> | java.util.function$.ToIntFunction$$Lambda<K>, arg2: int, arg3: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                public forEachValue<U>(arg0: long, arg1: java.util.function$.Consumer$$TypeScript<V>): void
                public forEachValue<U>(arg0: long, arg1: java.util.function$.Function<V, U>, arg2: java.util.function$.Consumer$$TypeScript<U>): void
                public searchValues<U>(arg0: long, arg1: java.util.function$.Function<V, U>): U
                public reduceValues<U>(arg0: long, arg1: java.util.function$.BiFunction<V, V, V>): V
                public reduceValues<U>(arg0: long, arg1: java.util.function$.Function<V, U>, arg2: java.util.function$.BiFunction<U, U, U>): U
                public reduceValuesToDouble<U>(arg0: long, arg1: java.util.function$.ToDoubleFunction<V> | java.util.function$.ToDoubleFunction$$Lambda<V>, arg2: double, arg3: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): double
                public reduceValuesToLong<U>(arg0: long, arg1: java.util.function$.ToLongFunction<V> | java.util.function$.ToLongFunction$$Lambda<V>, arg2: long, arg3: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                public reduceValuesToInt<U>(arg0: long, arg1: java.util.function$.ToIntFunction<V> | java.util.function$.ToIntFunction$$Lambda<V>, arg2: int, arg3: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                public forEachEntry<U>(arg0: long, arg1: java.util.function$.Consumer<java.util.Map$Entry<K, V>>): void
                public forEachEntry<U>(arg0: long, arg1: java.util.function$.Function<java.util.Map$Entry<K, V>, U>, arg2: java.util.function$.Consumer$$TypeScript<U>): void
                public searchEntries<U>(arg0: long, arg1: java.util.function$.Function<java.util.Map$Entry<K, V>, U>): U
                public reduceEntries<U>(arg0: long, arg1: java.util.function$.BiFunction<java.util.Map$Entry<K, V>, java.util.Map$Entry<K, V>, java.util.Map$Entry<K, V>>): java.util.Map$Entry<K, V>
                public reduceEntries<U>(arg0: long, arg1: java.util.function$.Function<java.util.Map$Entry<K, V>, U>, arg2: java.util.function$.BiFunction<U, U, U>): U
                public reduceEntriesToDouble<U>(arg0: long, arg1: java.util.function$.ToDoubleFunction<java.util.Map$Entry<K, V>> | java.util.function$.ToDoubleFunction$$Lambda<java.util.Map$Entry<K, V>>, arg2: double, arg3: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): double
                public reduceEntriesToLong<U>(arg0: long, arg1: java.util.function$.ToLongFunction<java.util.Map$Entry<K, V>> | java.util.function$.ToLongFunction$$Lambda<java.util.Map$Entry<K, V>>, arg2: long, arg3: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                public reduceEntriesToInt<U>(arg0: long, arg1: java.util.function$.ToIntFunction<java.util.Map$Entry<K, V>> | java.util.function$.ToIntFunction$$Lambda<java.util.Map$Entry<K, V>>, arg2: int, arg3: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                public keySet<U>(): java.util.Set
                public static class: java.lang.Class<any>
            }
            class ConcurrentLinkedDeque<E> extends java.util.AbstractCollection<E> implements java.util.Deque<E> , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.util.Collection<E>)
                public addFirst(arg0: E): void
                public addLast(arg0: E): void
                public offerFirst(arg0: E): boolean
                public offerLast(arg0: E): boolean
                public peekFirst(): E
                public peekLast(): E
                public getFirst(): E
                public getLast(): E
                public pollFirst(): E
                public pollLast(): E
                public removeFirst(): E
                public removeLast(): E
                public offer(arg0: E): boolean
                public add(arg0: E): boolean
                public poll(): E
                public peek(): E
                public remove(): E
                public pop(): E
                public element(): E
                public push(arg0: E): void
                public removeFirstOccurrence(arg0: java.lang.Object): boolean
                public removeLastOccurrence(arg0: java.lang.Object): boolean
                public contains(arg0: java.lang.Object): boolean
                public isEmpty(): boolean
                public size(): int
                public remove(arg0: java.lang.Object): boolean
                public addAll(arg0: java.util.Collection<E>): boolean
                public clear(): void
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public iterator<T>(): java.util.Iterator<E>
                public descendingIterator<T>(): java.util.Iterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            class ConcurrentLinkedQueue<E> extends java.util.AbstractQueue<E> implements java.util.Queue<E> , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.util.Collection<E>)
                public add(arg0: E): boolean
                public offer(arg0: E): boolean
                public poll(): E
                public peek(): E
                public isEmpty(): boolean
                public size(): int
                public contains(arg0: java.lang.Object): boolean
                public remove(arg0: java.lang.Object): boolean
                public addAll(arg0: java.util.Collection<E>): boolean
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public iterator<T>(): java.util.Iterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            interface ConcurrentMap<K, V> extends java.util.Map<K, V> {
                getOrDefault(arg0: java.lang.Object, arg1: V): V
                forEach(arg0: java.util.function$.BiConsumer<K, V>): void
                putIfAbsent(arg0: K, arg1: V): V
                remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
                replace(arg0: K, arg1: V, arg2: V): boolean
                replace(arg0: K, arg1: V): V
                replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
                computeIfAbsent(arg0: K, arg1: java.util.function$.Function<K, V>): V
                computeIfPresent(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
                compute(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
                merge(arg0: K, arg1: V, arg2: java.util.function$.BiFunction<V, V, V>): V
            }
            interface ConcurrentNavigableMap<K, V> extends java.util.concurrent.ConcurrentMap<K, V> , java.util.NavigableMap<K, V> {
                subMap(arg0: K, arg1: boolean, arg2: K, arg3: boolean): java.util.concurrent.ConcurrentNavigableMap<K, V>
                headMap(arg0: K, arg1: boolean): java.util.concurrent.ConcurrentNavigableMap<K, V>
                tailMap(arg0: K, arg1: boolean): java.util.concurrent.ConcurrentNavigableMap<K, V>
                subMap(arg0: K, arg1: K): java.util.concurrent.ConcurrentNavigableMap<K, V>
                headMap(arg0: K): java.util.concurrent.ConcurrentNavigableMap<K, V>
                tailMap(arg0: K): java.util.concurrent.ConcurrentNavigableMap<K, V>
                descendingMap(): java.util.concurrent.ConcurrentNavigableMap<K, V>
                navigableKeySet(): java.util.NavigableSet<K>
                keySet(): java.util.NavigableSet<K>
                descendingKeySet(): java.util.NavigableSet<K>
                keySet(): java.util.Set
                tailMap(arg0: java.lang.Object): java.util.SortedMap
                headMap(arg0: java.lang.Object): java.util.SortedMap
                subMap(arg0: java.lang.Object, arg1: java.lang.Object): java.util.SortedMap
                tailMap(arg0: java.lang.Object, arg1: boolean): java.util.NavigableMap
                headMap(arg0: java.lang.Object, arg1: boolean): java.util.NavigableMap
                subMap(arg0: java.lang.Object, arg1: boolean, arg2: java.lang.Object, arg3: boolean): java.util.NavigableMap
                descendingMap(): java.util.NavigableMap
            }
            class ConcurrentSkipListMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.concurrent.ConcurrentNavigableMap<K, V> , java.lang.Cloneable , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.util.Comparator<K>)
                public constructor(arg0: java.util.Map<K, V>)
                public constructor(arg0: java.util.SortedMap<K, V>)
                public clone(): java.util.concurrent.ConcurrentSkipListMap<K, V>
                public containsKey(arg0: java.lang.Object): boolean
                public get(arg0: java.lang.Object): V
                public getOrDefault(arg0: java.lang.Object, arg1: V): V
                public put(arg0: K, arg1: V): V
                public remove(arg0: java.lang.Object): V
                public containsValue(arg0: java.lang.Object): boolean
                public size(): int
                public isEmpty(): boolean
                public clear(): void
                public computeIfAbsent(arg0: K, arg1: java.util.function$.Function<K, V>): V
                public computeIfPresent(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
                public compute(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
                public merge(arg0: K, arg1: V, arg2: java.util.function$.BiFunction<V, V, V>): V
                public keySet(): java.util.NavigableSet<K>
                public navigableKeySet(): java.util.NavigableSet<K>
                public values(): java.util.Collection<V>
                public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
                public descendingMap(): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public descendingKeySet(): java.util.NavigableSet<K>
                public equals(arg0: java.lang.Object): boolean
                public putIfAbsent(arg0: K, arg1: V): V
                public remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
                public replace(arg0: K, arg1: V, arg2: V): boolean
                public replace(arg0: K, arg1: V): V
                public comparator(): java.util.Comparator<K>
                public firstKey(): K
                public lastKey(): K
                public subMap(arg0: K, arg1: boolean, arg2: K, arg3: boolean): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public headMap(arg0: K, arg1: boolean): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public tailMap(arg0: K, arg1: boolean): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public subMap(arg0: K, arg1: K): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public headMap(arg0: K): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public tailMap(arg0: K): java.util.concurrent.ConcurrentNavigableMap<K, V>
                public lowerEntry(arg0: K): java.util.Map$Entry<K, V>
                public lowerKey(arg0: K): K
                public floorEntry(arg0: K): java.util.Map$Entry<K, V>
                public floorKey(arg0: K): K
                public ceilingEntry(arg0: K): java.util.Map$Entry<K, V>
                public ceilingKey(arg0: K): K
                public higherEntry(arg0: K): java.util.Map$Entry<K, V>
                public higherKey(arg0: K): K
                public firstEntry(): java.util.Map$Entry<K, V>
                public lastEntry(): java.util.Map$Entry<K, V>
                public pollFirstEntry(): java.util.Map$Entry<K, V>
                public pollLastEntry(): java.util.Map$Entry<K, V>
                public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
                public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
                public clone(): java.lang.Object
                public keySet(): java.util.Set
                public tailMap(arg0: java.lang.Object): java.util.SortedMap
                public headMap(arg0: java.lang.Object): java.util.SortedMap
                public subMap(arg0: java.lang.Object, arg1: java.lang.Object): java.util.SortedMap
                public tailMap(arg0: java.lang.Object, arg1: boolean): java.util.NavigableMap
                public headMap(arg0: java.lang.Object, arg1: boolean): java.util.NavigableMap
                public subMap(arg0: java.lang.Object, arg1: boolean, arg2: java.lang.Object, arg3: boolean): java.util.NavigableMap
                public descendingMap(): java.util.NavigableMap
                public static class: java.lang.Class<any>
            }
            class ConcurrentSkipListSet<E> extends java.util.AbstractSet<E> implements java.util.NavigableSet<E> , java.lang.Cloneable , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.util.Comparator<E>)
                public constructor(arg0: java.util.Collection<E>)
                public constructor(arg0: java.util.SortedSet<E>)
                public clone(): java.util.concurrent.ConcurrentSkipListSet<E>
                public size(): int
                public isEmpty(): boolean
                public contains(arg0: java.lang.Object): boolean
                public add(arg0: E): boolean
                public remove(arg0: java.lang.Object): boolean
                public clear(): void
                public iterator(): java.util.Iterator<E>
                public descendingIterator(): java.util.Iterator<E>
                public equals(arg0: java.lang.Object): boolean
                public removeAll(arg0: java.util.Collection<any>): boolean
                public lower(arg0: E): E
                public floor(arg0: E): E
                public ceiling(arg0: E): E
                public higher(arg0: E): E
                public pollFirst(): E
                public pollLast(): E
                public comparator(): java.util.Comparator<E>
                public first(): E
                public last(): E
                public subSet(arg0: E, arg1: boolean, arg2: E, arg3: boolean): java.util.NavigableSet<E>
                public headSet(arg0: E, arg1: boolean): java.util.NavigableSet<E>
                public tailSet(arg0: E, arg1: boolean): java.util.NavigableSet<E>
                public subSet(arg0: E, arg1: E): java.util.NavigableSet<E>
                public headSet(arg0: E): java.util.NavigableSet<E>
                public tailSet(arg0: E): java.util.NavigableSet<E>
                public descendingSet(): java.util.NavigableSet<E>
                public spliterator(): java.util.Spliterator<E>
                public clone(): java.lang.Object
                public tailSet(arg0: java.lang.Object): java.util.SortedSet
                public headSet(arg0: java.lang.Object): java.util.SortedSet
                public subSet(arg0: java.lang.Object, arg1: java.lang.Object): java.util.SortedSet
                public static class: java.lang.Class<any>
            }
            class CopyOnWriteArrayList<E> implements java.util.List<E> , java.util.RandomAccess , java.lang.Cloneable , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.util.Collection<E>)
                public constructor(arg0: E[])
                public size(): int
                public isEmpty(): boolean
                public contains(arg0: java.lang.Object): boolean
                public indexOf(arg0: java.lang.Object): int
                public indexOf(arg0: E, arg1: int): int
                public lastIndexOf(arg0: java.lang.Object): int
                public lastIndexOf(arg0: E, arg1: int): int
                public clone(): java.lang.Object
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public get<T>(arg0: int): E
                public set<T>(arg0: int, arg1: E): E
                public add<T>(arg0: E): boolean
                public add<T>(arg0: int, arg1: E): void
                public remove<T>(arg0: int): E
                public remove<T>(arg0: java.lang.Object): boolean
                public addIfAbsent<T>(arg0: E): boolean
                public containsAll<T>(arg0: java.util.Collection<any>): boolean
                public removeAll<T>(arg0: java.util.Collection<any>): boolean
                public retainAll<T>(arg0: java.util.Collection<any>): boolean
                public addAllAbsent<T>(arg0: java.util.Collection<E>): int
                public clear<T>(): void
                public addAll<T>(arg0: java.util.Collection<E>): boolean
                public addAll<T>(arg0: int, arg1: java.util.Collection<E>): boolean
                public forEach<T>(arg0: java.util.function$.Consumer$$TypeScript<E>): void
                public removeIf<T>(arg0: java.util.function$.Predicate<E>): boolean
                public replaceAll<T>(arg0: java.util.function$.UnaryOperator<E>): void
                public sort<T>(arg0: java.util.Comparator<E>): void
                public toString<T>(): string
                public equals<T>(arg0: java.lang.Object): boolean
                public hashCode<T>(): int
                public iterator<T>(): java.util.Iterator<E>
                public listIterator<T>(): java.util.ListIterator<E>
                public listIterator<T>(arg0: int): java.util.ListIterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public subList<T>(arg0: int, arg1: int): java.util.List<E>
                public static class: java.lang.Class<any>
            }
            class CopyOnWriteArraySet<E> extends java.util.AbstractSet<E> implements java.io.Serializable {
                public constructor()
                public constructor(arg0: java.util.Collection<E>)
                public size(): int
                public isEmpty(): boolean
                public contains(arg0: java.lang.Object): boolean
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public clear<T>(): void
                public remove<T>(arg0: java.lang.Object): boolean
                public add<T>(arg0: E): boolean
                public containsAll<T>(arg0: java.util.Collection<any>): boolean
                public addAll<T>(arg0: java.util.Collection<E>): boolean
                public removeAll<T>(arg0: java.util.Collection<any>): boolean
                public retainAll<T>(arg0: java.util.Collection<any>): boolean
                public iterator<T>(): java.util.Iterator<E>
                public equals<T>(arg0: java.lang.Object): boolean
                public removeIf<T>(arg0: java.util.function$.Predicate<E>): boolean
                public forEach<T>(arg0: java.util.function$.Consumer$$TypeScript<E>): void
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            class CountDownLatch {
                public constructor(arg0: int)
                public await(): void
                public await(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                public countDown(): void
                public getCount(): long
                public toString(): string
                public static class: java.lang.Class<any>
            }
            abstract class CountedCompleter<T> extends java.util.concurrent.ForkJoinTask<T> {
                protected constructor(arg0: java.util.concurrent.CountedCompleter<any>, arg1: int)
                protected constructor(arg0: java.util.concurrent.CountedCompleter<any>)
                protected constructor()
                public compute(): void
                public onCompletion(arg0: java.util.concurrent.CountedCompleter<any>): void
                public onExceptionalCompletion(arg0: java.lang.Throwable, arg1: java.util.concurrent.CountedCompleter<any>): boolean
                public getCompleter(): java.util.concurrent.CountedCompleter<any>
                public getPendingCount(): int
                public setPendingCount(arg0: int): void
                public addToPendingCount(arg0: int): void
                public compareAndSetPendingCount(arg0: int, arg1: int): boolean
                public decrementPendingCountUnlessZero(): int
                public getRoot(): java.util.concurrent.CountedCompleter<any>
                public tryComplete(): void
                public propagateCompletion(): void
                public complete(arg0: T): void
                public firstComplete(): java.util.concurrent.CountedCompleter<any>
                public nextComplete(): java.util.concurrent.CountedCompleter<any>
                public quietlyCompleteRoot(): void
                public helpComplete(arg0: int): void
                protected exec(): boolean
                public getRawResult(): T
                protected setRawResult(arg0: T): void
                public static class: java.lang.Class<any>
            }
            class CyclicBarrier {
                public constructor(arg0: int, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda)
                public constructor(arg0: int)
                public getParties(): int
                public await(): int
                public await(arg0: long, arg1: java.util.concurrent.TimeUnit): int
                public isBroken(): boolean
                public reset(): void
                public getNumberWaiting(): int
                public static class: java.lang.Class<any>
            }
            class DelayQueue<E extends java.util.concurrent.Delayed> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> {
                public constructor()
                public constructor(arg0: java.util.Collection<E>)
                public add(arg0: E): boolean
                public offer(arg0: E): boolean
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public poll(): E
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public peek(): E
                public size(): int
                public drainTo(arg0: java.util.Collection<E>): int
                public drainTo(arg0: java.util.Collection<E>, arg1: int): int
                public clear(): void
                public remainingCapacity(): int
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public remove<T>(arg0: java.lang.Object): boolean
                public iterator<T>(): java.util.Iterator<E>
                public add<T>(arg0: java.lang.Object): boolean
                public peek<T>(): java.lang.Object
                public poll<T>(): java.lang.Object
                public offer<T>(arg0: java.lang.Object): boolean
                public poll<T>(arg0: long, arg1: java.util.concurrent.TimeUnit): java.lang.Object
                public take<T>(): java.lang.Object
                public offer<T>(arg0: java.lang.Object, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public put<T>(arg0: java.lang.Object): void
                public static class: java.lang.Class<any>
            }
            interface Delayed extends java.lang.Comparable<java.util.concurrent.Delayed> {
                getDelay(arg0: java.util.concurrent.TimeUnit): long
            }
            class Exchanger<V> {
                public constructor()
                public exchange(arg0: V): V
                public exchange(arg0: V, arg1: long, arg2: java.util.concurrent.TimeUnit): V
                public static class: java.lang.Class<any>
            }
            class ExecutionException extends java.lang.Exception {
                protected constructor()
                protected constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            interface Executor {
                execute(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
            }
            interface Executor$$Lambda {
                (arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
            }
            class ExecutorCompletionService<V> implements java.util.concurrent.CompletionService<V> {
                public constructor(arg0: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda)
                public constructor(arg0: java.util.concurrent.Executor | java.util.concurrent.Executor$$Lambda, arg1: java.util.concurrent.BlockingQueue<java.util.concurrent.Future<V>>)
                public submit(arg0: java.util.concurrent.Callable<V> | java.util.concurrent.Callable$$Lambda<V>): java.util.concurrent.Future<V>
                public submit(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: V): java.util.concurrent.Future<V>
                public take(): java.util.concurrent.Future<V>
                public poll(): java.util.concurrent.Future<V>
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): java.util.concurrent.Future<V>
                public static class: java.lang.Class<any>
            }
            interface ExecutorService extends java.util.concurrent.Executor {
                shutdown(): void
                shutdownNow(): java.util.List<java.lang.Runnable>
                isShutdown(): boolean
                isTerminated(): boolean
                awaitTermination(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                submit<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.Future<T>
                submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.Future<T>
                submit(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.Future<any>
                invokeAll<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>): java.util.List<java.util.concurrent.Future<T>>
                invokeAll<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>, arg1: long, arg2: java.util.concurrent.TimeUnit): java.util.List<java.util.concurrent.Future<T>>
                invokeAny<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>): T
                invokeAny<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>, arg1: long, arg2: java.util.concurrent.TimeUnit): T
            }
            class Executors {
                public static newFixedThreadPool(arg0: int): java.util.concurrent.ExecutorService
                public static newWorkStealingPool(arg0: int): java.util.concurrent.ExecutorService
                public static newWorkStealingPool(): java.util.concurrent.ExecutorService
                public static newFixedThreadPool(arg0: int, arg1: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.util.concurrent.ExecutorService
                public static newSingleThreadExecutor(): java.util.concurrent.ExecutorService
                public static newSingleThreadExecutor(arg0: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.util.concurrent.ExecutorService
                public static newCachedThreadPool(): java.util.concurrent.ExecutorService
                public static newCachedThreadPool(arg0: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.util.concurrent.ExecutorService
                public static newSingleThreadScheduledExecutor(): java.util.concurrent.ScheduledExecutorService
                public static newSingleThreadScheduledExecutor(arg0: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.util.concurrent.ScheduledExecutorService
                public static newScheduledThreadPool(arg0: int): java.util.concurrent.ScheduledExecutorService
                public static newScheduledThreadPool(arg0: int, arg1: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): java.util.concurrent.ScheduledExecutorService
                public static unconfigurableExecutorService(arg0: java.util.concurrent.ExecutorService): java.util.concurrent.ExecutorService
                public static unconfigurableScheduledExecutorService(arg0: java.util.concurrent.ScheduledExecutorService): java.util.concurrent.ScheduledExecutorService
                public static defaultThreadFactory(): java.util.concurrent.ThreadFactory
                public static privilegedThreadFactory(): java.util.concurrent.ThreadFactory
                public static callable<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.Callable<T>
                public static callable(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.Callable<java.lang.Object>
                public static callable(arg0: java.security.PrivilegedAction<any> | java.security.PrivilegedAction$$Lambda<any>): java.util.concurrent.Callable<java.lang.Object>
                public static callable(arg0: java.security.PrivilegedExceptionAction<any> | java.security.PrivilegedExceptionAction$$Lambda<any>): java.util.concurrent.Callable<java.lang.Object>
                public static privilegedCallable<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.Callable<T>
                public static privilegedCallableUsingCurrentClassLoader<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.Callable<T>
                public static class: java.lang.Class<any>
            }
            class ForkJoinPool extends java.util.concurrent.AbstractExecutorService {
                public static defaultForkJoinWorkerThreadFactory: java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory, arg2: java.lang.Thread$UncaughtExceptionHandler, arg3: boolean)
                public static commonPool(): java.util.concurrent.ForkJoinPool
                public invoke<T>(arg0: java.util.concurrent.ForkJoinTask<T>): T
                public execute<T>(arg0: java.util.concurrent.ForkJoinTask<any>): void
                public execute<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
                public submit<T>(arg0: java.util.concurrent.ForkJoinTask<T>): java.util.concurrent.ForkJoinTask<T>
                public submit<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.ForkJoinTask<T>
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.ForkJoinTask<T>
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.ForkJoinTask<any>
                public invokeAll<T>(arg0: java.util.Collection<java.util.concurrent.Callable<T>>): java.util.List<java.util.concurrent.Future<T>>
                public getFactory<T>(): java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory
                public getUncaughtExceptionHandler<T>(): java.lang.Thread$UncaughtExceptionHandler
                public getParallelism<T>(): int
                public static getCommonPoolParallelism<T>(): int
                public getPoolSize<T>(): int
                public getAsyncMode<T>(): boolean
                public getRunningThreadCount<T>(): int
                public getActiveThreadCount<T>(): int
                public isQuiescent<T>(): boolean
                public getStealCount<T>(): long
                public getQueuedTaskCount<T>(): long
                public getQueuedSubmissionCount<T>(): int
                public hasQueuedSubmissions<T>(): boolean
                protected pollSubmission<T>(): java.util.concurrent.ForkJoinTask<any>
                protected drainTasksTo<T>(arg0: java.util.Collection<java.util.concurrent.ForkJoinTask<any>>): int
                public toString<T>(): string
                public shutdown<T>(): void
                public shutdownNow<T>(): java.util.List<java.lang.Runnable>
                public isTerminated<T>(): boolean
                public isTerminating<T>(): boolean
                public isShutdown<T>(): boolean
                public awaitTermination<T>(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                public awaitQuiescence<T>(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                public static managedBlock<T>(arg0: java.util.concurrent.ForkJoinPool$ManagedBlocker): void
                protected newTaskFor<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.RunnableFuture<T>
                protected newTaskFor<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.RunnableFuture<T>
                public submit<T>(arg0: java.util.concurrent.Callable | java.util.concurrent.Callable$$Lambda): java.util.concurrent.Future
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.lang.Object): java.util.concurrent.Future
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.Future
                public static class: java.lang.Class<any>
            }
            abstract class ForkJoinTask<V> implements java.util.concurrent.Future<V> , java.io.Serializable {
                public constructor()
                public fork(): java.util.concurrent.ForkJoinTask<V>
                public join(): V
                public invoke(): V
                public static invokeAll(arg0: java.util.concurrent.ForkJoinTask<any>, arg1: java.util.concurrent.ForkJoinTask<any>): void
                public static invokeAll(...arg0: java.util.concurrent.ForkJoinTask<any>[]): void
                public static invokeAll<T extends java.util.concurrent.ForkJoinTask<any>>(arg0: java.util.Collection<T>): java.util.Collection<T>
                public cancel(arg0: boolean): boolean
                public isDone(): boolean
                public isCancelled(): boolean
                public isCompletedAbnormally(): boolean
                public isCompletedNormally(): boolean
                public getException(): java.lang.Throwable
                public completeExceptionally(arg0: java.lang.Throwable): void
                public complete(arg0: V): void
                public quietlyComplete(): void
                public get(): V
                public get(arg0: long, arg1: java.util.concurrent.TimeUnit): V
                public quietlyJoin(): void
                public quietlyInvoke(): void
                public static helpQuiesce(): void
                public reinitialize(): void
                public static getPool(): java.util.concurrent.ForkJoinPool
                public static inForkJoinPool(): boolean
                public tryUnfork(): boolean
                public static getQueuedTaskCount(): int
                public static getSurplusQueuedTaskCount(): int
                public getRawResult(): V
                protected setRawResult(arg0: V): void
                protected exec(): boolean
                protected static peekNextLocalTask(): java.util.concurrent.ForkJoinTask<any>
                protected static pollNextLocalTask(): java.util.concurrent.ForkJoinTask<any>
                protected static pollTask(): java.util.concurrent.ForkJoinTask<any>
                public getForkJoinTaskTag(): short
                public setForkJoinTaskTag(arg0: short): short
                public compareAndSetForkJoinTaskTag(arg0: short, arg1: short): boolean
                public static adapt(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.ForkJoinTask<any>
                public static adapt<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.ForkJoinTask<T>
                public static adapt<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.ForkJoinTask<T>
                public static class: java.lang.Class<any>
            }
            class ForkJoinWorkerThread extends java.lang.Thread {
                protected constructor(arg0: java.util.concurrent.ForkJoinPool)
                public getPool(): java.util.concurrent.ForkJoinPool
                public getPoolIndex(): int
                protected onStart(): void
                protected onTermination(arg0: java.lang.Throwable): void
                public run(): void
                public static class: java.lang.Class<any>
            }
            interface Future<V> {
                cancel(arg0: boolean): boolean
                isCancelled(): boolean
                isDone(): boolean
                get(): V
                get(arg0: long, arg1: java.util.concurrent.TimeUnit): V
            }
            class FutureTask<V> implements java.util.concurrent.RunnableFuture<V> {
                public constructor(arg0: java.util.concurrent.Callable<V> | java.util.concurrent.Callable$$Lambda<V>)
                public constructor(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: V)
                public isCancelled(): boolean
                public isDone(): boolean
                public cancel(arg0: boolean): boolean
                public get(): V
                public get(arg0: long, arg1: java.util.concurrent.TimeUnit): V
                protected done(): void
                protected set(arg0: V): void
                protected setException(arg0: java.lang.Throwable): void
                public run(): void
                protected runAndReset(): boolean
                public static class: java.lang.Class<any>
            }
            class LinkedBlockingDeque<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingDeque<E> , java.io.Serializable {
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: java.util.Collection<E>)
                public addFirst(arg0: E): void
                public addLast(arg0: E): void
                public offerFirst(arg0: E): boolean
                public offerLast(arg0: E): boolean
                public putFirst(arg0: E): void
                public putLast(arg0: E): void
                public offerFirst(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public offerLast(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public removeFirst(): E
                public removeLast(): E
                public pollFirst(): E
                public pollLast(): E
                public takeFirst(): E
                public takeLast(): E
                public pollFirst(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public pollLast(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public getFirst(): E
                public getLast(): E
                public peekFirst(): E
                public peekLast(): E
                public removeFirstOccurrence(arg0: java.lang.Object): boolean
                public removeLastOccurrence(arg0: java.lang.Object): boolean
                public add(arg0: E): boolean
                public offer(arg0: E): boolean
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public remove(): E
                public poll(): E
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public element(): E
                public peek(): E
                public remainingCapacity(): int
                public drainTo(arg0: java.util.Collection<E>): int
                public drainTo(arg0: java.util.Collection<E>, arg1: int): int
                public push(arg0: E): void
                public pop(): E
                public remove(arg0: java.lang.Object): boolean
                public size(): int
                public contains(arg0: java.lang.Object): boolean
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public toString<T>(): string
                public clear<T>(): void
                public iterator<T>(): java.util.Iterator<E>
                public descendingIterator<T>(): java.util.Iterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            class LinkedBlockingQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> , java.io.Serializable {
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: java.util.Collection<E>)
                public size(): int
                public remainingCapacity(): int
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public offer(arg0: E): boolean
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public poll(): E
                public peek(): E
                public remove(arg0: java.lang.Object): boolean
                public contains(arg0: java.lang.Object): boolean
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public toString<T>(): string
                public clear<T>(): void
                public drainTo<T>(arg0: java.util.Collection<E>): int
                public drainTo<T>(arg0: java.util.Collection<E>, arg1: int): int
                public iterator<T>(): java.util.Iterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            class LinkedTransferQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.TransferQueue<E> , java.io.Serializable {
                public spliterator(): java.util.Spliterator<E>
                public constructor()
                public constructor(arg0: java.util.Collection<E>)
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public offer(arg0: E): boolean
                public add(arg0: E): boolean
                public tryTransfer(arg0: E): boolean
                public transfer(arg0: E): void
                public tryTransfer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public poll(): E
                public drainTo(arg0: java.util.Collection<E>): int
                public drainTo(arg0: java.util.Collection<E>, arg1: int): int
                public iterator(): java.util.Iterator<E>
                public peek(): E
                public isEmpty(): boolean
                public hasWaitingConsumer(): boolean
                public size(): int
                public getWaitingConsumerCount(): int
                public remove(arg0: java.lang.Object): boolean
                public contains(arg0: java.lang.Object): boolean
                public remainingCapacity(): int
                public static class: java.lang.Class<any>
            }
            class Phaser {
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: java.util.concurrent.Phaser)
                public constructor(arg0: java.util.concurrent.Phaser, arg1: int)
                public register(): int
                public bulkRegister(arg0: int): int
                public arrive(): int
                public arriveAndDeregister(): int
                public arriveAndAwaitAdvance(): int
                public awaitAdvance(arg0: int): int
                public awaitAdvanceInterruptibly(arg0: int): int
                public awaitAdvanceInterruptibly(arg0: int, arg1: long, arg2: java.util.concurrent.TimeUnit): int
                public forceTermination(): void
                public getPhase(): int
                public getRegisteredParties(): int
                public getArrivedParties(): int
                public getUnarrivedParties(): int
                public getParent(): java.util.concurrent.Phaser
                public getRoot(): java.util.concurrent.Phaser
                public isTerminated(): boolean
                protected onAdvance(arg0: int, arg1: int): boolean
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PriorityBlockingQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> , java.io.Serializable {
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: java.util.Comparator<E>)
                public constructor(arg0: java.util.Collection<E>)
                public add(arg0: E): boolean
                public offer(arg0: E): boolean
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public poll(): E
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public peek(): E
                public comparator(): java.util.Comparator<E>
                public size(): int
                public remainingCapacity(): int
                public remove(arg0: java.lang.Object): boolean
                public contains(arg0: java.lang.Object): boolean
                public toArray(): java.lang.Object[]
                public toString(): string
                public drainTo(arg0: java.util.Collection<E>): int
                public drainTo(arg0: java.util.Collection<E>, arg1: int): int
                public clear(): void
                public toArray<T>(arg0: T[]): T[]
                public iterator<T>(): java.util.Iterator<E>
                public spliterator<T>(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            abstract class RecursiveAction extends java.util.concurrent.ForkJoinTask<java.lang.Void> {
                public constructor()
                protected compute(): void
                public getRawResult(): java.lang.Void
                protected setRawResult(arg0: java.lang.Void): void
                protected exec(): boolean
                protected setRawResult(arg0: java.lang.Object): void
                public getRawResult(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class RecursiveTask<V> extends java.util.concurrent.ForkJoinTask<V> {
                public constructor()
                protected compute(): V
                public getRawResult(): V
                protected setRawResult(arg0: V): void
                protected exec(): boolean
                public static class: java.lang.Class<any>
            }
            class RejectedExecutionException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            interface RejectedExecutionHandler {
                rejectedExecution(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.ThreadPoolExecutor): void
            }
            interface RejectedExecutionHandler$$Lambda {
                (arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.ThreadPoolExecutor): void
            }
            interface RunnableFuture<V> extends java.lang.Runnable , java.util.concurrent.Future<V> {
                run(): void
            }
            interface RunnableScheduledFuture<V> extends java.util.concurrent.RunnableFuture<V> , java.util.concurrent.ScheduledFuture<V> {
                isPeriodic(): boolean
            }
            interface ScheduledExecutorService extends java.util.concurrent.ExecutorService {
                schedule(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: long, arg2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<any>
                schedule<V>(arg0: java.util.concurrent.Callable<V> | java.util.concurrent.Callable$$Lambda<V>, arg1: long, arg2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<V>
                scheduleAtFixedRate(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: long, arg2: long, arg3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<any>
                scheduleWithFixedDelay(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: long, arg2: long, arg3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<any>
            }
            interface ScheduledFuture<V> extends java.util.concurrent.Delayed , java.util.concurrent.Future<V> {
            }
            class ScheduledThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor implements java.util.concurrent.ScheduledExecutorService {
                protected decorateTask<V>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.util.concurrent.RunnableScheduledFuture<V>): java.util.concurrent.RunnableScheduledFuture<V>
                protected decorateTask<V>(arg0: java.util.concurrent.Callable<V> | java.util.concurrent.Callable$$Lambda<V>, arg1: java.util.concurrent.RunnableScheduledFuture<V>): java.util.concurrent.RunnableScheduledFuture<V>
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda)
                public constructor(arg0: int, arg1: java.util.concurrent.RejectedExecutionHandler | java.util.concurrent.RejectedExecutionHandler$$Lambda)
                public constructor(arg0: int, arg1: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda, arg2: java.util.concurrent.RejectedExecutionHandler | java.util.concurrent.RejectedExecutionHandler$$Lambda)
                public schedule<V>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: long, arg2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<any>
                public schedule<V>(arg0: java.util.concurrent.Callable<V> | java.util.concurrent.Callable$$Lambda<V>, arg1: long, arg2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<V>
                public scheduleAtFixedRate<V>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: long, arg2: long, arg3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<any>
                public scheduleWithFixedDelay<V>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: long, arg2: long, arg3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture<any>
                public execute<V>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
                public submit<V>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.util.concurrent.Future<any>
                public submit<T>(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: T): java.util.concurrent.Future<T>
                public submit<T>(arg0: java.util.concurrent.Callable<T> | java.util.concurrent.Callable$$Lambda<T>): java.util.concurrent.Future<T>
                public setContinueExistingPeriodicTasksAfterShutdownPolicy<T>(arg0: boolean): void
                public getContinueExistingPeriodicTasksAfterShutdownPolicy<T>(): boolean
                public setExecuteExistingDelayedTasksAfterShutdownPolicy<T>(arg0: boolean): void
                public getExecuteExistingDelayedTasksAfterShutdownPolicy<T>(): boolean
                public setRemoveOnCancelPolicy<T>(arg0: boolean): void
                public getRemoveOnCancelPolicy<T>(): boolean
                public shutdown<T>(): void
                public shutdownNow<T>(): java.util.List<java.lang.Runnable>
                public getQueue<T>(): java.util.concurrent.BlockingQueue<java.lang.Runnable>
                public static class: java.lang.Class<any>
            }
            class Semaphore implements java.io.Serializable {
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: boolean)
                public acquire(): void
                public acquireUninterruptibly(): void
                public tryAcquire(): boolean
                public tryAcquire(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                public release(): void
                public acquire(arg0: int): void
                public acquireUninterruptibly(arg0: int): void
                public tryAcquire(arg0: int): boolean
                public tryAcquire(arg0: int, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public release(arg0: int): void
                public availablePermits(): int
                public drainPermits(): int
                protected reducePermits(arg0: int): void
                public isFair(): boolean
                public hasQueuedThreads(): boolean
                public getQueueLength(): int
                protected getQueuedThreads(): java.util.Collection<java.lang.Thread>
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SynchronousQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> , java.io.Serializable {
                public constructor()
                public constructor(arg0: boolean)
                public put(arg0: E): void
                public offer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                public offer(arg0: E): boolean
                public take(): E
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): E
                public poll(): E
                public isEmpty(): boolean
                public size(): int
                public remainingCapacity(): int
                public clear(): void
                public contains(arg0: java.lang.Object): boolean
                public remove(arg0: java.lang.Object): boolean
                public containsAll(arg0: java.util.Collection<any>): boolean
                public removeAll(arg0: java.util.Collection<any>): boolean
                public retainAll(arg0: java.util.Collection<any>): boolean
                public peek(): E
                public iterator(): java.util.Iterator<E>
                public spliterator(): java.util.Spliterator<E>
                public toArray(): java.lang.Object[]
                public toArray<T>(arg0: T[]): T[]
                public drainTo<T>(arg0: java.util.Collection<E>): int
                public drainTo<T>(arg0: java.util.Collection<E>, arg1: int): int
                public static class: java.lang.Class<any>
            }
            interface ThreadFactory {
                newThread(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.lang.Thread
            }
            interface ThreadFactory$$Lambda {
                (arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): java.lang.Thread
            }
            class ThreadLocalRandom extends java.util.Random {
                public static current(): java.util.concurrent.ThreadLocalRandom
                public setSeed(arg0: long): void
                protected next(arg0: int): int
                public nextInt(): int
                public nextInt(arg0: int): int
                public nextInt(arg0: int, arg1: int): int
                public nextLong(): long
                public nextLong(arg0: long): long
                public nextLong(arg0: long, arg1: long): long
                public nextDouble(): double
                public nextDouble(arg0: double): double
                public nextDouble(arg0: double, arg1: double): double
                public nextBoolean(): boolean
                public nextFloat(): float
                public nextGaussian(): double
                public ints(arg0: long): java.util.stream.IntStream
                public ints(): java.util.stream.IntStream
                public ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream
                public ints(arg0: int, arg1: int): java.util.stream.IntStream
                public longs(arg0: long): java.util.stream.LongStream
                public longs(): java.util.stream.LongStream
                public longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream
                public longs(arg0: long, arg1: long): java.util.stream.LongStream
                public doubles(arg0: long): java.util.stream.DoubleStream
                public doubles(): java.util.stream.DoubleStream
                public doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream
                public doubles(arg0: double, arg1: double): java.util.stream.DoubleStream
                public static class: java.lang.Class<any>
            }
            class ThreadPoolExecutor extends java.util.concurrent.AbstractExecutorService {
                public constructor(arg0: int, arg1: int, arg2: long, arg3: java.util.concurrent.TimeUnit, arg4: java.util.concurrent.BlockingQueue<java.lang.Runnable>)
                public constructor(arg0: int, arg1: int, arg2: long, arg3: java.util.concurrent.TimeUnit, arg4: java.util.concurrent.BlockingQueue<java.lang.Runnable>, arg5: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda)
                public constructor(arg0: int, arg1: int, arg2: long, arg3: java.util.concurrent.TimeUnit, arg4: java.util.concurrent.BlockingQueue<java.lang.Runnable>, arg5: java.util.concurrent.RejectedExecutionHandler | java.util.concurrent.RejectedExecutionHandler$$Lambda)
                public constructor(arg0: int, arg1: int, arg2: long, arg3: java.util.concurrent.TimeUnit, arg4: java.util.concurrent.BlockingQueue<java.lang.Runnable>, arg5: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda, arg6: java.util.concurrent.RejectedExecutionHandler | java.util.concurrent.RejectedExecutionHandler$$Lambda)
                public execute(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
                public shutdown(): void
                public shutdownNow(): java.util.List<java.lang.Runnable>
                public isShutdown(): boolean
                public isTerminating(): boolean
                public isTerminated(): boolean
                public awaitTermination(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                protected finalize(): void
                public setThreadFactory(arg0: java.util.concurrent.ThreadFactory | java.util.concurrent.ThreadFactory$$Lambda): void
                public getThreadFactory(): java.util.concurrent.ThreadFactory
                public setRejectedExecutionHandler(arg0: java.util.concurrent.RejectedExecutionHandler | java.util.concurrent.RejectedExecutionHandler$$Lambda): void
                public getRejectedExecutionHandler(): java.util.concurrent.RejectedExecutionHandler
                public setCorePoolSize(arg0: int): void
                public getCorePoolSize(): int
                public prestartCoreThread(): boolean
                public prestartAllCoreThreads(): int
                public allowsCoreThreadTimeOut(): boolean
                public allowCoreThreadTimeOut(arg0: boolean): void
                public setMaximumPoolSize(arg0: int): void
                public getMaximumPoolSize(): int
                public setKeepAliveTime(arg0: long, arg1: java.util.concurrent.TimeUnit): void
                public getKeepAliveTime(arg0: java.util.concurrent.TimeUnit): long
                public getQueue(): java.util.concurrent.BlockingQueue<java.lang.Runnable>
                public remove(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): boolean
                public purge(): void
                public getPoolSize(): int
                public getActiveCount(): int
                public getLargestPoolSize(): int
                public getTaskCount(): long
                public getCompletedTaskCount(): long
                public toString(): string
                protected beforeExecute(arg0: java.lang.Thread | java.lang.Thread$$Lambda, arg1: java.lang.Runnable | java.lang.Runnable$$Lambda): void
                protected afterExecute(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda, arg1: java.lang.Throwable): void
                protected terminated(): void
                public static class: java.lang.Class<any>
            }
            abstract class TimeUnit extends java.lang.Enum<java.util.concurrent.TimeUnit> {
                public static NANOSECONDS: java.util.concurrent.TimeUnit
                public static MICROSECONDS: java.util.concurrent.TimeUnit
                public static MILLISECONDS: java.util.concurrent.TimeUnit
                public static SECONDS: java.util.concurrent.TimeUnit
                public static MINUTES: java.util.concurrent.TimeUnit
                public static HOURS: java.util.concurrent.TimeUnit
                public static DAYS: java.util.concurrent.TimeUnit
                public static values(): java.util.concurrent.TimeUnit[]
                public static valueOf(arg0: java.lang.String | string): java.util.concurrent.TimeUnit
                public convert(arg0: long, arg1: java.util.concurrent.TimeUnit): long
                public toNanos(arg0: long): long
                public toMicros(arg0: long): long
                public toMillis(arg0: long): long
                public toSeconds(arg0: long): long
                public toMinutes(arg0: long): long
                public toHours(arg0: long): long
                public toDays(arg0: long): long
                public timedWait(arg0: java.lang.Object, arg1: long): void
                public timedJoin(arg0: java.lang.Thread | java.lang.Thread$$Lambda, arg1: long): void
                public sleep(arg0: long): void
                public static class: java.lang.Class<any>
            }
            class TimeoutException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface TransferQueue<E> extends java.util.concurrent.BlockingQueue<E> {
                tryTransfer(arg0: E): boolean
                transfer(arg0: E): void
                tryTransfer(arg0: E, arg1: long, arg2: java.util.concurrent.TimeUnit): boolean
                hasWaitingConsumer(): boolean
                getWaitingConsumerCount(): int
            }
        }
        namespace function$ {
            interface BiConsumer<T, U> {
                accept(arg0: T, arg1: U): void
                andThen(arg0: java.util.function$.BiConsumer<T, U>): java.util.function$.BiConsumer<T, U>
            }
            interface BiFunction<T, U, R> {
                apply(arg0: T, arg1: U): R
                andThen<V>(arg0: java.util.function$.Function<R, V>): java.util.function$.BiFunction<T, U, V>
            }
            interface BiPredicate<T, U> {
                test(arg0: T, arg1: U): boolean
                and(arg0: java.util.function$.BiPredicate<T, U>): java.util.function$.BiPredicate<T, U>
                negate(): java.util.function$.BiPredicate<T, U>
                or(arg0: java.util.function$.BiPredicate<T, U>): java.util.function$.BiPredicate<T, U>
            }
            interface BinaryOperator<T> extends java.util.function$.BiFunction<T, T, T> {
                minBy<T>(arg0: java.util.Comparator<T>): java.util.function$.BinaryOperator<T>
                maxBy<T>(arg0: java.util.Comparator<T>): java.util.function$.BinaryOperator<T>
            }
            interface BooleanSupplier {
                getAsBoolean(): boolean
            }
            interface BooleanSupplier$$Lambda {
                (): boolean
            }
            interface Consumer<T> {
                accept(arg0: T): void
                andThen(arg0: java.util.function$.Consumer$$TypeScript<T>): java.util.function$.Consumer<T>
            }
            interface DoubleBinaryOperator {
                applyAsDouble(arg0: double, arg1: double): double
            }
            interface DoubleBinaryOperator$$Lambda {
                (arg0: double, arg1: double): double
            }
            interface DoubleConsumer {
                accept(arg0: double): void
                andThen(arg0: java.util.function$.DoubleConsumer): java.util.function$.DoubleConsumer
            }
            interface DoubleFunction<R> {
                apply(arg0: double): R
            }
            interface DoubleFunction$$Lambda<R> {
                (arg0: double): R
            }
            interface DoublePredicate {
                test(arg0: double): boolean
                and(arg0: java.util.function$.DoublePredicate): java.util.function$.DoublePredicate
                negate(): java.util.function$.DoublePredicate
                or(arg0: java.util.function$.DoublePredicate): java.util.function$.DoublePredicate
            }
            interface DoubleSupplier {
                getAsDouble(): double
            }
            interface DoubleSupplier$$Lambda {
                (): double
            }
            interface DoubleToIntFunction {
                applyAsInt(arg0: double): int
            }
            interface DoubleToIntFunction$$Lambda {
                (arg0: double): int
            }
            interface DoubleToLongFunction {
                applyAsLong(arg0: double): long
            }
            interface DoubleToLongFunction$$Lambda {
                (arg0: double): long
            }
            interface DoubleUnaryOperator {
                applyAsDouble(arg0: double): double
                compose(arg0: java.util.function$.DoubleUnaryOperator): java.util.function$.DoubleUnaryOperator
                andThen(arg0: java.util.function$.DoubleUnaryOperator): java.util.function$.DoubleUnaryOperator
                identity(): java.util.function$.DoubleUnaryOperator
            }
            interface Function<T, R> {
                apply(arg0: T): R
                compose<V>(arg0: java.util.function$.Function<V, T>): java.util.function$.Function<V, R>
                andThen<V>(arg0: java.util.function$.Function<R, V>): java.util.function$.Function<T, V>
                identity<T>(): java.util.function$.Function<T, T>
            }
            interface IntBinaryOperator {
                applyAsInt(arg0: int, arg1: int): int
            }
            interface IntBinaryOperator$$Lambda {
                (arg0: int, arg1: int): int
            }
            interface IntConsumer {
                accept(arg0: int): void
                andThen(arg0: java.util.function$.IntConsumer): java.util.function$.IntConsumer
            }
            interface IntFunction<R> {
                apply(arg0: int): R
            }
            interface IntFunction$$Lambda<R> {
                (arg0: int): R
            }
            interface IntPredicate {
                test(arg0: int): boolean
                and(arg0: java.util.function$.IntPredicate): java.util.function$.IntPredicate
                negate(): java.util.function$.IntPredicate
                or(arg0: java.util.function$.IntPredicate): java.util.function$.IntPredicate
            }
            interface IntSupplier {
                getAsInt(): int
            }
            interface IntSupplier$$Lambda {
                (): int
            }
            interface IntToDoubleFunction {
                applyAsDouble(arg0: int): double
            }
            interface IntToDoubleFunction$$Lambda {
                (arg0: int): double
            }
            interface IntToLongFunction {
                applyAsLong(arg0: int): long
            }
            interface IntToLongFunction$$Lambda {
                (arg0: int): long
            }
            interface IntUnaryOperator {
                applyAsInt(arg0: int): int
                compose(arg0: java.util.function$.IntUnaryOperator): java.util.function$.IntUnaryOperator
                andThen(arg0: java.util.function$.IntUnaryOperator): java.util.function$.IntUnaryOperator
                identity(): java.util.function$.IntUnaryOperator
            }
            interface LongBinaryOperator {
                applyAsLong(arg0: long, arg1: long): long
            }
            interface LongBinaryOperator$$Lambda {
                (arg0: long, arg1: long): long
            }
            interface LongConsumer {
                accept(arg0: long): void
                andThen(arg0: java.util.function$.LongConsumer): java.util.function$.LongConsumer
            }
            interface LongFunction<R> {
                apply(arg0: long): R
            }
            interface LongFunction$$Lambda<R> {
                (arg0: long): R
            }
            interface LongPredicate {
                test(arg0: long): boolean
                and(arg0: java.util.function$.LongPredicate): java.util.function$.LongPredicate
                negate(): java.util.function$.LongPredicate
                or(arg0: java.util.function$.LongPredicate): java.util.function$.LongPredicate
            }
            interface LongSupplier {
                getAsLong(): long
            }
            interface LongSupplier$$Lambda {
                (): long
            }
            interface LongToDoubleFunction {
                applyAsDouble(arg0: long): double
            }
            interface LongToDoubleFunction$$Lambda {
                (arg0: long): double
            }
            interface LongToIntFunction {
                applyAsInt(arg0: long): int
            }
            interface LongToIntFunction$$Lambda {
                (arg0: long): int
            }
            interface LongUnaryOperator {
                applyAsLong(arg0: long): long
                compose(arg0: java.util.function$.LongUnaryOperator): java.util.function$.LongUnaryOperator
                andThen(arg0: java.util.function$.LongUnaryOperator): java.util.function$.LongUnaryOperator
                identity(): java.util.function$.LongUnaryOperator
            }
            interface ObjDoubleConsumer<T> {
                accept(arg0: T, arg1: double): void
            }
            interface ObjDoubleConsumer$$Lambda<T> {
                (arg0: T, arg1: double): void
            }
            interface ObjIntConsumer<T> {
                accept(arg0: T, arg1: int): void
            }
            interface ObjIntConsumer$$Lambda<T> {
                (arg0: T, arg1: int): void
            }
            interface ObjLongConsumer<T> {
                accept(arg0: T, arg1: long): void
            }
            interface ObjLongConsumer$$Lambda<T> {
                (arg0: T, arg1: long): void
            }
            interface Predicate<T> {
                test(arg0: T): boolean
                and(arg0: java.util.function$.Predicate<T>): java.util.function$.Predicate<T>
                negate(): java.util.function$.Predicate<T>
                or(arg0: java.util.function$.Predicate<T>): java.util.function$.Predicate<T>
                isEqual<T>(arg0: java.lang.Object): java.util.function$.Predicate<T>
            }
            interface Supplier<T> {
                get(): T
            }
            interface Supplier$$Lambda<T> {
                (): T
            }
            interface ToDoubleBiFunction<T, U> {
                applyAsDouble(arg0: T, arg1: U): double
            }
            interface ToDoubleBiFunction$$Lambda<T, U> {
                (arg0: T, arg1: U): double
            }
            interface ToDoubleFunction<T> {
                applyAsDouble(arg0: T): double
            }
            interface ToDoubleFunction$$Lambda<T> {
                (arg0: T): double
            }
            interface ToIntBiFunction<T, U> {
                applyAsInt(arg0: T, arg1: U): int
            }
            interface ToIntBiFunction$$Lambda<T, U> {
                (arg0: T, arg1: U): int
            }
            interface ToIntFunction<T> {
                applyAsInt(arg0: T): int
            }
            interface ToIntFunction$$Lambda<T> {
                (arg0: T): int
            }
            interface ToLongBiFunction<T, U> {
                applyAsLong(arg0: T, arg1: U): long
            }
            interface ToLongBiFunction$$Lambda<T, U> {
                (arg0: T, arg1: U): long
            }
            interface ToLongFunction<T> {
                applyAsLong(arg0: T): long
            }
            interface ToLongFunction$$Lambda<T> {
                (arg0: T): long
            }
            interface UnaryOperator<T> extends java.util.function$.Function<T, T> {
                identity<T>(): java.util.function$.UnaryOperator<T>
            }
        }
        namespace jar {
            class Attributes implements java.util.Map<java.lang.Object, java.lang.Object> , java.lang.Cloneable {
                protected map: java.util.Map<java.lang.Object, java.lang.Object>
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: java.util.jar.Attributes)
                public get(arg0: java.lang.Object): java.lang.Object
                public getValue(arg0: java.lang.String | string): string
                public getValue(arg0: java.util.jar.Attributes$Name): string
                public put(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
                public putValue(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                public remove(arg0: java.lang.Object): java.lang.Object
                public containsValue(arg0: java.lang.Object): boolean
                public containsKey(arg0: java.lang.Object): boolean
                public putAll(arg0: java.util.Map<any, any>): void
                public clear(): void
                public size(): int
                public isEmpty(): boolean
                public keySet(): java.util.Set<java.lang.Object>
                public values(): java.util.Collection<java.lang.Object>
                public entrySet(): java.util.Set<java.util.Map$Entry<java.lang.Object, java.lang.Object>>
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class JarEntry extends java.util.zip.ZipEntry {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.util.zip.ZipEntry)
                public constructor(arg0: java.util.jar.JarEntry)
                public getAttributes(): java.util.jar.Attributes
                public getCertificates(): java.security.cert.Certificate[]
                public getCodeSigners(): java.security.CodeSigner[]
                public static class: java.lang.Class<any>
            }
            class JarException extends java.util.zip.ZipException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class JarFile extends java.util.zip.ZipFile {
                public static MANIFEST_NAME: string
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: boolean)
                public constructor(arg0: java.io.File)
                public constructor(arg0: java.io.File, arg1: boolean)
                public constructor(arg0: java.io.File, arg1: boolean, arg2: int)
                public getManifest(): java.util.jar.Manifest
                public getJarEntry(arg0: java.lang.String | string): java.util.jar.JarEntry
                public getEntry(arg0: java.lang.String | string): java.util.zip.ZipEntry
                public entries(): java.util.Enumeration<java.util.jar.JarEntry>
                public stream(): java.util.stream.Stream<java.util.jar.JarEntry>
                public getInputStream(arg0: java.util.zip.ZipEntry): java.io.InputStream
                public static class: java.lang.Class<any>
            }
            class JarInputStream extends java.util.zip.ZipInputStream {
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: java.io.InputStream, arg1: boolean)
                public getManifest(): java.util.jar.Manifest
                public getNextEntry(): java.util.zip.ZipEntry
                public getNextJarEntry(): java.util.jar.JarEntry
                public read(arg0: byte[], arg1: int, arg2: int): int
                protected createZipEntry(arg0: java.lang.String | string): java.util.zip.ZipEntry
                public static class: java.lang.Class<any>
            }
            class JarOutputStream extends java.util.zip.ZipOutputStream {
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.jar.Manifest)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
                public putNextEntry(arg0: java.util.zip.ZipEntry): void
                public static class: java.lang.Class<any>
            }
            class JarVerifier {
                public constructor(arg0: byte[])
                public beginEntry(arg0: java.util.jar.JarEntry, arg1: sun.security.util.ManifestEntryVerifier): void
                public update(arg0: int, arg1: sun.security.util.ManifestEntryVerifier): void
                public update(arg0: int, arg1: byte[], arg2: int, arg3: int, arg4: sun.security.util.ManifestEntryVerifier): void
                public getCerts(arg0: java.lang.String | string): java.security.cert.Certificate[]
                public getCerts(arg0: java.util.jar.JarFile, arg1: java.util.jar.JarEntry): java.security.cert.Certificate[]
                public getCodeSigners(arg0: java.lang.String | string): java.security.CodeSigner[]
                public getCodeSigners(arg0: java.util.jar.JarFile, arg1: java.util.jar.JarEntry): java.security.CodeSigner[]
                public entryNames(arg0: java.util.jar.JarFile, arg1: java.security.CodeSource[]): java.util.Enumeration<java.lang.String>
                public entries2(arg0: java.util.jar.JarFile, arg1: java.util.Enumeration<java.util.zip.ZipEntry>): java.util.Enumeration<java.util.jar.JarEntry>
                public getCodeSources(arg0: java.util.jar.JarFile, arg1: java.net.URL): java.security.CodeSource[]
                public getCodeSource(arg0: java.net.URL, arg1: java.lang.String | string): java.security.CodeSource
                public getCodeSource(arg0: java.net.URL, arg1: java.util.jar.JarFile, arg2: java.util.jar.JarEntry): java.security.CodeSource
                public setEagerValidation(arg0: boolean): void
                public getManifestDigests(): java.util.List<java.lang.Object>
                public static class: java.lang.Class<any>
            }
            class JavaUtilJarAccessImpl implements sun.misc.JavaUtilJarAccess {
                public jarFileHasClassPathAttribute(arg0: java.util.jar.JarFile): boolean
                public getCodeSources(arg0: java.util.jar.JarFile, arg1: java.net.URL): java.security.CodeSource[]
                public getCodeSource(arg0: java.util.jar.JarFile, arg1: java.net.URL, arg2: java.lang.String | string): java.security.CodeSource
                public entryNames(arg0: java.util.jar.JarFile, arg1: java.security.CodeSource[]): java.util.Enumeration<java.lang.String>
                public entries2(arg0: java.util.jar.JarFile): java.util.Enumeration<java.util.jar.JarEntry>
                public setEagerValidation(arg0: java.util.jar.JarFile, arg1: boolean): void
                public getManifestDigests(arg0: java.util.jar.JarFile): java.util.List<java.lang.Object>
                public static class: java.lang.Class<any>
            }
            class Manifest implements java.lang.Cloneable {
                public constructor()
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: java.util.jar.Manifest)
                public getMainAttributes(): java.util.jar.Attributes
                public getEntries(): java.util.Map<java.lang.String, java.util.jar.Attributes>
                public getAttributes(arg0: java.lang.String | string): java.util.jar.Attributes
                public clear(): void
                public write(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public read(arg0: java.io.InputStream): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class Pack200 {
                public static newPacker(): java.util.jar.Pack200$Packer
                public static newUnpacker(): java.util.jar.Pack200$Unpacker
                public static class: java.lang.Class<any>
            }
        }
        namespace regex {
            class ASCII {
                public static class: java.lang.Class<any>
            }
            interface MatchResult {
                start(): int
                start(arg0: int): int
                end(): int
                end(arg0: int): int
                group(): string
                group(arg0: int): string
                groupCount(): int
            }
            class Matcher implements java.util.regex.MatchResult {
                public pattern(): java.util.regex.Pattern
                public toMatchResult(): java.util.regex.MatchResult
                public usePattern(arg0: java.util.regex.Pattern): java.util.regex.Matcher
                public reset(): java.util.regex.Matcher
                public reset(arg0: java.lang.CharSequence): java.util.regex.Matcher
                public start(): int
                public start(arg0: int): int
                public start(arg0: java.lang.String | string): int
                public end(): int
                public end(arg0: int): int
                public end(arg0: java.lang.String | string): int
                public group(): string
                public group(arg0: int): string
                public group(arg0: java.lang.String | string): string
                public groupCount(): int
                public matches(): boolean
                public find(): boolean
                public find(arg0: int): boolean
                public lookingAt(): boolean
                public static quoteReplacement(arg0: java.lang.String | string): string
                public appendReplacement(arg0: java.lang.StringBuffer, arg1: java.lang.String | string): java.util.regex.Matcher
                public appendTail(arg0: java.lang.StringBuffer): java.lang.StringBuffer
                public replaceAll(arg0: java.lang.String | string): string
                public replaceFirst(arg0: java.lang.String | string): string
                public region(arg0: int, arg1: int): java.util.regex.Matcher
                public regionStart(): int
                public regionEnd(): int
                public hasTransparentBounds(): boolean
                public useTransparentBounds(arg0: boolean): java.util.regex.Matcher
                public hasAnchoringBounds(): boolean
                public useAnchoringBounds(arg0: boolean): java.util.regex.Matcher
                public toString(): string
                public hitEnd(): boolean
                public requireEnd(): boolean
                public static class: java.lang.Class<any>
            }
            class Pattern implements java.io.Serializable {
                public static UNIX_LINES: int
                public static CASE_INSENSITIVE: int
                public static COMMENTS: int
                public static MULTILINE: int
                public static LITERAL: int
                public static DOTALL: int
                public static UNICODE_CASE: int
                public static CANON_EQ: int
                public static UNICODE_CHARACTER_CLASS: int
                public static compile(arg0: java.lang.String | string): java.util.regex.Pattern
                public static compile(arg0: java.lang.String | string, arg1: int): java.util.regex.Pattern
                public pattern(): string
                public toString(): string
                public matcher(arg0: java.lang.CharSequence): java.util.regex.Matcher
                public flags(): int
                public static matches(arg0: java.lang.String | string, arg1: java.lang.CharSequence): boolean
                public split(arg0: java.lang.CharSequence, arg1: int): java.lang.String[]
                public split(arg0: java.lang.CharSequence): java.lang.String[]
                public static quote(arg0: java.lang.String | string): string
                public asPredicate(): java.util.function$.Predicate<java.lang.String>
                public splitAsStream(arg0: java.lang.CharSequence): java.util.stream.Stream<java.lang.String>
                public static class: java.lang.Class<any>
            }
            class PatternSyntaxException extends java.lang.IllegalArgumentException {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: int)
                public getIndex(): int
                public getDescription(): string
                public getPattern(): string
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
        }
        namespace spi {
            abstract class CalendarDataProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getFirstDayOfWeek(arg0: java.util.Locale): int
                public getMinimalDaysInFirstWeek(arg0: java.util.Locale): int
                public static class: java.lang.Class<any>
            }
            abstract class CalendarNameProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getDisplayName(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int, arg4: java.util.Locale): string
                public getDisplayNames(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
                public static class: java.lang.Class<any>
            }
            abstract class CurrencyNameProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getSymbol(arg0: java.lang.String | string, arg1: java.util.Locale): string
                public getDisplayName(arg0: java.lang.String | string, arg1: java.util.Locale): string
                public static class: java.lang.Class<any>
            }
            abstract class LocaleNameProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getDisplayLanguage(arg0: java.lang.String | string, arg1: java.util.Locale): string
                public getDisplayScript(arg0: java.lang.String | string, arg1: java.util.Locale): string
                public getDisplayCountry(arg0: java.lang.String | string, arg1: java.util.Locale): string
                public getDisplayVariant(arg0: java.lang.String | string, arg1: java.util.Locale): string
                public static class: java.lang.Class<any>
            }
            abstract class LocaleServiceProvider {
                protected constructor()
                public getAvailableLocales(): java.util.Locale[]
                public isSupportedLocale(arg0: java.util.Locale): boolean
                public static class: java.lang.Class<any>
            }
            interface ResourceBundleControlProvider {
                getControl(arg0: java.lang.String | string): java.util.ResourceBundle$Control
            }
            interface ResourceBundleControlProvider$$Lambda {
                (arg0: java.lang.String | string): java.util.ResourceBundle$Control
            }
            abstract class TimeZoneNameProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getDisplayName(arg0: java.lang.String | string, arg1: boolean, arg2: int, arg3: java.util.Locale): string
                public getGenericDisplayName(arg0: java.lang.String | string, arg1: int, arg2: java.util.Locale): string
                public static class: java.lang.Class<any>
            }
        }
        namespace stream {
            abstract class AbstractPipeline<E_IN, E_OUT, S extends java.util.stream.BaseStream<E_OUT, S>> extends java.util.stream.PipelineHelper<E_OUT> implements java.util.stream.BaseStream<E_OUT, S> {
                protected sourceOrOpFlags: int
                public sequential(): S
                public parallel(): S
                public close(): void
                public onClose(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): S
                public spliterator(): java.util.Spliterator<E_OUT>
                public isParallel(): boolean
                public static class: java.lang.Class<any>
            }
            abstract class AbstractShortCircuitTask<P_IN, P_OUT, R, K extends java.util.stream.AbstractShortCircuitTask<P_IN, P_OUT, R, K>> extends java.util.stream.AbstractTask<P_IN, P_OUT, R, K> {
                protected sharedResult: java.util.concurrent.atomic.AtomicReference<R>
                protected canceled: boolean
                protected constructor(arg0: java.util.stream.PipelineHelper<P_OUT>, arg1: java.util.Spliterator<P_IN>)
                protected constructor(arg0: K, arg1: java.util.Spliterator<P_IN>)
                protected getEmptyResult(): R
                public compute(): void
                protected shortCircuit(arg0: R): void
                protected setLocalResult(arg0: R): void
                public getRawResult(): R
                public getLocalResult(): R
                protected cancel(): void
                protected taskCanceled(): boolean
                protected cancelLaterNodes(): void
                public static class: java.lang.Class<any>
            }
            abstract class AbstractSpinedBuffer {
                public static MIN_CHUNK_POWER: int
                public static MIN_CHUNK_SIZE: int
                public static MAX_CHUNK_POWER: int
                public static MIN_SPINE_SIZE: int
                protected initialChunkPower: int
                protected elementIndex: int
                protected spineIndex: int
                protected priorElementCount: long[]
                protected constructor()
                protected constructor(arg0: int)
                public isEmpty(): boolean
                public count(): long
                protected chunkSize(arg0: int): int
                public clear(): void
                public static class: java.lang.Class<any>
            }
            abstract class AbstractTask<P_IN, P_OUT, R, K extends java.util.stream.AbstractTask<P_IN, P_OUT, R, K>> extends java.util.concurrent.CountedCompleter<R> {
                protected helper: java.util.stream.PipelineHelper<P_OUT>
                protected spliterator: java.util.Spliterator<P_IN>
                protected targetSize: long
                protected leftChild: K
                protected rightChild: K
                protected constructor(arg0: java.util.stream.PipelineHelper<P_OUT>, arg1: java.util.Spliterator<P_IN>)
                protected constructor(arg0: K, arg1: java.util.Spliterator<P_IN>)
                protected makeChild(arg0: java.util.Spliterator<P_IN>): K
                protected doLeaf(): R
                public static suggestTargetSize(arg0: long): long
                protected getTargetSize(arg0: long): long
                public getRawResult(): R
                protected setRawResult(arg0: R): void
                protected getLocalResult(): R
                protected setLocalResult(arg0: R): void
                protected isLeaf(): boolean
                protected isRoot(): boolean
                protected getParent(): K
                public compute(): void
                public onCompletion(arg0: java.util.concurrent.CountedCompleter<any>): void
                protected isLeftmostNode(): boolean
                public static class: java.lang.Class<any>
            }
            interface BaseStream<T, S extends java.util.stream.BaseStream<T, S>> extends java.lang.AutoCloseable {
                iterator(): java.util.Iterator<T>
                spliterator(): java.util.Spliterator<T>
                isParallel(): boolean
                sequential(): S
                parallel(): S
                unordered(): S
                onClose(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): S
                close(): void
            }
            interface Collector<T, A, R> {
                supplier(): java.util.function$.Supplier<A>
                accumulator(): java.util.function$.BiConsumer<A, T>
                combiner(): java.util.function$.BinaryOperator<A>
                finisher(): java.util.function$.Function<A, R>
                characteristics(): java.util.Set<java.util.stream.Collector$Characteristics>
                of<T, R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.BiConsumer<R, T>, arg2: java.util.function$.BinaryOperator<R>, ...arg3: java.util.stream.Collector$Characteristics[]): java.util.stream.Collector<T, R, R>
                of<T, A, R>(arg0: java.util.function$.Supplier<A> | java.util.function$.Supplier$$Lambda<A>, arg1: java.util.function$.BiConsumer<A, T>, arg2: java.util.function$.BinaryOperator<A>, arg3: java.util.function$.Function<A, R>, ...arg4: java.util.stream.Collector$Characteristics[]): java.util.stream.Collector<T, A, R>
            }
            class Collectors {
                public static toCollection<T, C extends java.util.Collection<T>>(arg0: java.util.function$.Supplier<C> | java.util.function$.Supplier$$Lambda<C>): java.util.stream.Collector<T, any, C>
                public static toList<T>(): java.util.stream.Collector<T, any, java.util.List<T>>
                public static toSet<T>(): java.util.stream.Collector<T, any, java.util.Set<T>>
                public static joining(): java.util.stream.Collector<java.lang.CharSequence, any, java.lang.String>
                public static joining(arg0: java.lang.CharSequence): java.util.stream.Collector<java.lang.CharSequence, any, java.lang.String>
                public static joining(arg0: java.lang.CharSequence, arg1: java.lang.CharSequence, arg2: java.lang.CharSequence): java.util.stream.Collector<java.lang.CharSequence, any, java.lang.String>
                public static mapping<T, U, A, R>(arg0: java.util.function$.Function<T, U>, arg1: java.util.stream.Collector<U, A, R>): java.util.stream.Collector<T, any, R>
                public static collectingAndThen<T, A, R, RR>(arg0: java.util.stream.Collector<T, A, R>, arg1: java.util.function$.Function<R, RR>): java.util.stream.Collector<T, A, RR>
                public static counting<T>(): java.util.stream.Collector<T, any, java.lang.Long>
                public static minBy<T>(arg0: java.util.Comparator<T>): java.util.stream.Collector<T, any, java.util.Optional<T>>
                public static maxBy<T>(arg0: java.util.Comparator<T>): java.util.stream.Collector<T, any, java.util.Optional<T>>
                public static summingInt<T>(arg0: java.util.function$.ToIntFunction<T> | java.util.function$.ToIntFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.lang.Integer>
                public static summingLong<T>(arg0: java.util.function$.ToLongFunction<T> | java.util.function$.ToLongFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.lang.Long>
                public static summingDouble<T>(arg0: java.util.function$.ToDoubleFunction<T> | java.util.function$.ToDoubleFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.lang.Double>
                public static averagingInt<T>(arg0: java.util.function$.ToIntFunction<T> | java.util.function$.ToIntFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.lang.Double>
                public static averagingLong<T>(arg0: java.util.function$.ToLongFunction<T> | java.util.function$.ToLongFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.lang.Double>
                public static averagingDouble<T>(arg0: java.util.function$.ToDoubleFunction<T> | java.util.function$.ToDoubleFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.lang.Double>
                public static reducing<T>(arg0: T, arg1: java.util.function$.BinaryOperator<T>): java.util.stream.Collector<T, any, T>
                public static reducing<T>(arg0: java.util.function$.BinaryOperator<T>): java.util.stream.Collector<T, any, java.util.Optional<T>>
                public static reducing<T, U>(arg0: U, arg1: java.util.function$.Function<T, U>, arg2: java.util.function$.BinaryOperator<U>): java.util.stream.Collector<T, any, U>
                public static groupingBy<T, K>(arg0: java.util.function$.Function<T, K>): java.util.stream.Collector<T, any, java.util.Map<K, java.util.List<T>>>
                public static groupingBy<T, K, A, D>(arg0: java.util.function$.Function<T, K>, arg1: java.util.stream.Collector<T, A, D>): java.util.stream.Collector<T, any, java.util.Map<K, D>>
                public static groupingBy<T, K, D, A, M extends java.util.Map<K, D>>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Supplier<M> | java.util.function$.Supplier$$Lambda<M>, arg2: java.util.stream.Collector<T, A, D>): java.util.stream.Collector<T, any, M>
                public static groupingByConcurrent<T, K>(arg0: java.util.function$.Function<T, K>): java.util.stream.Collector<T, any, java.util.concurrent.ConcurrentMap<K, java.util.List<T>>>
                public static groupingByConcurrent<T, K, A, D>(arg0: java.util.function$.Function<T, K>, arg1: java.util.stream.Collector<T, A, D>): java.util.stream.Collector<T, any, java.util.concurrent.ConcurrentMap<K, D>>
                public static groupingByConcurrent<T, K, A, D, M extends java.util.concurrent.ConcurrentMap<K, D>>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Supplier<M> | java.util.function$.Supplier$$Lambda<M>, arg2: java.util.stream.Collector<T, A, D>): java.util.stream.Collector<T, any, M>
                public static partitioningBy<T>(arg0: java.util.function$.Predicate<T>): java.util.stream.Collector<T, any, java.util.Map<java.lang.Boolean, java.util.List<T>>>
                public static partitioningBy<T, D, A>(arg0: java.util.function$.Predicate<T>, arg1: java.util.stream.Collector<T, A, D>): java.util.stream.Collector<T, any, java.util.Map<java.lang.Boolean, D>>
                public static toMap<T, K, U>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Function<T, U>): java.util.stream.Collector<T, any, java.util.Map<K, U>>
                public static toMap<T, K, U>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Function<T, U>, arg2: java.util.function$.BinaryOperator<U>): java.util.stream.Collector<T, any, java.util.Map<K, U>>
                public static toMap<T, K, U, M extends java.util.Map<K, U>>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Function<T, U>, arg2: java.util.function$.BinaryOperator<U>, arg3: java.util.function$.Supplier<M> | java.util.function$.Supplier$$Lambda<M>): java.util.stream.Collector<T, any, M>
                public static toConcurrentMap<T, K, U>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Function<T, U>): java.util.stream.Collector<T, any, java.util.concurrent.ConcurrentMap<K, U>>
                public static toConcurrentMap<T, K, U>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Function<T, U>, arg2: java.util.function$.BinaryOperator<U>): java.util.stream.Collector<T, any, java.util.concurrent.ConcurrentMap<K, U>>
                public static toConcurrentMap<T, K, U, M extends java.util.concurrent.ConcurrentMap<K, U>>(arg0: java.util.function$.Function<T, K>, arg1: java.util.function$.Function<T, U>, arg2: java.util.function$.BinaryOperator<U>, arg3: java.util.function$.Supplier<M> | java.util.function$.Supplier$$Lambda<M>): java.util.stream.Collector<T, any, M>
                public static summarizingInt<T>(arg0: java.util.function$.ToIntFunction<T> | java.util.function$.ToIntFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.util.IntSummaryStatistics>
                public static summarizingLong<T>(arg0: java.util.function$.ToLongFunction<T> | java.util.function$.ToLongFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.util.LongSummaryStatistics>
                public static summarizingDouble<T>(arg0: java.util.function$.ToDoubleFunction<T> | java.util.function$.ToDoubleFunction$$Lambda<T>): java.util.stream.Collector<T, any, java.util.DoubleSummaryStatistics>
                public static class: java.lang.Class<any>
            }
            class DistinctOps {
                public static class: java.lang.Class<any>
            }
            abstract class DoublePipeline<E_IN> extends java.util.stream.AbstractPipeline<E_IN, java.lang.Double, java.util.stream.DoubleStream> implements java.util.stream.DoubleStream {
                public iterator(): java.util.PrimitiveIterator$OfDouble
                public spliterator(): java.util.Spliterator$OfDouble
                public boxed(): java.util.stream.Stream<java.lang.Double>
                public map(arg0: java.util.function$.DoubleUnaryOperator): java.util.stream.DoubleStream
                public mapToObj<U>(arg0: java.util.function$.DoubleFunction<U> | java.util.function$.DoubleFunction$$Lambda<U>): java.util.stream.Stream<U>
                public mapToInt(arg0: java.util.function$.DoubleToIntFunction | java.util.function$.DoubleToIntFunction$$Lambda): java.util.stream.IntStream
                public mapToLong(arg0: java.util.function$.DoubleToLongFunction | java.util.function$.DoubleToLongFunction$$Lambda): java.util.stream.LongStream
                public flatMap(arg0: java.util.function$.DoubleFunction<java.util.stream.DoubleStream> | java.util.function$.DoubleFunction$$Lambda<java.util.stream.DoubleStream>): java.util.stream.DoubleStream
                public unordered(): java.util.stream.DoubleStream
                public filter(arg0: java.util.function$.DoublePredicate): java.util.stream.DoubleStream
                public peek(arg0: java.util.function$.DoubleConsumer): java.util.stream.DoubleStream
                public limit(arg0: long): java.util.stream.DoubleStream
                public skip(arg0: long): java.util.stream.DoubleStream
                public sorted(): java.util.stream.DoubleStream
                public distinct(): java.util.stream.DoubleStream
                public forEach(arg0: java.util.function$.DoubleConsumer): void
                public forEachOrdered(arg0: java.util.function$.DoubleConsumer): void
                public sum(): double
                public min(): java.util.OptionalDouble
                public max(): java.util.OptionalDouble
                public average(): java.util.OptionalDouble
                public count(): long
                public summaryStatistics(): java.util.DoubleSummaryStatistics
                public reduce(arg0: double, arg1: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): double
                public reduce(arg0: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): java.util.OptionalDouble
                public collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjDoubleConsumer<R> | java.util.function$.ObjDoubleConsumer$$Lambda<R>, arg2: java.util.function$.BiConsumer<R, R>): R
                public anyMatch(arg0: java.util.function$.DoublePredicate): boolean
                public allMatch(arg0: java.util.function$.DoublePredicate): boolean
                public noneMatch(arg0: java.util.function$.DoublePredicate): boolean
                public findFirst(): java.util.OptionalDouble
                public findAny(): java.util.OptionalDouble
                public toArray(): double[]
                public spliterator(): java.util.Spliterator
                public unordered(): java.util.stream.BaseStream
                public iterator(): java.util.Iterator
                public parallel(): java.util.stream.DoubleStream
                public sequential(): java.util.stream.DoubleStream
                public static class: java.lang.Class<any>
            }
            interface DoubleStream extends java.util.stream.BaseStream<java.lang.Double, java.util.stream.DoubleStream> {
                filter(arg0: java.util.function$.DoublePredicate): java.util.stream.DoubleStream
                map(arg0: java.util.function$.DoubleUnaryOperator): java.util.stream.DoubleStream
                mapToObj<U>(arg0: java.util.function$.DoubleFunction<U> | java.util.function$.DoubleFunction$$Lambda<U>): java.util.stream.Stream<U>
                mapToInt(arg0: java.util.function$.DoubleToIntFunction | java.util.function$.DoubleToIntFunction$$Lambda): java.util.stream.IntStream
                mapToLong(arg0: java.util.function$.DoubleToLongFunction | java.util.function$.DoubleToLongFunction$$Lambda): java.util.stream.LongStream
                flatMap(arg0: java.util.function$.DoubleFunction<java.util.stream.DoubleStream> | java.util.function$.DoubleFunction$$Lambda<java.util.stream.DoubleStream>): java.util.stream.DoubleStream
                distinct(): java.util.stream.DoubleStream
                sorted(): java.util.stream.DoubleStream
                peek(arg0: java.util.function$.DoubleConsumer): java.util.stream.DoubleStream
                limit(arg0: long): java.util.stream.DoubleStream
                skip(arg0: long): java.util.stream.DoubleStream
                forEach(arg0: java.util.function$.DoubleConsumer): void
                forEachOrdered(arg0: java.util.function$.DoubleConsumer): void
                toArray(): double[]
                reduce(arg0: double, arg1: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): double
                reduce(arg0: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): java.util.OptionalDouble
                collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjDoubleConsumer<R> | java.util.function$.ObjDoubleConsumer$$Lambda<R>, arg2: java.util.function$.BiConsumer<R, R>): R
                sum(): double
                min(): java.util.OptionalDouble
                max(): java.util.OptionalDouble
                count(): long
                average(): java.util.OptionalDouble
                summaryStatistics(): java.util.DoubleSummaryStatistics
                anyMatch(arg0: java.util.function$.DoublePredicate): boolean
                allMatch(arg0: java.util.function$.DoublePredicate): boolean
                noneMatch(arg0: java.util.function$.DoublePredicate): boolean
                findFirst(): java.util.OptionalDouble
                findAny(): java.util.OptionalDouble
                boxed(): java.util.stream.Stream<java.lang.Double>
                sequential(): java.util.stream.DoubleStream
                parallel(): java.util.stream.DoubleStream
                iterator(): java.util.PrimitiveIterator$OfDouble
                spliterator(): java.util.Spliterator$OfDouble
                builder(): java.util.stream.DoubleStream$Builder
                empty(): java.util.stream.DoubleStream
                of(arg0: double): java.util.stream.DoubleStream
                of(...arg0: double[]): java.util.stream.DoubleStream
                iterate(arg0: double, arg1: java.util.function$.DoubleUnaryOperator): java.util.stream.DoubleStream
                generate(arg0: java.util.function$.DoubleSupplier | java.util.function$.DoubleSupplier$$Lambda): java.util.stream.DoubleStream
                concat(arg0: java.util.stream.DoubleStream, arg1: java.util.stream.DoubleStream): java.util.stream.DoubleStream
                parallel(): java.util.stream.BaseStream
                sequential(): java.util.stream.BaseStream
                spliterator(): java.util.Spliterator
                iterator(): java.util.Iterator
            }
            class FindOps {
                public static makeRef<T>(arg0: boolean): java.util.stream.TerminalOp<T, java.util.Optional<T>>
                public static makeInt(arg0: boolean): java.util.stream.TerminalOp<java.lang.Integer, java.util.OptionalInt>
                public static makeLong(arg0: boolean): java.util.stream.TerminalOp<java.lang.Long, java.util.OptionalLong>
                public static makeDouble(arg0: boolean): java.util.stream.TerminalOp<java.lang.Double, java.util.OptionalDouble>
                public static class: java.lang.Class<any>
            }
            class ForEachOps {
                public static makeRef<T>(arg0: java.util.function$.Consumer$$TypeScript<T>, arg1: boolean): java.util.stream.TerminalOp<T, java.lang.Void>
                public static makeInt(arg0: java.util.function$.IntConsumer, arg1: boolean): java.util.stream.TerminalOp<java.lang.Integer, java.lang.Void>
                public static makeLong(arg0: java.util.function$.LongConsumer, arg1: boolean): java.util.stream.TerminalOp<java.lang.Long, java.lang.Void>
                public static makeDouble(arg0: java.util.function$.DoubleConsumer, arg1: boolean): java.util.stream.TerminalOp<java.lang.Double, java.lang.Void>
                public static class: java.lang.Class<any>
            }
            abstract class IntPipeline<E_IN> extends java.util.stream.AbstractPipeline<E_IN, java.lang.Integer, java.util.stream.IntStream> implements java.util.stream.IntStream {
                public iterator(): java.util.PrimitiveIterator$OfInt
                public spliterator(): java.util.Spliterator$OfInt
                public asLongStream(): java.util.stream.LongStream
                public asDoubleStream(): java.util.stream.DoubleStream
                public boxed(): java.util.stream.Stream<java.lang.Integer>
                public map(arg0: java.util.function$.IntUnaryOperator): java.util.stream.IntStream
                public mapToObj<U>(arg0: java.util.function$.IntFunction<U> | java.util.function$.IntFunction$$Lambda<U>): java.util.stream.Stream<U>
                public mapToLong(arg0: java.util.function$.IntToLongFunction | java.util.function$.IntToLongFunction$$Lambda): java.util.stream.LongStream
                public mapToDouble(arg0: java.util.function$.IntToDoubleFunction | java.util.function$.IntToDoubleFunction$$Lambda): java.util.stream.DoubleStream
                public flatMap(arg0: java.util.function$.IntFunction<java.util.stream.IntStream> | java.util.function$.IntFunction$$Lambda<java.util.stream.IntStream>): java.util.stream.IntStream
                public unordered(): java.util.stream.IntStream
                public filter(arg0: java.util.function$.IntPredicate): java.util.stream.IntStream
                public peek(arg0: java.util.function$.IntConsumer): java.util.stream.IntStream
                public limit(arg0: long): java.util.stream.IntStream
                public skip(arg0: long): java.util.stream.IntStream
                public sorted(): java.util.stream.IntStream
                public distinct(): java.util.stream.IntStream
                protected static promoteGPUCompile(): void
                public forEach(arg0: java.util.function$.IntConsumer): void
                public forEachOrdered(arg0: java.util.function$.IntConsumer): void
                public sum(): int
                public min(): java.util.OptionalInt
                public max(): java.util.OptionalInt
                public count(): long
                public average(): java.util.OptionalDouble
                public summaryStatistics(): java.util.IntSummaryStatistics
                public reduce(arg0: int, arg1: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                public reduce(arg0: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): java.util.OptionalInt
                public collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjIntConsumer<R> | java.util.function$.ObjIntConsumer$$Lambda<R>, arg2: java.util.function$.BiConsumer<R, R>): R
                public anyMatch(arg0: java.util.function$.IntPredicate): boolean
                public allMatch(arg0: java.util.function$.IntPredicate): boolean
                public noneMatch(arg0: java.util.function$.IntPredicate): boolean
                public findFirst(): java.util.OptionalInt
                public findAny(): java.util.OptionalInt
                public toArray(): int[]
                public spliterator(): java.util.Spliterator
                public unordered(): java.util.stream.BaseStream
                public iterator(): java.util.Iterator
                public parallel(): java.util.stream.IntStream
                public sequential(): java.util.stream.IntStream
                public static class: java.lang.Class<any>
            }
            interface IntStream extends java.util.stream.BaseStream<java.lang.Integer, java.util.stream.IntStream> {
                filter(arg0: java.util.function$.IntPredicate): java.util.stream.IntStream
                map(arg0: java.util.function$.IntUnaryOperator): java.util.stream.IntStream
                mapToObj<U>(arg0: java.util.function$.IntFunction<U> | java.util.function$.IntFunction$$Lambda<U>): java.util.stream.Stream<U>
                mapToLong(arg0: java.util.function$.IntToLongFunction | java.util.function$.IntToLongFunction$$Lambda): java.util.stream.LongStream
                mapToDouble(arg0: java.util.function$.IntToDoubleFunction | java.util.function$.IntToDoubleFunction$$Lambda): java.util.stream.DoubleStream
                flatMap(arg0: java.util.function$.IntFunction<java.util.stream.IntStream> | java.util.function$.IntFunction$$Lambda<java.util.stream.IntStream>): java.util.stream.IntStream
                distinct(): java.util.stream.IntStream
                sorted(): java.util.stream.IntStream
                peek(arg0: java.util.function$.IntConsumer): java.util.stream.IntStream
                limit(arg0: long): java.util.stream.IntStream
                skip(arg0: long): java.util.stream.IntStream
                forEach(arg0: java.util.function$.IntConsumer): void
                forEachOrdered(arg0: java.util.function$.IntConsumer): void
                toArray(): int[]
                reduce(arg0: int, arg1: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): int
                reduce(arg0: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): java.util.OptionalInt
                collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjIntConsumer<R> | java.util.function$.ObjIntConsumer$$Lambda<R>, arg2: java.util.function$.BiConsumer<R, R>): R
                sum(): int
                min(): java.util.OptionalInt
                max(): java.util.OptionalInt
                count(): long
                average(): java.util.OptionalDouble
                summaryStatistics(): java.util.IntSummaryStatistics
                anyMatch(arg0: java.util.function$.IntPredicate): boolean
                allMatch(arg0: java.util.function$.IntPredicate): boolean
                noneMatch(arg0: java.util.function$.IntPredicate): boolean
                findFirst(): java.util.OptionalInt
                findAny(): java.util.OptionalInt
                asLongStream(): java.util.stream.LongStream
                asDoubleStream(): java.util.stream.DoubleStream
                boxed(): java.util.stream.Stream<java.lang.Integer>
                sequential(): java.util.stream.IntStream
                parallel(): java.util.stream.IntStream
                iterator(): java.util.PrimitiveIterator$OfInt
                spliterator(): java.util.Spliterator$OfInt
                builder(): java.util.stream.IntStream$Builder
                empty(): java.util.stream.IntStream
                of(arg0: int): java.util.stream.IntStream
                of(...arg0: int[]): java.util.stream.IntStream
                iterate(arg0: int, arg1: java.util.function$.IntUnaryOperator): java.util.stream.IntStream
                generate(arg0: java.util.function$.IntSupplier | java.util.function$.IntSupplier$$Lambda): java.util.stream.IntStream
                range(arg0: int, arg1: int): java.util.stream.IntStream
                rangeClosed(arg0: int, arg1: int): java.util.stream.IntStream
                concat(arg0: java.util.stream.IntStream, arg1: java.util.stream.IntStream): java.util.stream.IntStream
                parallel(): java.util.stream.BaseStream
                sequential(): java.util.stream.BaseStream
                spliterator(): java.util.Spliterator
                iterator(): java.util.Iterator
            }
            abstract class LongPipeline<E_IN> extends java.util.stream.AbstractPipeline<E_IN, java.lang.Long, java.util.stream.LongStream> implements java.util.stream.LongStream {
                public iterator(): java.util.PrimitiveIterator$OfLong
                public spliterator(): java.util.Spliterator$OfLong
                public asDoubleStream(): java.util.stream.DoubleStream
                public boxed(): java.util.stream.Stream<java.lang.Long>
                public map(arg0: java.util.function$.LongUnaryOperator): java.util.stream.LongStream
                public mapToObj<U>(arg0: java.util.function$.LongFunction<U> | java.util.function$.LongFunction$$Lambda<U>): java.util.stream.Stream<U>
                public mapToInt(arg0: java.util.function$.LongToIntFunction | java.util.function$.LongToIntFunction$$Lambda): java.util.stream.IntStream
                public mapToDouble(arg0: java.util.function$.LongToDoubleFunction | java.util.function$.LongToDoubleFunction$$Lambda): java.util.stream.DoubleStream
                public flatMap(arg0: java.util.function$.LongFunction<java.util.stream.LongStream> | java.util.function$.LongFunction$$Lambda<java.util.stream.LongStream>): java.util.stream.LongStream
                public unordered(): java.util.stream.LongStream
                public filter(arg0: java.util.function$.LongPredicate): java.util.stream.LongStream
                public peek(arg0: java.util.function$.LongConsumer): java.util.stream.LongStream
                public limit(arg0: long): java.util.stream.LongStream
                public skip(arg0: long): java.util.stream.LongStream
                public sorted(): java.util.stream.LongStream
                public distinct(): java.util.stream.LongStream
                public forEach(arg0: java.util.function$.LongConsumer): void
                public forEachOrdered(arg0: java.util.function$.LongConsumer): void
                public sum(): long
                public min(): java.util.OptionalLong
                public max(): java.util.OptionalLong
                public average(): java.util.OptionalDouble
                public count(): long
                public summaryStatistics(): java.util.LongSummaryStatistics
                public reduce(arg0: long, arg1: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                public reduce(arg0: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): java.util.OptionalLong
                public collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjLongConsumer<R> | java.util.function$.ObjLongConsumer$$Lambda<R>, arg2: java.util.function$.BiConsumer<R, R>): R
                public anyMatch(arg0: java.util.function$.LongPredicate): boolean
                public allMatch(arg0: java.util.function$.LongPredicate): boolean
                public noneMatch(arg0: java.util.function$.LongPredicate): boolean
                public findFirst(): java.util.OptionalLong
                public findAny(): java.util.OptionalLong
                public toArray(): long[]
                public spliterator(): java.util.Spliterator
                public unordered(): java.util.stream.BaseStream
                public iterator(): java.util.Iterator
                public parallel(): java.util.stream.LongStream
                public sequential(): java.util.stream.LongStream
                public static class: java.lang.Class<any>
            }
            interface LongStream extends java.util.stream.BaseStream<java.lang.Long, java.util.stream.LongStream> {
                filter(arg0: java.util.function$.LongPredicate): java.util.stream.LongStream
                map(arg0: java.util.function$.LongUnaryOperator): java.util.stream.LongStream
                mapToObj<U>(arg0: java.util.function$.LongFunction<U> | java.util.function$.LongFunction$$Lambda<U>): java.util.stream.Stream<U>
                mapToInt(arg0: java.util.function$.LongToIntFunction | java.util.function$.LongToIntFunction$$Lambda): java.util.stream.IntStream
                mapToDouble(arg0: java.util.function$.LongToDoubleFunction | java.util.function$.LongToDoubleFunction$$Lambda): java.util.stream.DoubleStream
                flatMap(arg0: java.util.function$.LongFunction<java.util.stream.LongStream> | java.util.function$.LongFunction$$Lambda<java.util.stream.LongStream>): java.util.stream.LongStream
                distinct(): java.util.stream.LongStream
                sorted(): java.util.stream.LongStream
                peek(arg0: java.util.function$.LongConsumer): java.util.stream.LongStream
                limit(arg0: long): java.util.stream.LongStream
                skip(arg0: long): java.util.stream.LongStream
                forEach(arg0: java.util.function$.LongConsumer): void
                forEachOrdered(arg0: java.util.function$.LongConsumer): void
                toArray(): long[]
                reduce(arg0: long, arg1: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): long
                reduce(arg0: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): java.util.OptionalLong
                collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjLongConsumer<R> | java.util.function$.ObjLongConsumer$$Lambda<R>, arg2: java.util.function$.BiConsumer<R, R>): R
                sum(): long
                min(): java.util.OptionalLong
                max(): java.util.OptionalLong
                count(): long
                average(): java.util.OptionalDouble
                summaryStatistics(): java.util.LongSummaryStatistics
                anyMatch(arg0: java.util.function$.LongPredicate): boolean
                allMatch(arg0: java.util.function$.LongPredicate): boolean
                noneMatch(arg0: java.util.function$.LongPredicate): boolean
                findFirst(): java.util.OptionalLong
                findAny(): java.util.OptionalLong
                asDoubleStream(): java.util.stream.DoubleStream
                boxed(): java.util.stream.Stream<java.lang.Long>
                sequential(): java.util.stream.LongStream
                parallel(): java.util.stream.LongStream
                iterator(): java.util.PrimitiveIterator$OfLong
                spliterator(): java.util.Spliterator$OfLong
                builder(): java.util.stream.LongStream$Builder
                empty(): java.util.stream.LongStream
                of(arg0: long): java.util.stream.LongStream
                of(...arg0: long[]): java.util.stream.LongStream
                iterate(arg0: long, arg1: java.util.function$.LongUnaryOperator): java.util.stream.LongStream
                generate(arg0: java.util.function$.LongSupplier | java.util.function$.LongSupplier$$Lambda): java.util.stream.LongStream
                range(arg0: long, arg1: long): java.util.stream.LongStream
                rangeClosed(arg0: long, arg1: long): java.util.stream.LongStream
                concat(arg0: java.util.stream.LongStream, arg1: java.util.stream.LongStream): java.util.stream.LongStream
                parallel(): java.util.stream.BaseStream
                sequential(): java.util.stream.BaseStream
                spliterator(): java.util.Spliterator
                iterator(): java.util.Iterator
            }
            class MatchOps {
                public static makeRef<T>(arg0: java.util.function$.Predicate<T>, arg1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp<T, java.lang.Boolean>
                public static makeInt(arg0: java.util.function$.IntPredicate, arg1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp<java.lang.Integer, java.lang.Boolean>
                public static makeLong(arg0: java.util.function$.LongPredicate, arg1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp<java.lang.Long, java.lang.Boolean>
                public static makeDouble(arg0: java.util.function$.DoublePredicate, arg1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp<java.lang.Double, java.lang.Boolean>
                public static class: java.lang.Class<any>
            }
            interface Node<T> {
                spliterator(): java.util.Spliterator<T>
                forEach(arg0: java.util.function$.Consumer$$TypeScript<T>): void
                getChildCount(): int
                getChild(arg0: int): java.util.stream.Node<T>
                truncate(arg0: long, arg1: long, arg2: java.util.function$.IntFunction<T[]> | java.util.function$.IntFunction$$Lambda<T[]>): java.util.stream.Node<T>
                asArray(arg0: java.util.function$.IntFunction<T[]> | java.util.function$.IntFunction$$Lambda<T[]>): T[]
                copyInto(arg0: T[], arg1: int): void
                getShape(): java.util.stream.StreamShape
                count(): long
            }
            class Nodes {
                public static collect<P_IN, P_OUT>(arg0: java.util.stream.PipelineHelper<P_OUT>, arg1: java.util.Spliterator<P_IN>, arg2: boolean, arg3: java.util.function$.IntFunction<P_OUT[]> | java.util.function$.IntFunction$$Lambda<P_OUT[]>): java.util.stream.Node<P_OUT>
                public static collectInt<P_IN>(arg0: java.util.stream.PipelineHelper<java.lang.Integer>, arg1: java.util.Spliterator<P_IN>, arg2: boolean): java.util.stream.Node$OfInt
                public static collectLong<P_IN>(arg0: java.util.stream.PipelineHelper<java.lang.Long>, arg1: java.util.Spliterator<P_IN>, arg2: boolean): java.util.stream.Node$OfLong
                public static collectDouble<P_IN>(arg0: java.util.stream.PipelineHelper<java.lang.Double>, arg1: java.util.Spliterator<P_IN>, arg2: boolean): java.util.stream.Node$OfDouble
                public static flatten<T>(arg0: java.util.stream.Node<T>, arg1: java.util.function$.IntFunction<T[]> | java.util.function$.IntFunction$$Lambda<T[]>): java.util.stream.Node<T>
                public static flattenInt(arg0: java.util.stream.Node$OfInt): java.util.stream.Node$OfInt
                public static flattenLong(arg0: java.util.stream.Node$OfLong): java.util.stream.Node$OfLong
                public static flattenDouble(arg0: java.util.stream.Node$OfDouble): java.util.stream.Node$OfDouble
                public static class: java.lang.Class<any>
            }
            abstract class PipelineHelper<P_OUT> {
                public static class: java.lang.Class<any>
            }
            class ReduceOps {
                public static makeRef<T, U>(arg0: U, arg1: java.util.function$.BiFunction<U, T, U>, arg2: java.util.function$.BinaryOperator<U>): java.util.stream.TerminalOp<T, U>
                public static makeRef<T>(arg0: java.util.function$.BinaryOperator<T>): java.util.stream.TerminalOp<T, java.util.Optional<T>>
                public static makeRef<T, I>(arg0: java.util.stream.Collector<T, I, any>): java.util.stream.TerminalOp<T, I>
                public static makeRef<T, R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.BiConsumer<R, T>, arg2: java.util.function$.BiConsumer<R, R>): java.util.stream.TerminalOp<T, R>
                public static makeInt(arg0: int, arg1: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): java.util.stream.TerminalOp<java.lang.Integer, java.lang.Integer>
                public static makeInt(arg0: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): java.util.stream.TerminalOp<java.lang.Integer, java.util.OptionalInt>
                public static makeInt<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjIntConsumer<R> | java.util.function$.ObjIntConsumer$$Lambda<R>, arg2: java.util.function$.BinaryOperator<R>): java.util.stream.TerminalOp<java.lang.Integer, R>
                public static makeLong(arg0: long, arg1: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): java.util.stream.TerminalOp<java.lang.Long, java.lang.Long>
                public static makeLong(arg0: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): java.util.stream.TerminalOp<java.lang.Long, java.util.OptionalLong>
                public static makeLong<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjLongConsumer<R> | java.util.function$.ObjLongConsumer$$Lambda<R>, arg2: java.util.function$.BinaryOperator<R>): java.util.stream.TerminalOp<java.lang.Long, R>
                public static makeDouble(arg0: double, arg1: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): java.util.stream.TerminalOp<java.lang.Double, java.lang.Double>
                public static makeDouble(arg0: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): java.util.stream.TerminalOp<java.lang.Double, java.util.OptionalDouble>
                public static makeDouble<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.ObjDoubleConsumer<R> | java.util.function$.ObjDoubleConsumer$$Lambda<R>, arg2: java.util.function$.BinaryOperator<R>): java.util.stream.TerminalOp<java.lang.Double, R>
                public static class: java.lang.Class<any>
            }
            abstract class ReferencePipeline<P_IN, P_OUT> extends java.util.stream.AbstractPipeline<P_IN, P_OUT, java.util.stream.Stream<P_OUT>> implements java.util.stream.Stream<P_OUT> {
                public iterator(): java.util.Iterator<P_OUT>
                public unordered(): java.util.stream.Stream<P_OUT>
                public filter(arg0: java.util.function$.Predicate<P_OUT>): java.util.stream.Stream<P_OUT>
                public map<R>(arg0: java.util.function$.Function<P_OUT, R>): java.util.stream.Stream<R>
                public mapToInt(arg0: java.util.function$.ToIntFunction<P_OUT> | java.util.function$.ToIntFunction$$Lambda<P_OUT>): java.util.stream.IntStream
                public mapToLong(arg0: java.util.function$.ToLongFunction<P_OUT> | java.util.function$.ToLongFunction$$Lambda<P_OUT>): java.util.stream.LongStream
                public mapToDouble(arg0: java.util.function$.ToDoubleFunction<P_OUT> | java.util.function$.ToDoubleFunction$$Lambda<P_OUT>): java.util.stream.DoubleStream
                public flatMap<R>(arg0: java.util.function$.Function<P_OUT, java.util.stream.Stream<R>>): java.util.stream.Stream<R>
                public flatMapToInt(arg0: java.util.function$.Function<P_OUT, java.util.stream.IntStream>): java.util.stream.IntStream
                public flatMapToDouble(arg0: java.util.function$.Function<P_OUT, java.util.stream.DoubleStream>): java.util.stream.DoubleStream
                public flatMapToLong(arg0: java.util.function$.Function<P_OUT, java.util.stream.LongStream>): java.util.stream.LongStream
                public peek(arg0: java.util.function$.Consumer$$TypeScript<P_OUT>): java.util.stream.Stream<P_OUT>
                public distinct(): java.util.stream.Stream<P_OUT>
                public sorted(): java.util.stream.Stream<P_OUT>
                public sorted(arg0: java.util.Comparator<P_OUT>): java.util.stream.Stream<P_OUT>
                public limit(arg0: long): java.util.stream.Stream<P_OUT>
                public skip(arg0: long): java.util.stream.Stream<P_OUT>
                public forEach(arg0: java.util.function$.Consumer$$TypeScript<P_OUT>): void
                public forEachOrdered(arg0: java.util.function$.Consumer$$TypeScript<P_OUT>): void
                public toArray<A>(arg0: java.util.function$.IntFunction<A[]> | java.util.function$.IntFunction$$Lambda<A[]>): A[]
                public toArray(): java.lang.Object[]
                public anyMatch(arg0: java.util.function$.Predicate<P_OUT>): boolean
                public allMatch(arg0: java.util.function$.Predicate<P_OUT>): boolean
                public noneMatch(arg0: java.util.function$.Predicate<P_OUT>): boolean
                public findFirst(): java.util.Optional<P_OUT>
                public findAny(): java.util.Optional<P_OUT>
                public reduce(arg0: P_OUT, arg1: java.util.function$.BinaryOperator<P_OUT>): P_OUT
                public reduce(arg0: java.util.function$.BinaryOperator<P_OUT>): java.util.Optional<P_OUT>
                public reduce<R>(arg0: R, arg1: java.util.function$.BiFunction<R, P_OUT, R>, arg2: java.util.function$.BinaryOperator<R>): R
                public collect<R, A>(arg0: java.util.stream.Collector<P_OUT, A, R>): R
                public collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.BiConsumer<R, P_OUT>, arg2: java.util.function$.BiConsumer<R, R>): R
                public max(arg0: java.util.Comparator<P_OUT>): java.util.Optional<P_OUT>
                public min(arg0: java.util.Comparator<P_OUT>): java.util.Optional<P_OUT>
                public count(): long
                public unordered(): java.util.stream.BaseStream
                public static class: java.lang.Class<any>
            }
            interface Sink<T> extends java.util.function$.Consumer<T> {
                begin(arg0: long): void
                end(): void
                cancellationRequested(): boolean
                accept(arg0: int): void
                accept(arg0: long): void
                accept(arg0: double): void
            }
            class SliceOps {
                public static makeRef<T>(arg0: java.util.stream.AbstractPipeline<any, T, any>, arg1: long, arg2: long): java.util.stream.Stream<T>
                public static makeInt(arg0: java.util.stream.AbstractPipeline<any, java.lang.Integer, any>, arg1: long, arg2: long): java.util.stream.IntStream
                public static makeLong(arg0: java.util.stream.AbstractPipeline<any, java.lang.Long, any>, arg1: long, arg2: long): java.util.stream.LongStream
                public static makeDouble(arg0: java.util.stream.AbstractPipeline<any, java.lang.Double, any>, arg1: long, arg2: long): java.util.stream.DoubleStream
                public static class: java.lang.Class<any>
            }
            class SortedOps {
                public static class: java.lang.Class<any>
            }
            class SpinedBuffer<E> extends java.util.stream.AbstractSpinedBuffer implements java.util.function$.Consumer<E> , java.lang.Iterable<E> {
                protected curChunk: E[]
                protected spine: E[][]
                protected capacity(): long
                protected ensureCapacity(arg0: long): void
                protected increaseCapacity(): void
                public get(arg0: long): E
                public copyInto(arg0: E[], arg1: int): void
                public asArray(arg0: java.util.function$.IntFunction<E[]> | java.util.function$.IntFunction$$Lambda<E[]>): E[]
                public clear(): void
                public iterator(): java.util.Iterator<E>
                public forEach(arg0: java.util.function$.Consumer$$TypeScript<E>): void
                public accept(arg0: E): void
                public toString(): string
                public spliterator(): java.util.Spliterator<E>
                public static class: java.lang.Class<any>
            }
            interface Stream<T> extends java.util.stream.BaseStream<T, java.util.stream.Stream<T>> {
                filter(arg0: java.util.function$.Predicate<T>): java.util.stream.Stream<T>
                map<R>(arg0: java.util.function$.Function<T, R>): java.util.stream.Stream<R>
                mapToInt(arg0: java.util.function$.ToIntFunction<T> | java.util.function$.ToIntFunction$$Lambda<T>): java.util.stream.IntStream
                mapToLong(arg0: java.util.function$.ToLongFunction<T> | java.util.function$.ToLongFunction$$Lambda<T>): java.util.stream.LongStream
                mapToDouble(arg0: java.util.function$.ToDoubleFunction<T> | java.util.function$.ToDoubleFunction$$Lambda<T>): java.util.stream.DoubleStream
                flatMap<R>(arg0: java.util.function$.Function<T, java.util.stream.Stream<R>>): java.util.stream.Stream<R>
                flatMapToInt(arg0: java.util.function$.Function<T, java.util.stream.IntStream>): java.util.stream.IntStream
                flatMapToLong(arg0: java.util.function$.Function<T, java.util.stream.LongStream>): java.util.stream.LongStream
                flatMapToDouble(arg0: java.util.function$.Function<T, java.util.stream.DoubleStream>): java.util.stream.DoubleStream
                distinct(): java.util.stream.Stream<T>
                sorted(): java.util.stream.Stream<T>
                sorted(arg0: java.util.Comparator<T>): java.util.stream.Stream<T>
                peek(arg0: java.util.function$.Consumer$$TypeScript<T>): java.util.stream.Stream<T>
                limit(arg0: long): java.util.stream.Stream<T>
                skip(arg0: long): java.util.stream.Stream<T>
                forEach(arg0: java.util.function$.Consumer$$TypeScript<T>): void
                forEachOrdered(arg0: java.util.function$.Consumer$$TypeScript<T>): void
                toArray(): java.lang.Object[]
                toArray<A>(arg0: java.util.function$.IntFunction<A[]> | java.util.function$.IntFunction$$Lambda<A[]>): A[]
                reduce(arg0: T, arg1: java.util.function$.BinaryOperator<T>): T
                reduce(arg0: java.util.function$.BinaryOperator<T>): java.util.Optional<T>
                reduce<U>(arg0: U, arg1: java.util.function$.BiFunction<U, T, U>, arg2: java.util.function$.BinaryOperator<U>): U
                collect<R>(arg0: java.util.function$.Supplier<R> | java.util.function$.Supplier$$Lambda<R>, arg1: java.util.function$.BiConsumer<R, T>, arg2: java.util.function$.BiConsumer<R, R>): R
                collect<R, A>(arg0: java.util.stream.Collector<T, A, R>): R
                min(arg0: java.util.Comparator<T>): java.util.Optional<T>
                max(arg0: java.util.Comparator<T>): java.util.Optional<T>
                count(): long
                anyMatch(arg0: java.util.function$.Predicate<T>): boolean
                allMatch(arg0: java.util.function$.Predicate<T>): boolean
                noneMatch(arg0: java.util.function$.Predicate<T>): boolean
                findFirst(): java.util.Optional<T>
                findAny(): java.util.Optional<T>
                builder<T>(): java.util.stream.Stream$Builder<T>
                empty<T>(): java.util.stream.Stream<T>
                of<T>(arg0: T): java.util.stream.Stream<T>
                of<T>(...arg0: T[]): java.util.stream.Stream<T>
                iterate<T>(arg0: T, arg1: java.util.function$.UnaryOperator<T>): java.util.stream.Stream<T>
                generate<T>(arg0: java.util.function$.Supplier<T> | java.util.function$.Supplier$$Lambda<T>): java.util.stream.Stream<T>
                concat<T>(arg0: java.util.stream.Stream<T>, arg1: java.util.stream.Stream<T>): java.util.stream.Stream<T>
            }
            class StreamOpFlag extends java.lang.Enum<java.util.stream.StreamOpFlag> {
                public static DISTINCT: java.util.stream.StreamOpFlag
                public static SORTED: java.util.stream.StreamOpFlag
                public static ORDERED: java.util.stream.StreamOpFlag
                public static SIZED: java.util.stream.StreamOpFlag
                public static SHORT_CIRCUIT: java.util.stream.StreamOpFlag
                public static values(): java.util.stream.StreamOpFlag[]
                public static valueOf(arg0: java.lang.String | string): java.util.stream.StreamOpFlag
                public static class: java.lang.Class<any>
            }
            class StreamShape extends java.lang.Enum<java.util.stream.StreamShape> {
                public static REFERENCE: java.util.stream.StreamShape
                public static INT_VALUE: java.util.stream.StreamShape
                public static LONG_VALUE: java.util.stream.StreamShape
                public static DOUBLE_VALUE: java.util.stream.StreamShape
                public static values(): java.util.stream.StreamShape[]
                public static valueOf(arg0: java.lang.String | string): java.util.stream.StreamShape
                public static class: java.lang.Class<any>
            }
            class StreamSpliterators {
                public static class: java.lang.Class<any>
            }
            class StreamSupport {
                public static stream<T>(arg0: java.util.Spliterator<T>, arg1: boolean): java.util.stream.Stream<T>
                public static stream<T>(arg0: java.util.function$.Supplier<java.util.Spliterator<T>> | java.util.function$.Supplier$$Lambda<java.util.Spliterator<T>>, arg1: int, arg2: boolean): java.util.stream.Stream<T>
                public static intStream(arg0: java.util.Spliterator$OfInt, arg1: boolean): java.util.stream.IntStream
                public static intStream(arg0: java.util.function$.Supplier<java.util.Spliterator$OfInt> | java.util.function$.Supplier$$Lambda<java.util.Spliterator$OfInt>, arg1: int, arg2: boolean): java.util.stream.IntStream
                public static longStream(arg0: java.util.Spliterator$OfLong, arg1: boolean): java.util.stream.LongStream
                public static longStream(arg0: java.util.function$.Supplier<java.util.Spliterator$OfLong> | java.util.function$.Supplier$$Lambda<java.util.Spliterator$OfLong>, arg1: int, arg2: boolean): java.util.stream.LongStream
                public static doubleStream(arg0: java.util.Spliterator$OfDouble, arg1: boolean): java.util.stream.DoubleStream
                public static doubleStream(arg0: java.util.function$.Supplier<java.util.Spliterator$OfDouble> | java.util.function$.Supplier$$Lambda<java.util.Spliterator$OfDouble>, arg1: int, arg2: boolean): java.util.stream.DoubleStream
                public static class: java.lang.Class<any>
            }
            class Streams {
                public static class: java.lang.Class<any>
            }
            interface TerminalOp<E_IN, R> {
                inputShape(): java.util.stream.StreamShape
                getOpFlags(): int
                evaluateParallel<P_IN>(arg0: java.util.stream.PipelineHelper<E_IN>, arg1: java.util.Spliterator<P_IN>): R
                evaluateSequential<P_IN>(arg0: java.util.stream.PipelineHelper<E_IN>, arg1: java.util.Spliterator<P_IN>): R
            }
            interface TerminalSink<T, R> extends java.util.stream.Sink<T> , java.util.function$.Supplier<R> {
            }
            class Tripwire {
                public static class: java.lang.Class<any>
            }
        }
        namespace zip {
            class Adler32 implements java.util.zip.Checksum {
                public constructor()
                public update(arg0: int): void
                public update(arg0: byte[], arg1: int, arg2: int): void
                public update(arg0: byte[]): void
                public update(arg0: java.nio.ByteBuffer): void
                public reset(): void
                public getValue(): long
                public static class: java.lang.Class<any>
            }
            class CRC32 implements java.util.zip.Checksum {
                public constructor()
                public update(arg0: int): void
                public update(arg0: byte[], arg1: int, arg2: int): void
                public update(arg0: byte[]): void
                public update(arg0: java.nio.ByteBuffer): void
                public reset(): void
                public getValue(): long
                public static class: java.lang.Class<any>
            }
            class CheckedInputStream extends java.io.FilterInputStream {
                public constructor(arg0: java.io.InputStream, arg1: java.util.zip.Checksum)
                public read(): int
                public read(arg0: byte[], arg1: int, arg2: int): int
                public skip(arg0: long): long
                public getChecksum(): java.util.zip.Checksum
                public static class: java.lang.Class<any>
            }
            class CheckedOutputStream extends java.io.FilterOutputStream {
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Checksum)
                public write(arg0: int): void
                public write(arg0: byte[], arg1: int, arg2: int): void
                public getChecksum(): java.util.zip.Checksum
                public static class: java.lang.Class<any>
            }
            interface Checksum {
                update(arg0: int): void
                update(arg0: byte[], arg1: int, arg2: int): void
                getValue(): long
                reset(): void
            }
            class DataFormatException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class Deflater {
                public static DEFLATED: int
                public static NO_COMPRESSION: int
                public static BEST_SPEED: int
                public static BEST_COMPRESSION: int
                public static DEFAULT_COMPRESSION: int
                public static FILTERED: int
                public static HUFFMAN_ONLY: int
                public static DEFAULT_STRATEGY: int
                public static NO_FLUSH: int
                public static SYNC_FLUSH: int
                public static FULL_FLUSH: int
                public constructor(arg0: int, arg1: boolean)
                public constructor(arg0: int)
                public constructor()
                public setInput(arg0: byte[], arg1: int, arg2: int): void
                public setInput(arg0: byte[]): void
                public setDictionary(arg0: byte[], arg1: int, arg2: int): void
                public setDictionary(arg0: byte[]): void
                public setStrategy(arg0: int): void
                public setLevel(arg0: int): void
                public needsInput(): boolean
                public finish(): void
                public finished(): boolean
                public deflate(arg0: byte[], arg1: int, arg2: int): int
                public deflate(arg0: byte[]): int
                public deflate(arg0: byte[], arg1: int, arg2: int, arg3: int): int
                public getAdler(): int
                public getTotalIn(): int
                public getBytesRead(): long
                public getTotalOut(): int
                public getBytesWritten(): long
                public reset(): void
                public end(): void
                protected finalize(): void
                public static class: java.lang.Class<any>
            }
            class DeflaterInputStream extends java.io.FilterInputStream {
                protected def: java.util.zip.Deflater
                protected buf: byte[]
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: java.io.InputStream, arg1: java.util.zip.Deflater)
                public constructor(arg0: java.io.InputStream, arg1: java.util.zip.Deflater, arg2: int)
                public close(): void
                public read(): int
                public read(arg0: byte[], arg1: int, arg2: int): int
                public skip(arg0: long): long
                public available(): int
                public markSupported(): boolean
                public mark(arg0: int): void
                public reset(): void
                public static class: java.lang.Class<any>
            }
            class DeflaterOutputStream extends java.io.FilterOutputStream {
                protected def: java.util.zip.Deflater
                protected buf: byte[]
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Deflater, arg2: int, arg3: boolean)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Deflater, arg2: int)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Deflater, arg2: boolean)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Deflater)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
                public write(arg0: int): void
                public write(arg0: byte[], arg1: int, arg2: int): void
                public finish(): void
                public close(): void
                protected deflate(): void
                public flush(): void
                public static class: java.lang.Class<any>
            }
            class GZIPInputStream extends java.util.zip.InflaterInputStream {
                protected crc: java.util.zip.CRC32
                protected eos: boolean
                public static GZIP_MAGIC: int
                public constructor(arg0: java.io.InputStream, arg1: int)
                public constructor(arg0: java.io.InputStream)
                public read(arg0: byte[], arg1: int, arg2: int): int
                public close(): void
                public static class: java.lang.Class<any>
            }
            class GZIPOutputStream extends java.util.zip.DeflaterOutputStream {
                protected crc: java.util.zip.CRC32
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: int, arg2: boolean)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean)
                public write(arg0: byte[], arg1: int, arg2: int): void
                public finish(): void
                public static class: java.lang.Class<any>
            }
            class Inflater {
                public constructor(arg0: boolean)
                public constructor()
                public setInput(arg0: byte[], arg1: int, arg2: int): void
                public setInput(arg0: byte[]): void
                public setDictionary(arg0: byte[], arg1: int, arg2: int): void
                public setDictionary(arg0: byte[]): void
                public getRemaining(): int
                public needsInput(): boolean
                public needsDictionary(): boolean
                public finished(): boolean
                public inflate(arg0: byte[], arg1: int, arg2: int): int
                public inflate(arg0: byte[]): int
                public getAdler(): int
                public getTotalIn(): int
                public getBytesRead(): long
                public getTotalOut(): int
                public getBytesWritten(): long
                public reset(): void
                public end(): void
                protected finalize(): void
                public static class: java.lang.Class<any>
            }
            class InflaterInputStream extends java.io.FilterInputStream {
                protected inf: java.util.zip.Inflater
                protected buf: byte[]
                protected len: int
                public constructor(arg0: java.io.InputStream, arg1: java.util.zip.Inflater, arg2: int)
                public constructor(arg0: java.io.InputStream, arg1: java.util.zip.Inflater)
                public constructor(arg0: java.io.InputStream)
                public read(): int
                public read(arg0: byte[], arg1: int, arg2: int): int
                public available(): int
                public skip(arg0: long): long
                public close(): void
                protected fill(): void
                public markSupported(): boolean
                public mark(arg0: int): void
                public reset(): void
                public static class: java.lang.Class<any>
            }
            class InflaterOutputStream extends java.io.FilterOutputStream {
                protected inf: java.util.zip.Inflater
                protected buf: byte[]
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Inflater)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.util.zip.Inflater, arg2: int)
                public close(): void
                public flush(): void
                public finish(): void
                public write(arg0: int): void
                public write(arg0: byte[], arg1: int, arg2: int): void
                public static class: java.lang.Class<any>
            }
            class ZipCoder {
                public static class: java.lang.Class<any>
            }
            interface ZipConstants {
                LOCSIG: long
                EXTSIG: long
                CENSIG: long
                ENDSIG: long
                LOCHDR: int
                EXTHDR: int
                CENHDR: int
                ENDHDR: int
                LOCVER: int
                LOCFLG: int
                LOCHOW: int
                LOCTIM: int
                LOCCRC: int
                LOCSIZ: int
                LOCLEN: int
                LOCNAM: int
                LOCEXT: int
                EXTCRC: int
                EXTSIZ: int
                EXTLEN: int
                CENVEM: int
                CENVER: int
                CENFLG: int
                CENHOW: int
                CENTIM: int
                CENCRC: int
                CENSIZ: int
                CENLEN: int
                CENNAM: int
                CENEXT: int
                CENCOM: int
                CENDSK: int
                CENATT: int
                CENATX: int
                CENOFF: int
                ENDSUB: int
                ENDTOT: int
                ENDSIZ: int
                ENDOFF: int
                ENDCOM: int
            }
            class ZipConstants64 {
                public static class: java.lang.Class<any>
            }
            class ZipEntry implements java.util.zip.ZipConstants , java.lang.Cloneable {
                public static STORED: int
                public static DEFLATED: int
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.util.zip.ZipEntry)
                public getName(): string
                public setTime(arg0: long): void
                public getTime(): long
                public setLastModifiedTime(arg0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry
                public getLastModifiedTime(): java.nio.file.attribute.FileTime
                public setLastAccessTime(arg0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry
                public getLastAccessTime(): java.nio.file.attribute.FileTime
                public setCreationTime(arg0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry
                public getCreationTime(): java.nio.file.attribute.FileTime
                public setSize(arg0: long): void
                public getSize(): long
                public getCompressedSize(): long
                public setCompressedSize(arg0: long): void
                public setCrc(arg0: long): void
                public getCrc(): long
                public setMethod(arg0: int): void
                public getMethod(): int
                public setExtra(arg0: byte[]): void
                public getExtra(): byte[]
                public setComment(arg0: java.lang.String | string): void
                public getComment(): string
                public isDirectory(): boolean
                public toString(): string
                public hashCode(): int
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class ZipError extends java.lang.InternalError {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class ZipException extends java.io.IOException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class ZipFile implements java.util.zip.ZipConstants , java.io.Closeable {
                public static OPEN_READ: int
                public static OPEN_DELETE: int
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.io.File, arg1: int)
                public constructor(arg0: java.io.File)
                public constructor(arg0: java.io.File, arg1: int, arg2: java.nio.charset.Charset)
                public constructor(arg0: java.lang.String | string, arg1: java.nio.charset.Charset)
                public constructor(arg0: java.io.File, arg1: java.nio.charset.Charset)
                public getComment(): string
                public getEntry(arg0: java.lang.String | string): java.util.zip.ZipEntry
                public getInputStream(arg0: java.util.zip.ZipEntry): java.io.InputStream
                public getName(): string
                public entries(): java.util.Enumeration<java.util.zip.ZipEntry>
                public stream(): java.util.stream.Stream<java.util.zip.ZipEntry>
                public size(): int
                public close(): void
                protected finalize(): void
                public static class: java.lang.Class<any>
            }
            class ZipInputStream extends java.util.zip.InflaterInputStream implements java.util.zip.ZipConstants {
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: java.io.InputStream, arg1: java.nio.charset.Charset)
                public getNextEntry(): java.util.zip.ZipEntry
                public closeEntry(): void
                public available(): int
                public read(arg0: byte[], arg1: int, arg2: int): int
                public skip(arg0: long): long
                public close(): void
                protected createZipEntry(arg0: java.lang.String | string): java.util.zip.ZipEntry
                public static class: java.lang.Class<any>
            }
            class ZipOutputStream extends java.util.zip.DeflaterOutputStream implements java.util.zip.ZipConstants {
                public static STORED: int
                public static DEFLATED: int
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
                public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.nio.charset.Charset)
                public setComment(arg0: java.lang.String | string): void
                public setMethod(arg0: int): void
                public setLevel(arg0: int): void
                public putNextEntry(arg0: java.util.zip.ZipEntry): void
                public closeEntry(): void
                public write(arg0: byte[], arg1: int, arg2: int): void
                public finish(): void
                public close(): void
                public static class: java.lang.Class<any>
            }
            class ZipUtils {
                public static winTimeToFileTime(arg0: long): java.nio.file.attribute.FileTime
                public static fileTimeToWinTime(arg0: java.nio.file.attribute.FileTime): long
                public static unixTimeToFileTime(arg0: long): java.nio.file.attribute.FileTime
                public static fileTimeToUnixTime(arg0: java.nio.file.attribute.FileTime): long
                public static extendedDosToJavaTime(arg0: long): long
                public static javaToExtendedDosTime(arg0: long): long
                public static get16(arg0: byte[], arg1: int): int
                public static get32(arg0: byte[], arg1: int): long
                public static get64(arg0: byte[], arg1: int): long
                public static class: java.lang.Class<any>
            }
        }
        abstract class AbstractCollection<E> implements java.util.Collection<E> {
            protected constructor()
            public iterator(): java.util.Iterator<E>
            public size(): int
            public isEmpty(): boolean
            public contains(arg0: java.lang.Object): boolean
            public toArray(): java.lang.Object[]
            public toArray<T>(arg0: T[]): T[]
            public add<T>(arg0: E): boolean
            public remove<T>(arg0: java.lang.Object): boolean
            public containsAll<T>(arg0: java.util.Collection<any>): boolean
            public addAll<T>(arg0: java.util.Collection<E>): boolean
            public removeAll<T>(arg0: java.util.Collection<any>): boolean
            public retainAll<T>(arg0: java.util.Collection<any>): boolean
            public clear<T>(): void
            public toString<T>(): string
            public static class: java.lang.Class<any>
        }
        abstract class AbstractList<E> extends java.util.AbstractCollection<E> implements java.util.List<E> {
            protected modCount: int
            protected constructor()
            public add(arg0: E): boolean
            public get(arg0: int): E
            public set(arg0: int, arg1: E): E
            public add(arg0: int, arg1: E): void
            public remove(arg0: int): E
            public indexOf(arg0: java.lang.Object): int
            public lastIndexOf(arg0: java.lang.Object): int
            public clear(): void
            public addAll(arg0: int, arg1: java.util.Collection<E>): boolean
            public iterator(): java.util.Iterator<E>
            public listIterator(): java.util.ListIterator<E>
            public listIterator(arg0: int): java.util.ListIterator<E>
            public subList(arg0: int, arg1: int): java.util.List<E>
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            protected removeRange(arg0: int, arg1: int): void
            public static class: java.lang.Class<any>
        }
        abstract class AbstractMap<K, V> implements java.util.Map<K, V> {
            protected constructor()
            public size(): int
            public isEmpty(): boolean
            public containsValue(arg0: java.lang.Object): boolean
            public containsKey(arg0: java.lang.Object): boolean
            public get(arg0: java.lang.Object): V
            public put(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object): V
            public putAll(arg0: java.util.Map<K, V>): void
            public clear(): void
            public keySet(): java.util.Set<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            protected clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        abstract class AbstractQueue<E> extends java.util.AbstractCollection<E> implements java.util.Queue<E> {
            protected constructor()
            public add(arg0: E): boolean
            public remove(): E
            public element(): E
            public clear(): void
            public addAll(arg0: java.util.Collection<E>): boolean
            public static class: java.lang.Class<any>
        }
        abstract class AbstractSequentialList<E> extends java.util.AbstractList<E> {
            protected constructor()
            public get(arg0: int): E
            public set(arg0: int, arg1: E): E
            public add(arg0: int, arg1: E): void
            public remove(arg0: int): E
            public addAll(arg0: int, arg1: java.util.Collection<E>): boolean
            public iterator(): java.util.Iterator<E>
            public listIterator(arg0: int): java.util.ListIterator<E>
            public static class: java.lang.Class<any>
        }
        abstract class AbstractSet<E> extends java.util.AbstractCollection<E> implements java.util.Set<E> {
            protected constructor()
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public removeAll(arg0: java.util.Collection<any>): boolean
            public static class: java.lang.Class<any>
        }
        class ArrayDeque<E> extends java.util.AbstractCollection<E> implements java.util.Deque<E> , java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.util.Collection<E>)
            public addFirst(arg0: E): void
            public addLast(arg0: E): void
            public offerFirst(arg0: E): boolean
            public offerLast(arg0: E): boolean
            public removeFirst(): E
            public removeLast(): E
            public pollFirst(): E
            public pollLast(): E
            public getFirst(): E
            public getLast(): E
            public peekFirst(): E
            public peekLast(): E
            public removeFirstOccurrence(arg0: java.lang.Object): boolean
            public removeLastOccurrence(arg0: java.lang.Object): boolean
            public add(arg0: E): boolean
            public offer(arg0: E): boolean
            public remove(): E
            public poll(): E
            public element(): E
            public peek(): E
            public push(arg0: E): void
            public pop(): E
            public size(): int
            public isEmpty(): boolean
            public iterator(): java.util.Iterator<E>
            public descendingIterator(): java.util.Iterator<E>
            public contains(arg0: java.lang.Object): boolean
            public remove(arg0: java.lang.Object): boolean
            public clear(): void
            public toArray(): java.lang.Object[]
            public toArray<T>(arg0: T[]): T[]
            public clone<T>(): java.util.ArrayDeque<E>
            public spliterator<T>(): java.util.Spliterator<E>
            public clone<T>(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class ArrayList<E> extends java.util.AbstractList<E> implements java.util.List<E> , java.util.RandomAccess , java.lang.Cloneable , java.io.Serializable {
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Collection<E>)
            public trimToSize(): void
            public ensureCapacity(arg0: int): void
            public size(): int
            public isEmpty(): boolean
            public contains(arg0: java.lang.Object): boolean
            public indexOf(arg0: java.lang.Object): int
            public lastIndexOf(arg0: java.lang.Object): int
            public clone(): java.lang.Object
            public toArray(): java.lang.Object[]
            public toArray<T>(arg0: T[]): T[]
            public get<T>(arg0: int): E
            public set<T>(arg0: int, arg1: E): E
            public add<T>(arg0: E): boolean
            public add<T>(arg0: int, arg1: E): void
            public remove<T>(arg0: int): E
            public remove<T>(arg0: java.lang.Object): boolean
            public clear<T>(): void
            public addAll<T>(arg0: java.util.Collection<E>): boolean
            public addAll<T>(arg0: int, arg1: java.util.Collection<E>): boolean
            protected removeRange<T>(arg0: int, arg1: int): void
            public removeAll<T>(arg0: java.util.Collection<any>): boolean
            public retainAll<T>(arg0: java.util.Collection<any>): boolean
            public listIterator<T>(arg0: int): java.util.ListIterator<E>
            public listIterator<T>(): java.util.ListIterator<E>
            public iterator<T>(): java.util.Iterator<E>
            public subList<T>(arg0: int, arg1: int): java.util.List<E>
            public forEach<T>(arg0: java.util.function$.Consumer$$TypeScript<E>): void
            public spliterator<T>(): java.util.Spliterator<E>
            public removeIf<T>(arg0: java.util.function$.Predicate<E>): boolean
            public replaceAll<T>(arg0: java.util.function$.UnaryOperator<E>): void
            public sort<T>(arg0: java.util.Comparator<E>): void
            public static class: java.lang.Class<any>
        }
        class ArrayPrefixHelpers {
            public static class: java.lang.Class<any>
        }
        class Arrays {
            public static sort(arg0: int[]): void
            public static sort(arg0: int[], arg1: int, arg2: int): void
            public static sort(arg0: long[]): void
            public static sort(arg0: long[], arg1: int, arg2: int): void
            public static sort(arg0: short[]): void
            public static sort(arg0: short[], arg1: int, arg2: int): void
            public static sort(arg0: char[]): void
            public static sort(arg0: char[], arg1: int, arg2: int): void
            public static sort(arg0: byte[]): void
            public static sort(arg0: byte[], arg1: int, arg2: int): void
            public static sort(arg0: float[]): void
            public static sort(arg0: float[], arg1: int, arg2: int): void
            public static sort(arg0: double[]): void
            public static sort(arg0: double[], arg1: int, arg2: int): void
            public static parallelSort(arg0: byte[]): void
            public static parallelSort(arg0: byte[], arg1: int, arg2: int): void
            public static parallelSort(arg0: char[]): void
            public static parallelSort(arg0: char[], arg1: int, arg2: int): void
            public static parallelSort(arg0: short[]): void
            public static parallelSort(arg0: short[], arg1: int, arg2: int): void
            public static parallelSort(arg0: int[]): void
            public static parallelSort(arg0: int[], arg1: int, arg2: int): void
            public static parallelSort(arg0: long[]): void
            public static parallelSort(arg0: long[], arg1: int, arg2: int): void
            public static parallelSort(arg0: float[]): void
            public static parallelSort(arg0: float[], arg1: int, arg2: int): void
            public static parallelSort(arg0: double[]): void
            public static parallelSort(arg0: double[], arg1: int, arg2: int): void
            public static parallelSort<T extends java.lang.Comparable<T>>(arg0: T[]): void
            public static parallelSort<T extends java.lang.Comparable<T>>(arg0: T[], arg1: int, arg2: int): void
            public static parallelSort<T>(arg0: T[], arg1: java.util.Comparator<T>): void
            public static parallelSort<T>(arg0: T[], arg1: int, arg2: int, arg3: java.util.Comparator<T>): void
            public static sort(arg0: java.lang.Object[]): void
            public static sort(arg0: java.lang.Object[], arg1: int, arg2: int): void
            public static sort<T>(arg0: T[], arg1: java.util.Comparator<T>): void
            public static sort<T>(arg0: T[], arg1: int, arg2: int, arg3: java.util.Comparator<T>): void
            public static parallelPrefix<T>(arg0: T[], arg1: java.util.function$.BinaryOperator<T>): void
            public static parallelPrefix<T>(arg0: T[], arg1: int, arg2: int, arg3: java.util.function$.BinaryOperator<T>): void
            public static parallelPrefix(arg0: long[], arg1: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): void
            public static parallelPrefix(arg0: long[], arg1: int, arg2: int, arg3: java.util.function$.LongBinaryOperator | java.util.function$.LongBinaryOperator$$Lambda): void
            public static parallelPrefix(arg0: double[], arg1: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): void
            public static parallelPrefix(arg0: double[], arg1: int, arg2: int, arg3: java.util.function$.DoubleBinaryOperator | java.util.function$.DoubleBinaryOperator$$Lambda): void
            public static parallelPrefix(arg0: int[], arg1: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): void
            public static parallelPrefix(arg0: int[], arg1: int, arg2: int, arg3: java.util.function$.IntBinaryOperator | java.util.function$.IntBinaryOperator$$Lambda): void
            public static binarySearch(arg0: long[], arg1: long): int
            public static binarySearch(arg0: long[], arg1: int, arg2: int, arg3: long): int
            public static binarySearch(arg0: int[], arg1: int): int
            public static binarySearch(arg0: int[], arg1: int, arg2: int, arg3: int): int
            public static binarySearch(arg0: short[], arg1: short): int
            public static binarySearch(arg0: short[], arg1: int, arg2: int, arg3: short): int
            public static binarySearch(arg0: char[], arg1: char): int
            public static binarySearch(arg0: char[], arg1: int, arg2: int, arg3: char): int
            public static binarySearch(arg0: byte[], arg1: byte): int
            public static binarySearch(arg0: byte[], arg1: int, arg2: int, arg3: byte): int
            public static binarySearch(arg0: double[], arg1: double): int
            public static binarySearch(arg0: double[], arg1: int, arg2: int, arg3: double): int
            public static binarySearch(arg0: float[], arg1: float): int
            public static binarySearch(arg0: float[], arg1: int, arg2: int, arg3: float): int
            public static binarySearch(arg0: java.lang.Object[], arg1: java.lang.Object): int
            public static binarySearch(arg0: java.lang.Object[], arg1: int, arg2: int, arg3: java.lang.Object): int
            public static binarySearch<T>(arg0: T[], arg1: T, arg2: java.util.Comparator<T>): int
            public static binarySearch<T>(arg0: T[], arg1: int, arg2: int, arg3: T, arg4: java.util.Comparator<T>): int
            public static equals(arg0: long[], arg1: long[]): boolean
            public static equals(arg0: int[], arg1: int[]): boolean
            public static equals(arg0: short[], arg1: short[]): boolean
            public static equals(arg0: char[], arg1: char[]): boolean
            public static equals(arg0: byte[], arg1: byte[]): boolean
            public static equals(arg0: boolean[], arg1: boolean[]): boolean
            public static equals(arg0: double[], arg1: double[]): boolean
            public static equals(arg0: float[], arg1: float[]): boolean
            public static equals(arg0: java.lang.Object[], arg1: java.lang.Object[]): boolean
            public static fill(arg0: long[], arg1: long): void
            public static fill(arg0: long[], arg1: int, arg2: int, arg3: long): void
            public static fill(arg0: int[], arg1: int): void
            public static fill(arg0: int[], arg1: int, arg2: int, arg3: int): void
            public static fill(arg0: short[], arg1: short): void
            public static fill(arg0: short[], arg1: int, arg2: int, arg3: short): void
            public static fill(arg0: char[], arg1: char): void
            public static fill(arg0: char[], arg1: int, arg2: int, arg3: char): void
            public static fill(arg0: byte[], arg1: byte): void
            public static fill(arg0: byte[], arg1: int, arg2: int, arg3: byte): void
            public static fill(arg0: boolean[], arg1: boolean): void
            public static fill(arg0: boolean[], arg1: int, arg2: int, arg3: boolean): void
            public static fill(arg0: double[], arg1: double): void
            public static fill(arg0: double[], arg1: int, arg2: int, arg3: double): void
            public static fill(arg0: float[], arg1: float): void
            public static fill(arg0: float[], arg1: int, arg2: int, arg3: float): void
            public static fill(arg0: java.lang.Object[], arg1: java.lang.Object): void
            public static fill(arg0: java.lang.Object[], arg1: int, arg2: int, arg3: java.lang.Object): void
            public static copyOf<T>(arg0: T[], arg1: int): T[]
            public static copyOf<T, U>(arg0: U[], arg1: int, arg2: java.lang.Class<T[]>): T[]
            public static copyOf(arg0: byte[], arg1: int): byte[]
            public static copyOf(arg0: short[], arg1: int): short[]
            public static copyOf(arg0: int[], arg1: int): int[]
            public static copyOf(arg0: long[], arg1: int): long[]
            public static copyOf(arg0: char[], arg1: int): char[]
            public static copyOf(arg0: float[], arg1: int): float[]
            public static copyOf(arg0: double[], arg1: int): double[]
            public static copyOf(arg0: boolean[], arg1: int): boolean[]
            public static copyOfRange<T>(arg0: T[], arg1: int, arg2: int): T[]
            public static copyOfRange<T, U>(arg0: U[], arg1: int, arg2: int, arg3: java.lang.Class<T[]>): T[]
            public static copyOfRange(arg0: byte[], arg1: int, arg2: int): byte[]
            public static copyOfRange(arg0: short[], arg1: int, arg2: int): short[]
            public static copyOfRange(arg0: int[], arg1: int, arg2: int): int[]
            public static copyOfRange(arg0: long[], arg1: int, arg2: int): long[]
            public static copyOfRange(arg0: char[], arg1: int, arg2: int): char[]
            public static copyOfRange(arg0: float[], arg1: int, arg2: int): float[]
            public static copyOfRange(arg0: double[], arg1: int, arg2: int): double[]
            public static copyOfRange(arg0: boolean[], arg1: int, arg2: int): boolean[]
            public static asList<T>(...arg0: T[]): java.util.List<T>
            public static hashCode(arg0: long[]): int
            public static hashCode(arg0: int[]): int
            public static hashCode(arg0: short[]): int
            public static hashCode(arg0: char[]): int
            public static hashCode(arg0: byte[]): int
            public static hashCode(arg0: boolean[]): int
            public static hashCode(arg0: float[]): int
            public static hashCode(arg0: double[]): int
            public static hashCode(arg0: java.lang.Object[]): int
            public static deepHashCode(arg0: java.lang.Object[]): int
            public static deepEquals(arg0: java.lang.Object[], arg1: java.lang.Object[]): boolean
            public static toString(arg0: long[]): string
            public static toString(arg0: int[]): string
            public static toString(arg0: short[]): string
            public static toString(arg0: char[]): string
            public static toString(arg0: byte[]): string
            public static toString(arg0: boolean[]): string
            public static toString(arg0: float[]): string
            public static toString(arg0: double[]): string
            public static toString(arg0: java.lang.Object[]): string
            public static deepToString(arg0: java.lang.Object[]): string
            public static setAll<T>(arg0: T[], arg1: java.util.function$.IntFunction<T> | java.util.function$.IntFunction$$Lambda<T>): void
            public static parallelSetAll<T>(arg0: T[], arg1: java.util.function$.IntFunction<T> | java.util.function$.IntFunction$$Lambda<T>): void
            public static setAll(arg0: int[], arg1: java.util.function$.IntUnaryOperator): void
            public static parallelSetAll(arg0: int[], arg1: java.util.function$.IntUnaryOperator): void
            public static setAll(arg0: long[], arg1: java.util.function$.IntToLongFunction | java.util.function$.IntToLongFunction$$Lambda): void
            public static parallelSetAll(arg0: long[], arg1: java.util.function$.IntToLongFunction | java.util.function$.IntToLongFunction$$Lambda): void
            public static setAll(arg0: double[], arg1: java.util.function$.IntToDoubleFunction | java.util.function$.IntToDoubleFunction$$Lambda): void
            public static parallelSetAll(arg0: double[], arg1: java.util.function$.IntToDoubleFunction | java.util.function$.IntToDoubleFunction$$Lambda): void
            public static spliterator<T>(arg0: T[]): java.util.Spliterator<T>
            public static spliterator<T>(arg0: T[], arg1: int, arg2: int): java.util.Spliterator<T>
            public static spliterator(arg0: int[]): java.util.Spliterator$OfInt
            public static spliterator(arg0: int[], arg1: int, arg2: int): java.util.Spliterator$OfInt
            public static spliterator(arg0: long[]): java.util.Spliterator$OfLong
            public static spliterator(arg0: long[], arg1: int, arg2: int): java.util.Spliterator$OfLong
            public static spliterator(arg0: double[]): java.util.Spliterator$OfDouble
            public static spliterator(arg0: double[], arg1: int, arg2: int): java.util.Spliterator$OfDouble
            public static stream<T>(arg0: T[]): java.util.stream.Stream<T>
            public static stream<T>(arg0: T[], arg1: int, arg2: int): java.util.stream.Stream<T>
            public static stream(arg0: int[]): java.util.stream.IntStream
            public static stream(arg0: int[], arg1: int, arg2: int): java.util.stream.IntStream
            public static stream(arg0: long[]): java.util.stream.LongStream
            public static stream(arg0: long[], arg1: int, arg2: int): java.util.stream.LongStream
            public static stream(arg0: double[]): java.util.stream.DoubleStream
            public static stream(arg0: double[], arg1: int, arg2: int): java.util.stream.DoubleStream
            public static class: java.lang.Class<any>
        }
        class ArraysParallelSortHelpers {
            public static class: java.lang.Class<any>
        }
        class Base64 {
            public static getEncoder(): java.util.Base64$Encoder
            public static getUrlEncoder(): java.util.Base64$Encoder
            public static getMimeEncoder(): java.util.Base64$Encoder
            public static getMimeEncoder(arg0: int, arg1: byte[]): java.util.Base64$Encoder
            public static getDecoder(): java.util.Base64$Decoder
            public static getUrlDecoder(): java.util.Base64$Decoder
            public static getMimeDecoder(): java.util.Base64$Decoder
            public static class: java.lang.Class<any>
        }
        class BitSet implements java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: int)
            public static valueOf(arg0: long[]): java.util.BitSet
            public static valueOf(arg0: java.nio.LongBuffer): java.util.BitSet
            public static valueOf(arg0: byte[]): java.util.BitSet
            public static valueOf(arg0: java.nio.ByteBuffer): java.util.BitSet
            public toByteArray(): byte[]
            public toLongArray(): long[]
            public flip(arg0: int): void
            public flip(arg0: int, arg1: int): void
            public set(arg0: int): void
            public set(arg0: int, arg1: boolean): void
            public set(arg0: int, arg1: int): void
            public set(arg0: int, arg1: int, arg2: boolean): void
            public clear(arg0: int): void
            public clear(arg0: int, arg1: int): void
            public clear(): void
            public get(arg0: int): boolean
            public get(arg0: int, arg1: int): java.util.BitSet
            public nextSetBit(arg0: int): int
            public nextClearBit(arg0: int): int
            public previousSetBit(arg0: int): int
            public previousClearBit(arg0: int): int
            public length(): int
            public isEmpty(): boolean
            public intersects(arg0: java.util.BitSet): boolean
            public cardinality(): int
            public and(arg0: java.util.BitSet): void
            public or(arg0: java.util.BitSet): void
            public xor(arg0: java.util.BitSet): void
            public andNot(arg0: java.util.BitSet): void
            public hashCode(): int
            public size(): int
            public equals(arg0: java.lang.Object): boolean
            public clone(): java.lang.Object
            public toString(): string
            public stream(): java.util.stream.IntStream
            public static class: java.lang.Class<any>
        }
        abstract class Calendar implements java.io.Serializable , java.lang.Cloneable , java.lang.Comparable<java.util.Calendar> {
            public static ERA: int
            public static YEAR: int
            public static MONTH: int
            public static WEEK_OF_YEAR: int
            public static WEEK_OF_MONTH: int
            public static DATE: int
            public static DAY_OF_MONTH: int
            public static DAY_OF_YEAR: int
            public static DAY_OF_WEEK: int
            public static DAY_OF_WEEK_IN_MONTH: int
            public static AM_PM: int
            public static HOUR: int
            public static HOUR_OF_DAY: int
            public static MINUTE: int
            public static SECOND: int
            public static MILLISECOND: int
            public static ZONE_OFFSET: int
            public static DST_OFFSET: int
            public static FIELD_COUNT: int
            public static SUNDAY: int
            public static MONDAY: int
            public static TUESDAY: int
            public static WEDNESDAY: int
            public static THURSDAY: int
            public static FRIDAY: int
            public static SATURDAY: int
            public static JANUARY: int
            public static FEBRUARY: int
            public static MARCH: int
            public static APRIL: int
            public static MAY: int
            public static JUNE: int
            public static JULY: int
            public static AUGUST: int
            public static SEPTEMBER: int
            public static OCTOBER: int
            public static NOVEMBER: int
            public static DECEMBER: int
            public static UNDECIMBER: int
            public static AM: int
            public static PM: int
            public static ALL_STYLES: int
            public static SHORT: int
            public static LONG: int
            public static NARROW_FORMAT: int
            public static NARROW_STANDALONE: int
            public static SHORT_FORMAT: int
            public static LONG_FORMAT: int
            public static SHORT_STANDALONE: int
            public static LONG_STANDALONE: int
            protected fields: int[]
            protected isSet: boolean[]
            protected time: long
            protected isTimeSet: boolean
            protected areFieldsSet: boolean
            protected constructor()
            protected constructor(arg0: java.util.TimeZone, arg1: java.util.Locale)
            public static getInstance(): java.util.Calendar
            public static getInstance(arg0: java.util.TimeZone): java.util.Calendar
            public static getInstance(arg0: java.util.Locale): java.util.Calendar
            public static getInstance(arg0: java.util.TimeZone, arg1: java.util.Locale): java.util.Calendar
            public static getAvailableLocales(): java.util.Locale[]
            protected computeTime(): void
            protected computeFields(): void
            public getTime(): java.util.Date
            public setTime(arg0: java.util.Date): void
            public getTimeInMillis(): long
            public setTimeInMillis(arg0: long): void
            public get(arg0: int): int
            protected internalGet(arg0: int): int
            public set(arg0: int, arg1: int): void
            public set(arg0: int, arg1: int, arg2: int): void
            public set(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): void
            public set(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void
            public clear(): void
            public clear(arg0: int): void
            public isSet(arg0: int): boolean
            public getDisplayName(arg0: int, arg1: int, arg2: java.util.Locale): string
            public getDisplayNames(arg0: int, arg1: int, arg2: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
            protected complete(): void
            public static getAvailableCalendarTypes(): java.util.Set<java.lang.String>
            public getCalendarType(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public before(arg0: java.lang.Object): boolean
            public after(arg0: java.lang.Object): boolean
            public compareTo(arg0: java.util.Calendar): int
            public add(arg0: int, arg1: int): void
            public roll(arg0: int, arg1: boolean): void
            public roll(arg0: int, arg1: int): void
            public setTimeZone(arg0: java.util.TimeZone): void
            public getTimeZone(): java.util.TimeZone
            public setLenient(arg0: boolean): void
            public isLenient(): boolean
            public setFirstDayOfWeek(arg0: int): void
            public getFirstDayOfWeek(): int
            public setMinimalDaysInFirstWeek(arg0: int): void
            public getMinimalDaysInFirstWeek(): int
            public isWeekDateSupported(): boolean
            public getWeekYear(): int
            public setWeekDate(arg0: int, arg1: int, arg2: int): void
            public getWeeksInWeekYear(): int
            public getMinimum(arg0: int): int
            public getMaximum(arg0: int): int
            public getGreatestMinimum(arg0: int): int
            public getLeastMaximum(arg0: int): int
            public getActualMinimum(arg0: int): int
            public getActualMaximum(arg0: int): int
            public clone(): java.lang.Object
            public toString(): string
            public toInstant(): java.time.Instant
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        interface Collection<E> extends java.lang.Iterable<E> {
            size(): int
            isEmpty(): boolean
            contains(arg0: java.lang.Object): boolean
            iterator(): java.util.Iterator<E>
            toArray(): java.lang.Object[]
            toArray<T>(arg0: T[]): T[]
            add(arg0: E): boolean
            remove(arg0: java.lang.Object): boolean
            containsAll(arg0: java.util.Collection<any>): boolean
            addAll(arg0: java.util.Collection<E>): boolean
            removeAll(arg0: java.util.Collection<any>): boolean
            removeIf(arg0: java.util.function$.Predicate<E>): boolean
            retainAll(arg0: java.util.Collection<any>): boolean
            clear(): void
            equals(arg0: java.lang.Object): boolean
            hashCode(): int
            spliterator(): java.util.Spliterator<E>
            stream(): java.util.stream.Stream<E>
            parallelStream(): java.util.stream.Stream<E>
        }
        class Collections {
            public static EMPTY_SET: java.util.Set
            public static EMPTY_LIST: java.util.List
            public static EMPTY_MAP: java.util.Map
            public static sort<T extends java.lang.Comparable<T>>(arg0: java.util.List<T>): void
            public static sort<T>(arg0: java.util.List<T>, arg1: java.util.Comparator<T>): void
            public static binarySearch<T>(arg0: java.util.List<java.lang.Comparable<T>>, arg1: T): int
            public static binarySearch<T>(arg0: java.util.List<T>, arg1: T, arg2: java.util.Comparator<T>): int
            public static reverse(arg0: java.util.List<any>): void
            public static shuffle(arg0: java.util.List<any>): void
            public static shuffle(arg0: java.util.List<any>, arg1: java.util.Random): void
            public static swap(arg0: java.util.List<any>, arg1: int, arg2: int): void
            public static fill<T>(arg0: java.util.List<T>, arg1: T): void
            public static copy<T>(arg0: java.util.List<T>, arg1: java.util.List<T>): void
            public static min<T extends java.lang.Comparable<T>>(arg0: java.util.Collection<T>): T
            public static min<T>(arg0: java.util.Collection<T>, arg1: java.util.Comparator<T>): T
            public static max<T extends java.lang.Comparable<T>>(arg0: java.util.Collection<T>): T
            public static max<T>(arg0: java.util.Collection<T>, arg1: java.util.Comparator<T>): T
            public static rotate(arg0: java.util.List<any>, arg1: int): void
            public static replaceAll<T>(arg0: java.util.List<T>, arg1: T, arg2: T): boolean
            public static indexOfSubList(arg0: java.util.List<any>, arg1: java.util.List<any>): int
            public static lastIndexOfSubList(arg0: java.util.List<any>, arg1: java.util.List<any>): int
            public static unmodifiableCollection<T>(arg0: java.util.Collection<T>): java.util.Collection<T>
            public static unmodifiableSet<T>(arg0: java.util.Set<T>): java.util.Set<T>
            public static unmodifiableSortedSet<T>(arg0: java.util.SortedSet<T>): java.util.SortedSet<T>
            public static unmodifiableNavigableSet<T>(arg0: java.util.NavigableSet<T>): java.util.NavigableSet<T>
            public static unmodifiableList<T>(arg0: java.util.List<T>): java.util.List<T>
            public static unmodifiableMap<K, V>(arg0: java.util.Map<K, V>): java.util.Map<K, V>
            public static unmodifiableSortedMap<K, V>(arg0: java.util.SortedMap<K, V>): java.util.SortedMap<K, V>
            public static unmodifiableNavigableMap<K, V>(arg0: java.util.NavigableMap<K, V>): java.util.NavigableMap<K, V>
            public static synchronizedCollection<T>(arg0: java.util.Collection<T>): java.util.Collection<T>
            public static synchronizedSet<T>(arg0: java.util.Set<T>): java.util.Set<T>
            public static synchronizedSortedSet<T>(arg0: java.util.SortedSet<T>): java.util.SortedSet<T>
            public static synchronizedNavigableSet<T>(arg0: java.util.NavigableSet<T>): java.util.NavigableSet<T>
            public static synchronizedList<T>(arg0: java.util.List<T>): java.util.List<T>
            public static synchronizedMap<K, V>(arg0: java.util.Map<K, V>): java.util.Map<K, V>
            public static synchronizedSortedMap<K, V>(arg0: java.util.SortedMap<K, V>): java.util.SortedMap<K, V>
            public static synchronizedNavigableMap<K, V>(arg0: java.util.NavigableMap<K, V>): java.util.NavigableMap<K, V>
            public static checkedCollection<E>(arg0: java.util.Collection<E>, arg1: java.lang.Class<E>): java.util.Collection<E>
            public static checkedQueue<E>(arg0: java.util.Queue<E>, arg1: java.lang.Class<E>): java.util.Queue<E>
            public static checkedSet<E>(arg0: java.util.Set<E>, arg1: java.lang.Class<E>): java.util.Set<E>
            public static checkedSortedSet<E>(arg0: java.util.SortedSet<E>, arg1: java.lang.Class<E>): java.util.SortedSet<E>
            public static checkedNavigableSet<E>(arg0: java.util.NavigableSet<E>, arg1: java.lang.Class<E>): java.util.NavigableSet<E>
            public static checkedList<E>(arg0: java.util.List<E>, arg1: java.lang.Class<E>): java.util.List<E>
            public static checkedMap<K, V>(arg0: java.util.Map<K, V>, arg1: java.lang.Class<K>, arg2: java.lang.Class<V>): java.util.Map<K, V>
            public static checkedSortedMap<K, V>(arg0: java.util.SortedMap<K, V>, arg1: java.lang.Class<K>, arg2: java.lang.Class<V>): java.util.SortedMap<K, V>
            public static checkedNavigableMap<K, V>(arg0: java.util.NavigableMap<K, V>, arg1: java.lang.Class<K>, arg2: java.lang.Class<V>): java.util.NavigableMap<K, V>
            public static emptyIterator<T>(): java.util.Iterator<T>
            public static emptyListIterator<T>(): java.util.ListIterator<T>
            public static emptyEnumeration<T>(): java.util.Enumeration<T>
            public static emptySet<T>(): java.util.Set<T>
            public static emptySortedSet<E>(): java.util.SortedSet<E>
            public static emptyNavigableSet<E>(): java.util.NavigableSet<E>
            public static emptyList<T>(): java.util.List<T>
            public static emptyMap<K, V>(): java.util.Map<K, V>
            public static emptySortedMap<K, V>(): java.util.SortedMap<K, V>
            public static emptyNavigableMap<K, V>(): java.util.NavigableMap<K, V>
            public static singleton<T>(arg0: T): java.util.Set<T>
            public static singletonList<T>(arg0: T): java.util.List<T>
            public static singletonMap<K, V>(arg0: K, arg1: V): java.util.Map<K, V>
            public static nCopies<T>(arg0: int, arg1: T): java.util.List<T>
            public static reverseOrder<T>(): java.util.Comparator<T>
            public static reverseOrder<T>(arg0: java.util.Comparator<T>): java.util.Comparator<T>
            public static enumeration<T>(arg0: java.util.Collection<T>): java.util.Enumeration<T>
            public static list<T>(arg0: java.util.Enumeration<T>): java.util.ArrayList<T>
            public static frequency(arg0: java.util.Collection<any>, arg1: java.lang.Object): int
            public static disjoint(arg0: java.util.Collection<any>, arg1: java.util.Collection<any>): boolean
            public static addAll<T>(arg0: java.util.Collection<T>, ...arg1: T[]): boolean
            public static newSetFromMap<E>(arg0: java.util.Map<E, java.lang.Boolean>): java.util.Set<E>
            public static asLifoQueue<T>(arg0: java.util.Deque<T>): java.util.Queue<T>
            public static class: java.lang.Class<any>
        }
        class ComparableTimSort {
            public static class: java.lang.Class<any>
        }
        interface Comparator<T> {
            compare(arg0: T, arg1: T): int
            equals(arg0: java.lang.Object): boolean
            reversed(): java.util.Comparator<T>
            thenComparing(arg0: java.util.Comparator<T>): java.util.Comparator<T>
            thenComparing<U>(arg0: java.util.function$.Function<T, U>, arg1: java.util.Comparator<U>): java.util.Comparator<T>
            thenComparing<U extends java.lang.Comparable<U>>(arg0: java.util.function$.Function<T, U>): java.util.Comparator<T>
            thenComparingInt<U extends java.lang.Comparable<U>>(arg0: java.util.function$.ToIntFunction<T> | java.util.function$.ToIntFunction$$Lambda<T>): java.util.Comparator<T>
            thenComparingLong<U extends java.lang.Comparable<U>>(arg0: java.util.function$.ToLongFunction<T> | java.util.function$.ToLongFunction$$Lambda<T>): java.util.Comparator<T>
            thenComparingDouble<U extends java.lang.Comparable<U>>(arg0: java.util.function$.ToDoubleFunction<T> | java.util.function$.ToDoubleFunction$$Lambda<T>): java.util.Comparator<T>
            reverseOrder<T extends java.lang.Comparable<T>>(): java.util.Comparator<T>
            naturalOrder<T extends java.lang.Comparable<T>>(): java.util.Comparator<T>
            nullsFirst<T>(arg0: java.util.Comparator<T>): java.util.Comparator<T>
            nullsLast<T>(arg0: java.util.Comparator<T>): java.util.Comparator<T>
            comparing<T, U>(arg0: java.util.function$.Function<T, U>, arg1: java.util.Comparator<U>): java.util.Comparator<T>
            comparing<T, U extends java.lang.Comparable<U>>(arg0: java.util.function$.Function<T, U>): java.util.Comparator<T>
            comparingInt<T>(arg0: java.util.function$.ToIntFunction<T> | java.util.function$.ToIntFunction$$Lambda<T>): java.util.Comparator<T>
            comparingLong<T>(arg0: java.util.function$.ToLongFunction<T> | java.util.function$.ToLongFunction$$Lambda<T>): java.util.Comparator<T>
            comparingDouble<T>(arg0: java.util.function$.ToDoubleFunction<T> | java.util.function$.ToDoubleFunction$$Lambda<T>): java.util.Comparator<T>
        }
        class Comparators {
            public static class: java.lang.Class<any>
        }
        class ConcurrentModificationException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.Throwable)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class Currency implements java.io.Serializable {
            public static getInstance(arg0: java.lang.String | string): java.util.Currency
            public static getInstance(arg0: java.util.Locale): java.util.Currency
            public static getAvailableCurrencies(): java.util.Set<java.util.Currency>
            public getCurrencyCode(): string
            public getSymbol(): string
            public getSymbol(arg0: java.util.Locale): string
            public getDefaultFractionDigits(): int
            public getNumericCode(): int
            public getDisplayName(): string
            public getDisplayName(arg0: java.util.Locale): string
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class Date implements java.io.Serializable , java.lang.Cloneable , java.lang.Comparable<java.util.Date> {
            public constructor()
            public constructor(arg0: long)
            public constructor(arg0: int, arg1: int, arg2: int)
            public constructor(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int)
            public constructor(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int)
            public constructor(arg0: java.lang.String | string)
            public clone(): java.lang.Object
            public static UTC(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): long
            public static parse(arg0: java.lang.String | string): long
            public getYear(): int
            public setYear(arg0: int): void
            public getMonth(): int
            public setMonth(arg0: int): void
            public getDate(): int
            public setDate(arg0: int): void
            public getDay(): int
            public getHours(): int
            public setHours(arg0: int): void
            public getMinutes(): int
            public setMinutes(arg0: int): void
            public getSeconds(): int
            public setSeconds(arg0: int): void
            public getTime(): long
            public setTime(arg0: long): void
            public before(arg0: java.util.Date): boolean
            public after(arg0: java.util.Date): boolean
            public equals(arg0: java.lang.Object): boolean
            public compareTo(arg0: java.util.Date): int
            public hashCode(): int
            public toString(): string
            public toLocaleString(): string
            public toGMTString(): string
            public getTimezoneOffset(): int
            public static from(arg0: java.time.Instant): java.util.Date
            public toInstant(): java.time.Instant
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        interface Deque<E> extends java.util.Queue<E> {
            addFirst(arg0: E): void
            addLast(arg0: E): void
            offerFirst(arg0: E): boolean
            offerLast(arg0: E): boolean
            removeFirst(): E
            removeLast(): E
            pollFirst(): E
            pollLast(): E
            getFirst(): E
            getLast(): E
            peekFirst(): E
            peekLast(): E
            removeFirstOccurrence(arg0: java.lang.Object): boolean
            removeLastOccurrence(arg0: java.lang.Object): boolean
            add(arg0: E): boolean
            offer(arg0: E): boolean
            remove(): E
            poll(): E
            element(): E
            peek(): E
            push(arg0: E): void
            pop(): E
            remove(arg0: java.lang.Object): boolean
            contains(arg0: java.lang.Object): boolean
            size(): int
            iterator(): java.util.Iterator<E>
            descendingIterator(): java.util.Iterator<E>
        }
        abstract class Dictionary<K, V> {
            public constructor()
            public size(): int
            public isEmpty(): boolean
            public keys(): java.util.Enumeration<K>
            public elements(): java.util.Enumeration<V>
            public get(arg0: java.lang.Object): V
            public put(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object): V
            public static class: java.lang.Class<any>
        }
        class DoubleSummaryStatistics implements java.util.function$.DoubleConsumer {
            public constructor()
            public accept(arg0: double): void
            public combine(arg0: java.util.DoubleSummaryStatistics): void
            public getCount(): long
            public getSum(): double
            public getMin(): double
            public getMax(): double
            public getAverage(): double
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class DualPivotQuicksort {
            public static class: java.lang.Class<any>
        }
        class DuplicateFormatFlagsException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string)
            public getFlags(): string
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class EmptyStackException extends java.lang.RuntimeException {
            public constructor()
            public static class: java.lang.Class<any>
        }
        class EnumMap<K extends java.lang.Enum<K>, V> extends java.util.AbstractMap<K, V> implements java.io.Serializable , java.lang.Cloneable {
            public constructor(arg0: java.lang.Class<K>)
            public constructor(arg0: java.util.EnumMap<K, V>)
            public constructor(arg0: java.util.Map<K, V>)
            public size(): int
            public containsValue(arg0: java.lang.Object): boolean
            public containsKey(arg0: java.lang.Object): boolean
            public get(arg0: java.lang.Object): V
            public put(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object): V
            public putAll(arg0: java.util.Map<K, V>): void
            public clear(): void
            public keySet(): java.util.Set<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public clone(): java.util.EnumMap<K, V>
            public clone(): java.lang.Object
            public put(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
            public static class: java.lang.Class<any>
        }
        abstract class EnumSet<E extends java.lang.Enum<E>> extends java.util.AbstractSet<E> implements java.lang.Cloneable , java.io.Serializable {
            public static noneOf<E extends java.lang.Enum<E>>(arg0: java.lang.Class<E>): java.util.EnumSet<E>
            public static allOf<E extends java.lang.Enum<E>>(arg0: java.lang.Class<E>): java.util.EnumSet<E>
            public static copyOf<E extends java.lang.Enum<E>>(arg0: java.util.EnumSet<E>): java.util.EnumSet<E>
            public static copyOf<E extends java.lang.Enum<E>>(arg0: java.util.Collection<E>): java.util.EnumSet<E>
            public static complementOf<E extends java.lang.Enum<E>>(arg0: java.util.EnumSet<E>): java.util.EnumSet<E>
            public static of<E extends java.lang.Enum<E>>(arg0: E): java.util.EnumSet<E>
            public static of<E extends java.lang.Enum<E>>(arg0: E, arg1: E): java.util.EnumSet<E>
            public static of<E extends java.lang.Enum<E>>(arg0: E, arg1: E, arg2: E): java.util.EnumSet<E>
            public static of<E extends java.lang.Enum<E>>(arg0: E, arg1: E, arg2: E, arg3: E): java.util.EnumSet<E>
            public static of<E extends java.lang.Enum<E>>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): java.util.EnumSet<E>
            public static of<E extends java.lang.Enum<E>>(arg0: E, ...arg1: E[]): java.util.EnumSet<E>
            public static range<E extends java.lang.Enum<E>>(arg0: E, arg1: E): java.util.EnumSet<E>
            public clone(): java.util.EnumSet<E>
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        interface Enumeration<E> {
            hasMoreElements(): boolean
            nextElement(): E
        }
        interface EventListener {
        }
        abstract class EventListenerProxy<T extends java.util.EventListener> implements java.util.EventListener {
            public constructor(arg0: T)
            public getListener(): T
            public static class: java.lang.Class<any>
        }
        class EventObject implements java.io.Serializable {
            protected source: java.lang.Object
            public constructor(arg0: java.lang.Object)
            public getSource(): java.lang.Object
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class FormatFlagsConversionMismatchException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string, arg1: char)
            public getFlags(): string
            public getConversion(): char
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        interface Formattable {
            formatTo(arg0: java.util.Formatter | java.util.Formatter$$Lambda, arg1: int, arg2: int, arg3: int): void
        }
        interface Formattable$$Lambda {
            (arg0: java.util.Formatter | java.util.Formatter$$Lambda, arg1: int, arg2: int, arg3: int): void
        }
        class FormattableFlags {
            public static LEFT_JUSTIFY: int
            public static UPPERCASE: int
            public static ALTERNATE: int
            public static class: java.lang.Class<any>
        }
        class Formatter implements java.io.Closeable , java.io.Flushable {
            public constructor()
            public constructor(arg0: java.lang.Appendable)
            public constructor(arg0: java.util.Locale)
            public constructor(arg0: java.lang.Appendable, arg1: java.util.Locale)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.util.Locale)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string, arg2: java.util.Locale)
            public constructor(arg0: java.io.PrintStream)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string)
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string, arg2: java.util.Locale)
            public locale(): java.util.Locale
            public out(): java.lang.Appendable
            public toString(): string
            public flush(): void
            public close(): void
            public ioException(): java.io.IOException
            public format(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): java.util.Formatter
            public format(arg0: java.util.Locale, arg1: java.lang.String | string, ...arg2: java.lang.Object[]): java.util.Formatter
            public static class: java.lang.Class<any>
        }
        class Formatter$$Lambda implements java.io.Closeable , java.io.Flushable {
            public constructor()
        }
        class FormatterClosedException extends java.lang.IllegalStateException {
            public constructor()
            public static class: java.lang.Class<any>
        }
        class GregorianCalendar extends java.util.Calendar {
            public static BC: int
            public static AD: int
            public constructor()
            public constructor(arg0: java.util.TimeZone)
            public constructor(arg0: java.util.Locale)
            public constructor(arg0: java.util.TimeZone, arg1: java.util.Locale)
            public constructor(arg0: int, arg1: int, arg2: int)
            public constructor(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int)
            public constructor(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int)
            public setGregorianChange(arg0: java.util.Date): void
            public getGregorianChange(): java.util.Date
            public isLeapYear(arg0: int): boolean
            public getCalendarType(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public add(arg0: int, arg1: int): void
            public roll(arg0: int, arg1: boolean): void
            public roll(arg0: int, arg1: int): void
            public getMinimum(arg0: int): int
            public getMaximum(arg0: int): int
            public getGreatestMinimum(arg0: int): int
            public getLeastMaximum(arg0: int): int
            public getActualMinimum(arg0: int): int
            public getActualMaximum(arg0: int): int
            public clone(): java.lang.Object
            public getTimeZone(): java.util.TimeZone
            public setTimeZone(arg0: java.util.TimeZone): void
            public isWeekDateSupported(): boolean
            public getWeekYear(): int
            public setWeekDate(arg0: int, arg1: int, arg2: int): void
            public getWeeksInWeekYear(): int
            protected computeFields(): void
            protected computeTime(): void
            public toZonedDateTime(): java.time.ZonedDateTime
            public static from(arg0: java.time.ZonedDateTime): java.util.GregorianCalendar
            public static class: java.lang.Class<any>
        }
        class HashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.Map<K, V> , java.lang.Cloneable , java.io.Serializable {
            public constructor(arg0: int, arg1: float)
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Map<K, V>)
            public size(): int
            public isEmpty(): boolean
            public get(arg0: java.lang.Object): V
            public containsKey(arg0: java.lang.Object): boolean
            public put(arg0: K, arg1: V): V
            public putAll(arg0: java.util.Map<K, V>): void
            public remove(arg0: java.lang.Object): V
            public clear(): void
            public containsValue(arg0: java.lang.Object): boolean
            public keySet(): java.util.Set<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public getOrDefault(arg0: java.lang.Object, arg1: V): V
            public putIfAbsent(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
            public replace(arg0: K, arg1: V, arg2: V): boolean
            public replace(arg0: K, arg1: V): V
            public computeIfAbsent(arg0: K, arg1: java.util.function$.Function<K, V>): V
            public computeIfPresent(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
            public compute(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
            public merge(arg0: K, arg1: V, arg2: java.util.function$.BiFunction<V, V, V>): V
            public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class HashSet<E> extends java.util.AbstractSet<E> implements java.util.Set<E> , java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: java.util.Collection<E>)
            public constructor(arg0: int, arg1: float)
            public constructor(arg0: int)
            public iterator(): java.util.Iterator<E>
            public size(): int
            public isEmpty(): boolean
            public contains(arg0: java.lang.Object): boolean
            public add(arg0: E): boolean
            public remove(arg0: java.lang.Object): boolean
            public clear(): void
            public clone(): java.lang.Object
            public spliterator(): java.util.Spliterator<E>
            public static class: java.lang.Class<any>
        }
        class Hashtable<K, V> extends java.util.Dictionary<K, V> implements java.util.Map<K, V> , java.lang.Cloneable , java.io.Serializable {
            public constructor(arg0: int, arg1: float)
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Map<K, V>)
            public size(): int
            public isEmpty(): boolean
            public keys(): java.util.Enumeration<K>
            public elements(): java.util.Enumeration<V>
            public contains(arg0: java.lang.Object): boolean
            public containsValue(arg0: java.lang.Object): boolean
            public containsKey(arg0: java.lang.Object): boolean
            public get(arg0: java.lang.Object): V
            protected rehash(): void
            public put(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object): V
            public putAll(arg0: java.util.Map<K, V>): void
            public clear(): void
            public clone(): java.lang.Object
            public toString(): string
            public keySet(): java.util.Set<K>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public values(): java.util.Collection<V>
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getOrDefault(arg0: java.lang.Object, arg1: V): V
            public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            public putIfAbsent(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
            public replace(arg0: K, arg1: V, arg2: V): boolean
            public replace(arg0: K, arg1: V): V
            public computeIfAbsent(arg0: K, arg1: java.util.function$.Function<K, V>): V
            public computeIfPresent(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
            public compute(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
            public merge(arg0: K, arg1: V, arg2: java.util.function$.BiFunction<V, V, V>): V
            public static class: java.lang.Class<any>
        }
        class IdentityHashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.Map<K, V> , java.io.Serializable , java.lang.Cloneable {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.util.Map<K, V>)
            public size(): int
            public isEmpty(): boolean
            public get(arg0: java.lang.Object): V
            public containsKey(arg0: java.lang.Object): boolean
            public containsValue(arg0: java.lang.Object): boolean
            public put(arg0: K, arg1: V): V
            public putAll(arg0: java.util.Map<K, V>): void
            public remove(arg0: java.lang.Object): V
            public clear(): void
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public clone(): java.lang.Object
            public keySet(): java.util.Set<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            public static class: java.lang.Class<any>
        }
        class IllegalFormatCodePointException extends java.util.IllegalFormatException {
            public constructor(arg0: int)
            public getCodePoint(): int
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class IllegalFormatConversionException extends java.util.IllegalFormatException {
            public constructor(arg0: char, arg1: java.lang.Class<any>)
            public getConversion(): char
            public getArgumentClass(): java.lang.Class<any>
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class IllegalFormatException extends java.lang.IllegalArgumentException {
            public static class: java.lang.Class<any>
        }
        class IllegalFormatFlagsException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string)
            public getFlags(): string
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class IllegalFormatPrecisionException extends java.util.IllegalFormatException {
            public constructor(arg0: int)
            public getPrecision(): int
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class IllegalFormatWidthException extends java.util.IllegalFormatException {
            public constructor(arg0: int)
            public getWidth(): int
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class IllformedLocaleException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: int)
            public getErrorIndex(): int
            public static class: java.lang.Class<any>
        }
        class InputMismatchException extends java.util.NoSuchElementException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class IntSummaryStatistics implements java.util.function$.IntConsumer {
            public constructor()
            public accept(arg0: int): void
            public combine(arg0: java.util.IntSummaryStatistics): void
            public getCount(): long
            public getSum(): long
            public getMin(): int
            public getMax(): int
            public getAverage(): double
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class InvalidPropertiesFormatException extends java.io.IOException {
            public constructor(arg0: java.lang.Throwable)
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        interface Iterator<E> {
            hasNext(): boolean
            next(): E
            remove(): void
            forEachRemaining(arg0: java.util.function$.Consumer$$TypeScript<E>): void
        }
        class JapaneseImperialCalendar extends java.util.Calendar {
            public static BEFORE_MEIJI: int
            public static MEIJI: int
            public static TAISHO: int
            public static SHOWA: int
            public static HEISEI: int
            public getCalendarType(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public add(arg0: int, arg1: int): void
            public roll(arg0: int, arg1: boolean): void
            public roll(arg0: int, arg1: int): void
            public getDisplayName(arg0: int, arg1: int, arg2: java.util.Locale): string
            public getDisplayNames(arg0: int, arg1: int, arg2: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
            public getMinimum(arg0: int): int
            public getMaximum(arg0: int): int
            public getGreatestMinimum(arg0: int): int
            public getLeastMaximum(arg0: int): int
            public getActualMinimum(arg0: int): int
            public getActualMaximum(arg0: int): int
            public clone(): java.lang.Object
            public getTimeZone(): java.util.TimeZone
            public setTimeZone(arg0: java.util.TimeZone): void
            protected computeFields(): void
            protected computeTime(): void
            public static class: java.lang.Class<any>
        }
        class JumboEnumSet<E extends java.lang.Enum<E>> extends java.util.EnumSet<E> {
            public iterator(): java.util.Iterator<E>
            public size(): int
            public isEmpty(): boolean
            public contains(arg0: java.lang.Object): boolean
            public add(arg0: E): boolean
            public remove(arg0: java.lang.Object): boolean
            public containsAll(arg0: java.util.Collection<any>): boolean
            public addAll(arg0: java.util.Collection<E>): boolean
            public removeAll(arg0: java.util.Collection<any>): boolean
            public retainAll(arg0: java.util.Collection<any>): boolean
            public clear(): void
            public equals(arg0: java.lang.Object): boolean
            public clone(): java.util.EnumSet<E>
            public add(arg0: java.lang.Object): boolean
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class LinkedHashMap<K, V> extends java.util.HashMap<K, V> implements java.util.Map<K, V> {
            public constructor(arg0: int, arg1: float)
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Map<K, V>)
            public constructor(arg0: int, arg1: float, arg2: boolean)
            public containsValue(arg0: java.lang.Object): boolean
            public get(arg0: java.lang.Object): V
            public getOrDefault(arg0: java.lang.Object, arg1: V): V
            public clear(): void
            protected removeEldestEntry(arg0: java.util.Map$Entry<K, V>): boolean
            public keySet(): java.util.Set<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            public static class: java.lang.Class<any>
        }
        class LinkedHashSet<E> extends java.util.HashSet<E> implements java.util.Set<E> , java.lang.Cloneable , java.io.Serializable {
            public constructor(arg0: int, arg1: float)
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Collection<E>)
            public spliterator(): java.util.Spliterator<E>
            public static class: java.lang.Class<any>
        }
        class LinkedList<E> extends java.util.AbstractSequentialList<E> implements java.util.List<E> , java.util.Deque<E> , java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: java.util.Collection<E>)
            public getFirst(): E
            public getLast(): E
            public removeFirst(): E
            public removeLast(): E
            public addFirst(arg0: E): void
            public addLast(arg0: E): void
            public contains(arg0: java.lang.Object): boolean
            public size(): int
            public add(arg0: E): boolean
            public remove(arg0: java.lang.Object): boolean
            public addAll(arg0: java.util.Collection<E>): boolean
            public addAll(arg0: int, arg1: java.util.Collection<E>): boolean
            public clear(): void
            public get(arg0: int): E
            public set(arg0: int, arg1: E): E
            public add(arg0: int, arg1: E): void
            public remove(arg0: int): E
            public indexOf(arg0: java.lang.Object): int
            public lastIndexOf(arg0: java.lang.Object): int
            public peek(): E
            public element(): E
            public poll(): E
            public remove(): E
            public offer(arg0: E): boolean
            public offerFirst(arg0: E): boolean
            public offerLast(arg0: E): boolean
            public peekFirst(): E
            public peekLast(): E
            public pollFirst(): E
            public pollLast(): E
            public push(arg0: E): void
            public pop(): E
            public removeFirstOccurrence(arg0: java.lang.Object): boolean
            public removeLastOccurrence(arg0: java.lang.Object): boolean
            public listIterator(arg0: int): java.util.ListIterator<E>
            public descendingIterator(): java.util.Iterator<E>
            public clone(): java.lang.Object
            public toArray(): java.lang.Object[]
            public toArray<T>(arg0: T[]): T[]
            public spliterator<T>(): java.util.Spliterator<E>
            public static class: java.lang.Class<any>
        }
        interface List<E> extends java.util.Collection<E> {
            size(): int
            isEmpty(): boolean
            contains(arg0: java.lang.Object): boolean
            iterator(): java.util.Iterator<E>
            toArray(): java.lang.Object[]
            toArray<T>(arg0: T[]): T[]
            add(arg0: E): boolean
            remove(arg0: java.lang.Object): boolean
            containsAll(arg0: java.util.Collection<any>): boolean
            addAll(arg0: java.util.Collection<E>): boolean
            addAll(arg0: int, arg1: java.util.Collection<E>): boolean
            removeAll(arg0: java.util.Collection<any>): boolean
            retainAll(arg0: java.util.Collection<any>): boolean
            replaceAll(arg0: java.util.function$.UnaryOperator<E>): void
            sort(arg0: java.util.Comparator<E>): void
            clear(): void
            equals(arg0: java.lang.Object): boolean
            hashCode(): int
            get(arg0: int): E
            set(arg0: int, arg1: E): E
            add(arg0: int, arg1: E): void
            remove(arg0: int): E
            indexOf(arg0: java.lang.Object): int
            lastIndexOf(arg0: java.lang.Object): int
            listIterator(): java.util.ListIterator<E>
            listIterator(arg0: int): java.util.ListIterator<E>
            subList(arg0: int, arg1: int): java.util.List<E>
            spliterator(): java.util.Spliterator<E>
        }
        interface ListIterator<E> extends java.util.Iterator<E> {
            hasNext(): boolean
            next(): E
            hasPrevious(): boolean
            previous(): E
            nextIndex(): int
            previousIndex(): int
            remove(): void
            set(arg0: E): void
            add(arg0: E): void
        }
        abstract class ListResourceBundle extends java.util.ResourceBundle {
            public constructor()
            public handleGetObject(arg0: java.lang.String | string): java.lang.Object
            public getKeys(): java.util.Enumeration<java.lang.String>
            protected handleKeySet(): java.util.Set<java.lang.String>
            protected getContents(): java.lang.Object[][]
            public static class: java.lang.Class<any>
        }
        class Locale implements java.lang.Cloneable , java.io.Serializable {
            public static ENGLISH: java.util.Locale
            public static FRENCH: java.util.Locale
            public static GERMAN: java.util.Locale
            public static ITALIAN: java.util.Locale
            public static JAPANESE: java.util.Locale
            public static KOREAN: java.util.Locale
            public static CHINESE: java.util.Locale
            public static SIMPLIFIED_CHINESE: java.util.Locale
            public static TRADITIONAL_CHINESE: java.util.Locale
            public static FRANCE: java.util.Locale
            public static GERMANY: java.util.Locale
            public static ITALY: java.util.Locale
            public static JAPAN: java.util.Locale
            public static KOREA: java.util.Locale
            public static CHINA: java.util.Locale
            public static PRC: java.util.Locale
            public static TAIWAN: java.util.Locale
            public static UK: java.util.Locale
            public static US: java.util.Locale
            public static CANADA: java.util.Locale
            public static CANADA_FRENCH: java.util.Locale
            public static ROOT: java.util.Locale
            public static PRIVATE_USE_EXTENSION: char
            public static UNICODE_LOCALE_EXTENSION: char
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.lang.String | string)
            public static getDefault(): java.util.Locale
            public static getDefault(arg0: java.util.Locale$Category): java.util.Locale
            public static setDefault(arg0: java.util.Locale): void
            public static setDefault(arg0: java.util.Locale$Category, arg1: java.util.Locale): void
            public static getAvailableLocales(): java.util.Locale[]
            public static getISOCountries(): java.lang.String[]
            public static getISOLanguages(): java.lang.String[]
            public getLanguage(): string
            public getScript(): string
            public getCountry(): string
            public getVariant(): string
            public hasExtensions(): boolean
            public stripExtensions(): java.util.Locale
            public getExtension(arg0: char): string
            public getExtensionKeys(): java.util.Set<java.lang.Character>
            public getUnicodeLocaleAttributes(): java.util.Set<java.lang.String>
            public getUnicodeLocaleType(arg0: java.lang.String | string): string
            public getUnicodeLocaleKeys(): java.util.Set<java.lang.String>
            public toString(): string
            public toLanguageTag(): string
            public static forLanguageTag(arg0: java.lang.String | string): java.util.Locale
            public getISO3Language(): string
            public getISO3Country(): string
            public getDisplayLanguage(): string
            public getDisplayLanguage(arg0: java.util.Locale): string
            public getDisplayScript(): string
            public getDisplayScript(arg0: java.util.Locale): string
            public getDisplayCountry(): string
            public getDisplayCountry(arg0: java.util.Locale): string
            public getDisplayVariant(): string
            public getDisplayVariant(arg0: java.util.Locale): string
            public getDisplayName(): string
            public getDisplayName(arg0: java.util.Locale): string
            public clone(): java.lang.Object
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public static filter(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.util.Locale>, arg2: java.util.Locale$FilteringMode): java.util.List<java.util.Locale>
            public static filter(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.util.Locale>): java.util.List<java.util.Locale>
            public static filterTags(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.lang.String>, arg2: java.util.Locale$FilteringMode): java.util.List<java.lang.String>
            public static filterTags(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.lang.String>): java.util.List<java.lang.String>
            public static lookup(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.util.Locale>): java.util.Locale
            public static lookupTag(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.lang.String>): string
            public static class: java.lang.Class<any>
        }
        class LocaleISOData {
            public static class: java.lang.Class<any>
        }
        class LongSummaryStatistics implements java.util.function$.LongConsumer , java.util.function$.IntConsumer {
            public constructor()
            public accept(arg0: int): void
            public accept(arg0: long): void
            public combine(arg0: java.util.LongSummaryStatistics): void
            public getCount(): long
            public getSum(): long
            public getMin(): long
            public getMax(): long
            public getAverage(): double
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface Map<K, V> {
            size(): int
            isEmpty(): boolean
            containsKey(arg0: java.lang.Object): boolean
            containsValue(arg0: java.lang.Object): boolean
            get(arg0: java.lang.Object): V
            put(arg0: K, arg1: V): V
            remove(arg0: java.lang.Object): V
            putAll(arg0: java.util.Map<K, V>): void
            clear(): void
            keySet(): java.util.Set<K>
            values(): java.util.Collection<V>
            entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            equals(arg0: java.lang.Object): boolean
            hashCode(): int
            getOrDefault(arg0: java.lang.Object, arg1: V): V
            forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            putIfAbsent(arg0: K, arg1: V): V
            remove(arg0: java.lang.Object, arg1: java.lang.Object): boolean
            replace(arg0: K, arg1: V, arg2: V): boolean
            replace(arg0: K, arg1: V): V
            computeIfAbsent(arg0: K, arg1: java.util.function$.Function<K, V>): V
            computeIfPresent(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
            compute(arg0: K, arg1: java.util.function$.BiFunction<K, V, V>): V
            merge(arg0: K, arg1: V, arg2: java.util.function$.BiFunction<V, V, V>): V
        }
        class MissingFormatArgumentException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string)
            public getFormatSpecifier(): string
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class MissingFormatWidthException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string)
            public getFormatSpecifier(): string
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class MissingResourceException extends java.lang.RuntimeException {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
            public getClassName(): string
            public getKey(): string
            public static class: java.lang.Class<any>
        }
        interface NavigableMap<K, V> extends java.util.SortedMap<K, V> {
            lowerEntry(arg0: K): java.util.Map$Entry<K, V>
            lowerKey(arg0: K): K
            floorEntry(arg0: K): java.util.Map$Entry<K, V>
            floorKey(arg0: K): K
            ceilingEntry(arg0: K): java.util.Map$Entry<K, V>
            ceilingKey(arg0: K): K
            higherEntry(arg0: K): java.util.Map$Entry<K, V>
            higherKey(arg0: K): K
            firstEntry(): java.util.Map$Entry<K, V>
            lastEntry(): java.util.Map$Entry<K, V>
            pollFirstEntry(): java.util.Map$Entry<K, V>
            pollLastEntry(): java.util.Map$Entry<K, V>
            descendingMap(): java.util.NavigableMap<K, V>
            navigableKeySet(): java.util.NavigableSet<K>
            descendingKeySet(): java.util.NavigableSet<K>
            subMap(arg0: K, arg1: boolean, arg2: K, arg3: boolean): java.util.NavigableMap<K, V>
            headMap(arg0: K, arg1: boolean): java.util.NavigableMap<K, V>
            tailMap(arg0: K, arg1: boolean): java.util.NavigableMap<K, V>
            subMap(arg0: K, arg1: K): java.util.SortedMap<K, V>
            headMap(arg0: K): java.util.SortedMap<K, V>
            tailMap(arg0: K): java.util.SortedMap<K, V>
        }
        interface NavigableSet<E> extends java.util.SortedSet<E> {
            lower(arg0: E): E
            floor(arg0: E): E
            ceiling(arg0: E): E
            higher(arg0: E): E
            pollFirst(): E
            pollLast(): E
            iterator(): java.util.Iterator<E>
            descendingSet(): java.util.NavigableSet<E>
            descendingIterator(): java.util.Iterator<E>
            subSet(arg0: E, arg1: boolean, arg2: E, arg3: boolean): java.util.NavigableSet<E>
            headSet(arg0: E, arg1: boolean): java.util.NavigableSet<E>
            tailSet(arg0: E, arg1: boolean): java.util.NavigableSet<E>
            subSet(arg0: E, arg1: E): java.util.SortedSet<E>
            headSet(arg0: E): java.util.SortedSet<E>
            tailSet(arg0: E): java.util.SortedSet<E>
        }
        class NoSuchElementException extends java.lang.RuntimeException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class Objects {
            public static equals(arg0: java.lang.Object, arg1: java.lang.Object): boolean
            public static deepEquals(arg0: java.lang.Object, arg1: java.lang.Object): boolean
            public static hashCode(arg0: java.lang.Object): int
            public static hash(...arg0: java.lang.Object[]): int
            public static toString(arg0: java.lang.Object): string
            public static toString(arg0: java.lang.Object, arg1: java.lang.String | string): string
            public static compare<T>(arg0: T, arg1: T, arg2: java.util.Comparator<T>): int
            public static requireNonNull<T>(arg0: T): T
            public static requireNonNull<T>(arg0: T, arg1: java.lang.String | string): T
            public static isNull(arg0: java.lang.Object): boolean
            public static nonNull(arg0: java.lang.Object): boolean
            public static requireNonNull<T>(arg0: T, arg1: java.util.function$.Supplier<java.lang.String> | java.util.function$.Supplier$$Lambda<java.lang.String>): T
            public static class: java.lang.Class<any>
        }
        class Observable {
            public constructor()
            public addObserver(arg0: java.util.Observer | java.util.Observer$$Lambda): void
            public deleteObserver(arg0: java.util.Observer | java.util.Observer$$Lambda): void
            public notifyObservers(): void
            public notifyObservers(arg0: java.lang.Object): void
            public deleteObservers(): void
            protected setChanged(): void
            protected clearChanged(): void
            public hasChanged(): boolean
            public countObservers(): int
            public static class: java.lang.Class<any>
        }
        interface Observer {
            update(arg0: java.util.Observable, arg1: java.lang.Object): void
        }
        interface Observer$$Lambda {
            (arg0: java.util.Observable, arg1: java.lang.Object): void
        }
        class Optional<T> {
            public static empty<T>(): java.util.Optional<T>
            public static of<T>(arg0: T): java.util.Optional<T>
            public static ofNullable<T>(arg0: T): java.util.Optional<T>
            public get(): T
            public isPresent(): boolean
            public ifPresent(arg0: java.util.function$.Consumer$$TypeScript<T>): void
            public filter(arg0: java.util.function$.Predicate<T>): java.util.Optional<T>
            public map<U>(arg0: java.util.function$.Function<T, U>): java.util.Optional<U>
            public flatMap<U>(arg0: java.util.function$.Function<T, java.util.Optional<U>>): java.util.Optional<U>
            public orElse<U>(arg0: T): T
            public orElseGet<U>(arg0: java.util.function$.Supplier<T> | java.util.function$.Supplier$$Lambda<T>): T
            public orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function$.Supplier<X> | java.util.function$.Supplier$$Lambda<X>): T
            public equals<X extends java.lang.Throwable>(arg0: java.lang.Object): boolean
            public hashCode<X extends java.lang.Throwable>(): int
            public toString<X extends java.lang.Throwable>(): string
            public static class: java.lang.Class<any>
        }
        class OptionalDouble {
            public static empty(): java.util.OptionalDouble
            public static of(arg0: double): java.util.OptionalDouble
            public getAsDouble(): double
            public isPresent(): boolean
            public ifPresent(arg0: java.util.function$.DoubleConsumer): void
            public orElse(arg0: double): double
            public orElseGet(arg0: java.util.function$.DoubleSupplier | java.util.function$.DoubleSupplier$$Lambda): double
            public orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function$.Supplier<X> | java.util.function$.Supplier$$Lambda<X>): double
            public equals<X extends java.lang.Throwable>(arg0: java.lang.Object): boolean
            public hashCode<X extends java.lang.Throwable>(): int
            public toString<X extends java.lang.Throwable>(): string
            public static class: java.lang.Class<any>
        }
        class OptionalInt {
            public static empty(): java.util.OptionalInt
            public static of(arg0: int): java.util.OptionalInt
            public getAsInt(): int
            public isPresent(): boolean
            public ifPresent(arg0: java.util.function$.IntConsumer): void
            public orElse(arg0: int): int
            public orElseGet(arg0: java.util.function$.IntSupplier | java.util.function$.IntSupplier$$Lambda): int
            public orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function$.Supplier<X> | java.util.function$.Supplier$$Lambda<X>): int
            public equals<X extends java.lang.Throwable>(arg0: java.lang.Object): boolean
            public hashCode<X extends java.lang.Throwable>(): int
            public toString<X extends java.lang.Throwable>(): string
            public static class: java.lang.Class<any>
        }
        class OptionalLong {
            public static empty(): java.util.OptionalLong
            public static of(arg0: long): java.util.OptionalLong
            public getAsLong(): long
            public isPresent(): boolean
            public ifPresent(arg0: java.util.function$.LongConsumer): void
            public orElse(arg0: long): long
            public orElseGet(arg0: java.util.function$.LongSupplier | java.util.function$.LongSupplier$$Lambda): long
            public orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function$.Supplier<X> | java.util.function$.Supplier$$Lambda<X>): long
            public equals<X extends java.lang.Throwable>(arg0: java.lang.Object): boolean
            public hashCode<X extends java.lang.Throwable>(): int
            public toString<X extends java.lang.Throwable>(): string
            public static class: java.lang.Class<any>
        }
        interface PrimitiveIterator<T, T_CONS> extends java.util.Iterator<T> {
            forEachRemaining(arg0: T_CONS): void
        }
        class PriorityQueue<E> extends java.util.AbstractQueue<E> implements java.io.Serializable {
            public constructor()
            public constructor(arg0: int)
            public constructor(arg0: java.util.Comparator<E>)
            public constructor(arg0: int, arg1: java.util.Comparator<E>)
            public constructor(arg0: java.util.Collection<E>)
            public constructor(arg0: java.util.PriorityQueue<E>)
            public constructor(arg0: java.util.SortedSet<E>)
            public add(arg0: E): boolean
            public offer(arg0: E): boolean
            public peek(): E
            public remove(arg0: java.lang.Object): boolean
            public contains(arg0: java.lang.Object): boolean
            public toArray(): java.lang.Object[]
            public toArray<T>(arg0: T[]): T[]
            public iterator<T>(): java.util.Iterator<E>
            public size<T>(): int
            public clear<T>(): void
            public poll<T>(): E
            public comparator<T>(): java.util.Comparator<E>
            public spliterator<T>(): java.util.Spliterator<E>
            public static class: java.lang.Class<any>
        }
        class Properties extends java.util.Hashtable<java.lang.Object, java.lang.Object> {
            protected defaults: java.util.Properties
            public constructor()
            public constructor(arg0: java.util.Properties)
            public setProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): java.lang.Object
            public load(arg0: java.io.Reader): void
            public load(arg0: java.io.InputStream): void
            public save(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string): void
            public store(arg0: java.io.Writer | java.io.Writer$$Lambda, arg1: java.lang.String | string): void
            public store(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string): void
            public loadFromXML(arg0: java.io.InputStream): void
            public storeToXML(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string): void
            public storeToXML(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string, arg2: java.lang.String | string): void
            public getProperty(arg0: java.lang.String | string): string
            public getProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): string
            public propertyNames(): java.util.Enumeration<any>
            public stringPropertyNames(): java.util.Set<java.lang.String>
            public list(arg0: java.io.PrintStream): void
            public list(arg0: java.io.PrintWriter): void
            public static class: java.lang.Class<any>
        }
        class PropertyPermission extends java.security.BasicPermission {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        class PropertyResourceBundle extends java.util.ResourceBundle {
            public constructor(arg0: java.io.InputStream)
            public constructor(arg0: java.io.Reader)
            public handleGetObject(arg0: java.lang.String | string): java.lang.Object
            public getKeys(): java.util.Enumeration<java.lang.String>
            protected handleKeySet(): java.util.Set<java.lang.String>
            public static class: java.lang.Class<any>
        }
        interface Queue<E> extends java.util.Collection<E> {
            add(arg0: E): boolean
            offer(arg0: E): boolean
            remove(): E
            poll(): E
            element(): E
            peek(): E
        }
        class Random implements java.io.Serializable {
            public constructor()
            public constructor(arg0: long)
            public setSeed(arg0: long): void
            protected next(arg0: int): int
            public nextBytes(arg0: byte[]): void
            public nextInt(): int
            public nextInt(arg0: int): int
            public nextLong(): long
            public nextBoolean(): boolean
            public nextFloat(): float
            public nextDouble(): double
            public nextGaussian(): double
            public ints(arg0: long): java.util.stream.IntStream
            public ints(): java.util.stream.IntStream
            public ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream
            public ints(arg0: int, arg1: int): java.util.stream.IntStream
            public longs(arg0: long): java.util.stream.LongStream
            public longs(): java.util.stream.LongStream
            public longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream
            public longs(arg0: long, arg1: long): java.util.stream.LongStream
            public doubles(arg0: long): java.util.stream.DoubleStream
            public doubles(): java.util.stream.DoubleStream
            public doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream
            public doubles(arg0: double, arg1: double): java.util.stream.DoubleStream
            public static class: java.lang.Class<any>
        }
        interface RandomAccess {
        }
        class RegularEnumSet<E extends java.lang.Enum<E>> extends java.util.EnumSet<E> {
            public iterator(): java.util.Iterator<E>
            public size(): int
            public isEmpty(): boolean
            public contains(arg0: java.lang.Object): boolean
            public add(arg0: E): boolean
            public remove(arg0: java.lang.Object): boolean
            public containsAll(arg0: java.util.Collection<any>): boolean
            public addAll(arg0: java.util.Collection<E>): boolean
            public removeAll(arg0: java.util.Collection<any>): boolean
            public retainAll(arg0: java.util.Collection<any>): boolean
            public clear(): void
            public equals(arg0: java.lang.Object): boolean
            public add(arg0: java.lang.Object): boolean
            public static class: java.lang.Class<any>
        }
        abstract class ResourceBundle {
            protected parent: java.util.ResourceBundle
            public getBaseBundleName(): string
            public constructor()
            public getString(arg0: java.lang.String | string): string
            public getStringArray(arg0: java.lang.String | string): java.lang.String[]
            public getObject(arg0: java.lang.String | string): java.lang.Object
            public getLocale(): java.util.Locale
            protected setParent(arg0: java.util.ResourceBundle): void
            public static getBundle(arg0: java.lang.String | string): java.util.ResourceBundle
            public static getBundle(arg0: java.lang.String | string, arg1: java.util.ResourceBundle$Control): java.util.ResourceBundle
            public static getBundle(arg0: java.lang.String | string, arg1: java.util.Locale): java.util.ResourceBundle
            public static getBundle(arg0: java.lang.String | string, arg1: java.util.Locale, arg2: java.util.ResourceBundle$Control): java.util.ResourceBundle
            public static getBundle(arg0: java.lang.String | string, arg1: java.util.Locale, arg2: java.lang.ClassLoader): java.util.ResourceBundle
            public static getBundle(arg0: java.lang.String | string, arg1: java.util.Locale, arg2: java.lang.ClassLoader, arg3: java.util.ResourceBundle$Control): java.util.ResourceBundle
            public static clearCache(): void
            public static clearCache(arg0: java.lang.ClassLoader): void
            protected handleGetObject(arg0: java.lang.String | string): java.lang.Object
            public getKeys(): java.util.Enumeration<java.lang.String>
            public containsKey(arg0: java.lang.String | string): boolean
            public keySet(): java.util.Set<java.lang.String>
            protected handleKeySet(): java.util.Set<java.lang.String>
            public static class: java.lang.Class<any>
        }
        class Scanner implements java.util.Iterator<java.lang.String> , java.io.Closeable {
            public constructor(arg0: java.lang.Readable | java.lang.Readable$$Lambda)
            public constructor(arg0: java.io.InputStream)
            public constructor(arg0: java.io.InputStream, arg1: java.lang.String | string)
            public constructor(arg0: java.io.File)
            public constructor(arg0: java.io.File, arg1: java.lang.String | string)
            public constructor(arg0: java.nio.file.Path)
            public constructor(arg0: java.nio.file.Path, arg1: java.lang.String | string)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.nio.channels.ReadableByteChannel)
            public constructor(arg0: java.nio.channels.ReadableByteChannel, arg1: java.lang.String | string)
            public close(): void
            public ioException(): java.io.IOException
            public delimiter(): java.util.regex.Pattern
            public useDelimiter(arg0: java.util.regex.Pattern): java.util.Scanner
            public useDelimiter(arg0: java.lang.String | string): java.util.Scanner
            public locale(): java.util.Locale
            public useLocale(arg0: java.util.Locale): java.util.Scanner
            public radix(): int
            public useRadix(arg0: int): java.util.Scanner
            public match(): java.util.regex.MatchResult
            public toString(): string
            public hasNext(): boolean
            public next(): string
            public remove(): void
            public hasNext(arg0: java.lang.String | string): boolean
            public next(arg0: java.lang.String | string): string
            public hasNext(arg0: java.util.regex.Pattern): boolean
            public next(arg0: java.util.regex.Pattern): string
            public hasNextLine(): boolean
            public nextLine(): string
            public findInLine(arg0: java.lang.String | string): string
            public findInLine(arg0: java.util.regex.Pattern): string
            public findWithinHorizon(arg0: java.lang.String | string, arg1: int): string
            public findWithinHorizon(arg0: java.util.regex.Pattern, arg1: int): string
            public skip(arg0: java.util.regex.Pattern): java.util.Scanner
            public skip(arg0: java.lang.String | string): java.util.Scanner
            public hasNextBoolean(): boolean
            public nextBoolean(): boolean
            public hasNextByte(): boolean
            public hasNextByte(arg0: int): boolean
            public nextByte(): byte
            public nextByte(arg0: int): byte
            public hasNextShort(): boolean
            public hasNextShort(arg0: int): boolean
            public nextShort(): short
            public nextShort(arg0: int): short
            public hasNextInt(): boolean
            public hasNextInt(arg0: int): boolean
            public nextInt(): int
            public nextInt(arg0: int): int
            public hasNextLong(): boolean
            public hasNextLong(arg0: int): boolean
            public nextLong(): long
            public nextLong(arg0: int): long
            public hasNextFloat(): boolean
            public nextFloat(): float
            public hasNextDouble(): boolean
            public nextDouble(): double
            public hasNextBigInteger(): boolean
            public hasNextBigInteger(arg0: int): boolean
            public nextBigInteger(): java.math.BigInteger
            public nextBigInteger(arg0: int): java.math.BigInteger
            public hasNextBigDecimal(): boolean
            public nextBigDecimal(): java.math.BigDecimal
            public reset(): java.util.Scanner
            public next(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class ServiceConfigurationError extends java.lang.Error {
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
            public static class: java.lang.Class<any>
        }
        class ServiceLoader<S> implements java.lang.Iterable<S> {
            public reload(): void
            public iterator(): java.util.Iterator<S>
            public static load<S>(arg0: java.lang.Class<S>, arg1: java.lang.ClassLoader): java.util.ServiceLoader<S>
            public static load<S>(arg0: java.lang.Class<S>): java.util.ServiceLoader<S>
            public static loadInstalled<S>(arg0: java.lang.Class<S>): java.util.ServiceLoader<S>
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface Set<E> extends java.util.Collection<E> {
            size(): int
            isEmpty(): boolean
            contains(arg0: java.lang.Object): boolean
            iterator(): java.util.Iterator<E>
            toArray(): java.lang.Object[]
            toArray<T>(arg0: T[]): T[]
            add(arg0: E): boolean
            remove(arg0: java.lang.Object): boolean
            containsAll(arg0: java.util.Collection<any>): boolean
            addAll(arg0: java.util.Collection<E>): boolean
            retainAll(arg0: java.util.Collection<any>): boolean
            removeAll(arg0: java.util.Collection<any>): boolean
            clear(): void
            equals(arg0: java.lang.Object): boolean
            hashCode(): int
            spliterator(): java.util.Spliterator<E>
        }
        class SimpleTimeZone extends java.util.TimeZone {
            public static WALL_TIME: int
            public static STANDARD_TIME: int
            public static UTC_TIME: int
            public constructor(arg0: int, arg1: java.lang.String | string)
            public constructor(arg0: int, arg1: java.lang.String | string, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: int)
            public constructor(arg0: int, arg1: java.lang.String | string, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: int, arg10: int)
            public constructor(arg0: int, arg1: java.lang.String | string, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: int, arg10: int, arg11: int, arg12: int)
            public setStartYear(arg0: int): void
            public setStartRule(arg0: int, arg1: int, arg2: int, arg3: int): void
            public setStartRule(arg0: int, arg1: int, arg2: int): void
            public setStartRule(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void
            public setEndRule(arg0: int, arg1: int, arg2: int, arg3: int): void
            public setEndRule(arg0: int, arg1: int, arg2: int): void
            public setEndRule(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void
            public getOffset(arg0: long): int
            public getOffset(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): int
            public getRawOffset(): int
            public setRawOffset(arg0: int): void
            public setDSTSavings(arg0: int): void
            public getDSTSavings(): int
            public useDaylightTime(): boolean
            public observesDaylightTime(): boolean
            public inDaylightTime(arg0: java.util.Date): boolean
            public clone(): java.lang.Object
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public hasSameRules(arg0: java.util.TimeZone): boolean
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface SortedMap<K, V> extends java.util.Map<K, V> {
            comparator(): java.util.Comparator<K>
            subMap(arg0: K, arg1: K): java.util.SortedMap<K, V>
            headMap(arg0: K): java.util.SortedMap<K, V>
            tailMap(arg0: K): java.util.SortedMap<K, V>
            firstKey(): K
            lastKey(): K
            keySet(): java.util.Set<K>
            values(): java.util.Collection<V>
            entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
        }
        interface SortedSet<E> extends java.util.Set<E> {
            comparator(): java.util.Comparator<E>
            subSet(arg0: E, arg1: E): java.util.SortedSet<E>
            headSet(arg0: E): java.util.SortedSet<E>
            tailSet(arg0: E): java.util.SortedSet<E>
            first(): E
            last(): E
            spliterator(): java.util.Spliterator<E>
        }
        interface Spliterator<T> {
            ORDERED: int
            DISTINCT: int
            SORTED: int
            SIZED: int
            NONNULL: int
            IMMUTABLE: int
            CONCURRENT: int
            SUBSIZED: int
            tryAdvance(arg0: java.util.function$.Consumer$$TypeScript<T>): boolean
            forEachRemaining(arg0: java.util.function$.Consumer$$TypeScript<T>): void
            trySplit(): java.util.Spliterator<T>
            estimateSize(): long
            getExactSizeIfKnown(): long
            characteristics(): int
            hasCharacteristics(arg0: int): boolean
            getComparator(): java.util.Comparator<T>
        }
        class Spliterators {
            public static emptySpliterator<T>(): java.util.Spliterator<T>
            public static emptyIntSpliterator(): java.util.Spliterator$OfInt
            public static emptyLongSpliterator(): java.util.Spliterator$OfLong
            public static emptyDoubleSpliterator(): java.util.Spliterator$OfDouble
            public static spliterator<T>(arg0: java.lang.Object[], arg1: int): java.util.Spliterator<T>
            public static spliterator<T>(arg0: java.lang.Object[], arg1: int, arg2: int, arg3: int): java.util.Spliterator<T>
            public static spliterator(arg0: int[], arg1: int): java.util.Spliterator$OfInt
            public static spliterator(arg0: int[], arg1: int, arg2: int, arg3: int): java.util.Spliterator$OfInt
            public static spliterator(arg0: long[], arg1: int): java.util.Spliterator$OfLong
            public static spliterator(arg0: long[], arg1: int, arg2: int, arg3: int): java.util.Spliterator$OfLong
            public static spliterator(arg0: double[], arg1: int): java.util.Spliterator$OfDouble
            public static spliterator(arg0: double[], arg1: int, arg2: int, arg3: int): java.util.Spliterator$OfDouble
            public static spliterator<T>(arg0: java.util.Collection<T>, arg1: int): java.util.Spliterator<T>
            public static spliterator<T>(arg0: java.util.Iterator<T>, arg1: long, arg2: int): java.util.Spliterator<T>
            public static spliteratorUnknownSize<T>(arg0: java.util.Iterator<T>, arg1: int): java.util.Spliterator<T>
            public static spliterator(arg0: java.util.PrimitiveIterator$OfInt, arg1: long, arg2: int): java.util.Spliterator$OfInt
            public static spliteratorUnknownSize(arg0: java.util.PrimitiveIterator$OfInt, arg1: int): java.util.Spliterator$OfInt
            public static spliterator(arg0: java.util.PrimitiveIterator$OfLong, arg1: long, arg2: int): java.util.Spliterator$OfLong
            public static spliteratorUnknownSize(arg0: java.util.PrimitiveIterator$OfLong, arg1: int): java.util.Spliterator$OfLong
            public static spliterator(arg0: java.util.PrimitiveIterator$OfDouble, arg1: long, arg2: int): java.util.Spliterator$OfDouble
            public static spliteratorUnknownSize(arg0: java.util.PrimitiveIterator$OfDouble, arg1: int): java.util.Spliterator$OfDouble
            public static iterator<T>(arg0: java.util.Spliterator<T>): java.util.Iterator<T>
            public static iterator(arg0: java.util.Spliterator$OfInt): java.util.PrimitiveIterator$OfInt
            public static iterator(arg0: java.util.Spliterator$OfLong): java.util.PrimitiveIterator$OfLong
            public static iterator(arg0: java.util.Spliterator$OfDouble): java.util.PrimitiveIterator$OfDouble
            public static class: java.lang.Class<any>
        }
        class SplittableRandom {
            public constructor(arg0: long)
            public constructor()
            public split(): java.util.SplittableRandom
            public nextInt(): int
            public nextInt(arg0: int): int
            public nextInt(arg0: int, arg1: int): int
            public nextLong(): long
            public nextLong(arg0: long): long
            public nextLong(arg0: long, arg1: long): long
            public nextDouble(): double
            public nextDouble(arg0: double): double
            public nextDouble(arg0: double, arg1: double): double
            public nextBoolean(): boolean
            public ints(arg0: long): java.util.stream.IntStream
            public ints(): java.util.stream.IntStream
            public ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream
            public ints(arg0: int, arg1: int): java.util.stream.IntStream
            public longs(arg0: long): java.util.stream.LongStream
            public longs(): java.util.stream.LongStream
            public longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream
            public longs(arg0: long, arg1: long): java.util.stream.LongStream
            public doubles(arg0: long): java.util.stream.DoubleStream
            public doubles(): java.util.stream.DoubleStream
            public doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream
            public doubles(arg0: double, arg1: double): java.util.stream.DoubleStream
            public static class: java.lang.Class<any>
        }
        class Stack<E> extends java.util.Vector<E> {
            public constructor()
            public push(arg0: E): E
            public pop(): E
            public peek(): E
            public empty(): boolean
            public search(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class StringJoiner {
            public constructor(arg0: java.lang.CharSequence)
            public constructor(arg0: java.lang.CharSequence, arg1: java.lang.CharSequence, arg2: java.lang.CharSequence)
            public setEmptyValue(arg0: java.lang.CharSequence): java.util.StringJoiner
            public toString(): string
            public add(arg0: java.lang.CharSequence): java.util.StringJoiner
            public merge(arg0: java.util.StringJoiner): java.util.StringJoiner
            public length(): int
            public static class: java.lang.Class<any>
        }
        class StringTokenizer implements java.util.Enumeration<java.lang.Object> {
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: boolean)
            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
            public constructor(arg0: java.lang.String | string)
            public hasMoreTokens(): boolean
            public nextToken(): string
            public nextToken(arg0: java.lang.String | string): string
            public hasMoreElements(): boolean
            public nextElement(): java.lang.Object
            public countTokens(): int
            public static class: java.lang.Class<any>
        }
        class TimSort<T> {
            public static class: java.lang.Class<any>
        }
        abstract class TimeZone implements java.io.Serializable , java.lang.Cloneable {
            public static SHORT: int
            public static LONG: int
            public constructor()
            public getOffset(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): int
            public getOffset(arg0: long): int
            public setRawOffset(arg0: int): void
            public getRawOffset(): int
            public getID(): string
            public setID(arg0: java.lang.String | string): void
            public getDisplayName(): string
            public getDisplayName(arg0: java.util.Locale): string
            public getDisplayName(arg0: boolean, arg1: int): string
            public getDisplayName(arg0: boolean, arg1: int, arg2: java.util.Locale): string
            public getDSTSavings(): int
            public useDaylightTime(): boolean
            public observesDaylightTime(): boolean
            public inDaylightTime(arg0: java.util.Date): boolean
            public static getTimeZone(arg0: java.lang.String | string): java.util.TimeZone
            public static getTimeZone(arg0: java.time.ZoneId): java.util.TimeZone
            public toZoneId(): java.time.ZoneId
            public static getAvailableIDs(arg0: int): java.lang.String[]
            public static getAvailableIDs(): java.lang.String[]
            public static getDefault(): java.util.TimeZone
            public static setDefault(arg0: java.util.TimeZone): void
            public hasSameRules(arg0: java.util.TimeZone): boolean
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class Timer {
            public constructor()
            public constructor(arg0: boolean)
            public constructor(arg0: java.lang.String | string)
            public constructor(arg0: java.lang.String | string, arg1: boolean)
            public schedule(arg0: java.util.TimerTask | java.util.TimerTask$$Lambda, arg1: long): void
            public schedule(arg0: java.util.TimerTask | java.util.TimerTask$$Lambda, arg1: java.util.Date): void
            public schedule(arg0: java.util.TimerTask | java.util.TimerTask$$Lambda, arg1: long, arg2: long): void
            public schedule(arg0: java.util.TimerTask | java.util.TimerTask$$Lambda, arg1: java.util.Date, arg2: long): void
            public scheduleAtFixedRate(arg0: java.util.TimerTask | java.util.TimerTask$$Lambda, arg1: long, arg2: long): void
            public scheduleAtFixedRate(arg0: java.util.TimerTask | java.util.TimerTask$$Lambda, arg1: java.util.Date, arg2: long): void
            public cancel(): void
            public purge(): int
            public static class: java.lang.Class<any>
        }
        abstract class TimerTask implements java.lang.Runnable {
            protected constructor()
            public run(): void
            public cancel(): boolean
            public scheduledExecutionTime(): long
            public static class: java.lang.Class<any>
        }
        abstract class TimerTask$$Lambda implements java.lang.Runnable {
            protected constructor()
        }
        class TooManyListenersException extends java.lang.Exception {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class TreeMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.NavigableMap<K, V> , java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: java.util.Comparator<K>)
            public constructor(arg0: java.util.Map<K, V>)
            public constructor(arg0: java.util.SortedMap<K, V>)
            public size(): int
            public containsKey(arg0: java.lang.Object): boolean
            public containsValue(arg0: java.lang.Object): boolean
            public get(arg0: java.lang.Object): V
            public comparator(): java.util.Comparator<K>
            public firstKey(): K
            public lastKey(): K
            public putAll(arg0: java.util.Map<K, V>): void
            public put(arg0: K, arg1: V): V
            public remove(arg0: java.lang.Object): V
            public clear(): void
            public clone(): java.lang.Object
            public firstEntry(): java.util.Map$Entry<K, V>
            public lastEntry(): java.util.Map$Entry<K, V>
            public pollFirstEntry(): java.util.Map$Entry<K, V>
            public pollLastEntry(): java.util.Map$Entry<K, V>
            public lowerEntry(arg0: K): java.util.Map$Entry<K, V>
            public lowerKey(arg0: K): K
            public floorEntry(arg0: K): java.util.Map$Entry<K, V>
            public floorKey(arg0: K): K
            public ceilingEntry(arg0: K): java.util.Map$Entry<K, V>
            public ceilingKey(arg0: K): K
            public higherEntry(arg0: K): java.util.Map$Entry<K, V>
            public higherKey(arg0: K): K
            public keySet(): java.util.Set<K>
            public navigableKeySet(): java.util.NavigableSet<K>
            public descendingKeySet(): java.util.NavigableSet<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public descendingMap(): java.util.NavigableMap<K, V>
            public subMap(arg0: K, arg1: boolean, arg2: K, arg3: boolean): java.util.NavigableMap<K, V>
            public headMap(arg0: K, arg1: boolean): java.util.NavigableMap<K, V>
            public tailMap(arg0: K, arg1: boolean): java.util.NavigableMap<K, V>
            public subMap(arg0: K, arg1: K): java.util.SortedMap<K, V>
            public headMap(arg0: K): java.util.SortedMap<K, V>
            public tailMap(arg0: K): java.util.SortedMap<K, V>
            public replace(arg0: K, arg1: V, arg2: V): boolean
            public replace(arg0: K, arg1: V): V
            public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            public static class: java.lang.Class<any>
        }
        class TreeSet<E> extends java.util.AbstractSet<E> implements java.util.NavigableSet<E> , java.lang.Cloneable , java.io.Serializable {
            public constructor()
            public constructor(arg0: java.util.Comparator<E>)
            public constructor(arg0: java.util.Collection<E>)
            public constructor(arg0: java.util.SortedSet<E>)
            public iterator(): java.util.Iterator<E>
            public descendingIterator(): java.util.Iterator<E>
            public descendingSet(): java.util.NavigableSet<E>
            public size(): int
            public isEmpty(): boolean
            public contains(arg0: java.lang.Object): boolean
            public add(arg0: E): boolean
            public remove(arg0: java.lang.Object): boolean
            public clear(): void
            public addAll(arg0: java.util.Collection<E>): boolean
            public subSet(arg0: E, arg1: boolean, arg2: E, arg3: boolean): java.util.NavigableSet<E>
            public headSet(arg0: E, arg1: boolean): java.util.NavigableSet<E>
            public tailSet(arg0: E, arg1: boolean): java.util.NavigableSet<E>
            public subSet(arg0: E, arg1: E): java.util.SortedSet<E>
            public headSet(arg0: E): java.util.SortedSet<E>
            public tailSet(arg0: E): java.util.SortedSet<E>
            public comparator(): java.util.Comparator<E>
            public first(): E
            public last(): E
            public lower(arg0: E): E
            public floor(arg0: E): E
            public ceiling(arg0: E): E
            public higher(arg0: E): E
            public pollFirst(): E
            public pollLast(): E
            public clone(): java.lang.Object
            public spliterator(): java.util.Spliterator<E>
            public static class: java.lang.Class<any>
        }
        class Tripwire {
            public static class: java.lang.Class<any>
        }
        class UUID implements java.io.Serializable , java.lang.Comparable<java.util.UUID> {
            public constructor(arg0: long, arg1: long)
            public static randomUUID(): java.util.UUID
            public static nameUUIDFromBytes(arg0: byte[]): java.util.UUID
            public static fromString(arg0: java.lang.String | string): java.util.UUID
            public getLeastSignificantBits(): long
            public getMostSignificantBits(): long
            public version(): int
            public variant(): int
            public timestamp(): long
            public clockSequence(): int
            public node(): long
            public toString(): string
            public hashCode(): int
            public equals(arg0: java.lang.Object): boolean
            public compareTo(arg0: java.util.UUID): int
            public compareTo(arg0: java.lang.Object): int
            public static class: java.lang.Class<any>
        }
        class UnknownFormatConversionException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string)
            public getConversion(): string
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class UnknownFormatFlagsException extends java.util.IllegalFormatException {
            public constructor(arg0: java.lang.String | string)
            public getFlags(): string
            public getMessage(): string
            public static class: java.lang.Class<any>
        }
        class Vector<E> extends java.util.AbstractList<E> implements java.util.List<E> , java.util.RandomAccess , java.lang.Cloneable , java.io.Serializable {
            protected elementData: java.lang.Object[]
            protected elementCount: int
            protected capacityIncrement: int
            public constructor(arg0: int, arg1: int)
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Collection<E>)
            public copyInto(arg0: java.lang.Object[]): void
            public trimToSize(): void
            public ensureCapacity(arg0: int): void
            public setSize(arg0: int): void
            public capacity(): int
            public size(): int
            public isEmpty(): boolean
            public elements(): java.util.Enumeration<E>
            public contains(arg0: java.lang.Object): boolean
            public indexOf(arg0: java.lang.Object): int
            public indexOf(arg0: java.lang.Object, arg1: int): int
            public lastIndexOf(arg0: java.lang.Object): int
            public lastIndexOf(arg0: java.lang.Object, arg1: int): int
            public elementAt(arg0: int): E
            public firstElement(): E
            public lastElement(): E
            public setElementAt(arg0: E, arg1: int): void
            public removeElementAt(arg0: int): void
            public insertElementAt(arg0: E, arg1: int): void
            public addElement(arg0: E): void
            public removeElement(arg0: java.lang.Object): boolean
            public removeAllElements(): void
            public clone(): java.lang.Object
            public toArray(): java.lang.Object[]
            public toArray<T>(arg0: T[]): T[]
            public get(arg0: int): E
            public set(arg0: int, arg1: E): E
            public add(arg0: E): boolean
            public remove(arg0: java.lang.Object): boolean
            public add(arg0: int, arg1: E): void
            public remove(arg0: int): E
            public clear(): void
            public containsAll(arg0: java.util.Collection<any>): boolean
            public addAll(arg0: java.util.Collection<E>): boolean
            public removeAll(arg0: java.util.Collection<any>): boolean
            public retainAll(arg0: java.util.Collection<any>): boolean
            public addAll(arg0: int, arg1: java.util.Collection<E>): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public toString(): string
            public subList(arg0: int, arg1: int): java.util.List<E>
            protected removeRange(arg0: int, arg1: int): void
            public listIterator(arg0: int): java.util.ListIterator<E>
            public listIterator(): java.util.ListIterator<E>
            public iterator(): java.util.Iterator<E>
            public forEach(arg0: java.util.function$.Consumer$$TypeScript<E>): void
            public removeIf(arg0: java.util.function$.Predicate<E>): boolean
            public replaceAll(arg0: java.util.function$.UnaryOperator<E>): void
            public sort(arg0: java.util.Comparator<E>): void
            public spliterator(): java.util.Spliterator<E>
            public static class: java.lang.Class<any>
        }
        class WeakHashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.Map<K, V> {
            public constructor(arg0: int, arg1: float)
            public constructor(arg0: int)
            public constructor()
            public constructor(arg0: java.util.Map<K, V>)
            public size(): int
            public isEmpty(): boolean
            public get(arg0: java.lang.Object): V
            public containsKey(arg0: java.lang.Object): boolean
            public put(arg0: K, arg1: V): V
            public putAll(arg0: java.util.Map<K, V>): void
            public remove(arg0: java.lang.Object): V
            public clear(): void
            public containsValue(arg0: java.lang.Object): boolean
            public keySet(): java.util.Set<K>
            public values(): java.util.Collection<V>
            public entrySet(): java.util.Set<java.util.Map$Entry<K, V>>
            public forEach(arg0: java.util.function$.BiConsumer<K, V>): void
            public replaceAll(arg0: java.util.function$.BiFunction<K, V, V>): void
            public static class: java.lang.Class<any>
        }
    }
}
declare namespace javax {
    namespace crypto {
        namespace interfaces {
            interface DHKey {
                getParams(): javax.crypto.spec.DHParameterSpec
            }
            interface DHKey$$Lambda {
                (): javax.crypto.spec.DHParameterSpec
            }
            interface DHPrivateKey extends javax.crypto.interfaces.DHKey , java.security.PrivateKey {
                serialVersionUID: long
                getX(): java.math.BigInteger
            }
            interface DHPublicKey extends javax.crypto.interfaces.DHKey , java.security.PublicKey {
                serialVersionUID: long
                getY(): java.math.BigInteger
            }
            interface PBEKey extends javax.crypto.SecretKey {
                serialVersionUID: long
                getPassword(): char[]
                getSalt(): byte[]
                getIterationCount(): int
            }
        }
        namespace spec {
            class DESKeySpec implements java.security.spec.KeySpec {
                public static DES_KEY_LEN: int
                public constructor(arg0: byte[])
                public constructor(arg0: byte[], arg1: int)
                public getKey(): byte[]
                public static isParityAdjusted(arg0: byte[], arg1: int): boolean
                public static isWeak(arg0: byte[], arg1: int): boolean
                public static class: java.lang.Class<any>
            }
            class DESedeKeySpec implements java.security.spec.KeySpec {
                public static DES_EDE_KEY_LEN: int
                public constructor(arg0: byte[])
                public constructor(arg0: byte[], arg1: int)
                public getKey(): byte[]
                public static isParityAdjusted(arg0: byte[], arg1: int): boolean
                public static class: java.lang.Class<any>
            }
            class DHGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: int, arg1: int)
                public getPrimeSize(): int
                public getExponentSize(): int
                public static class: java.lang.Class<any>
            }
            class DHParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger)
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: int)
                public getP(): java.math.BigInteger
                public getG(): java.math.BigInteger
                public getL(): int
                public static class: java.lang.Class<any>
            }
            class DHPrivateKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger)
                public getX(): java.math.BigInteger
                public getP(): java.math.BigInteger
                public getG(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class DHPublicKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger)
                public getY(): java.math.BigInteger
                public getP(): java.math.BigInteger
                public getG(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class GCMParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: int, arg1: byte[])
                public constructor(arg0: int, arg1: byte[], arg2: int, arg3: int)
                public getTLen(): int
                public getIV(): byte[]
                public static class: java.lang.Class<any>
            }
            class IvParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: byte[])
                public constructor(arg0: byte[], arg1: int, arg2: int)
                public getIV(): byte[]
                public static class: java.lang.Class<any>
            }
            class OAEPParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public static DEFAULT: javax.crypto.spec.OAEPParameterSpec
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.security.spec.AlgorithmParameterSpec, arg3: javax.crypto.spec.PSource)
                public getDigestAlgorithm(): string
                public getMGFAlgorithm(): string
                public getMGFParameters(): java.security.spec.AlgorithmParameterSpec
                public getPSource(): javax.crypto.spec.PSource
                public static class: java.lang.Class<any>
            }
            class PBEKeySpec implements java.security.spec.KeySpec {
                public constructor(arg0: char[])
                public constructor(arg0: char[], arg1: byte[], arg2: int, arg3: int)
                public constructor(arg0: char[], arg1: byte[], arg2: int)
                public clearPassword(): void
                public getPassword(): char[]
                public getSalt(): byte[]
                public getIterationCount(): int
                public getKeyLength(): int
                public static class: java.lang.Class<any>
            }
            class PBEParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: byte[], arg1: int)
                public constructor(arg0: byte[], arg1: int, arg2: java.security.spec.AlgorithmParameterSpec)
                public getSalt(): byte[]
                public getIterationCount(): int
                public getParameterSpec(): java.security.spec.AlgorithmParameterSpec
                public static class: java.lang.Class<any>
            }
            class PSource {
                protected constructor(arg0: java.lang.String | string)
                public getAlgorithm(): string
                public static class: java.lang.Class<any>
            }
            class RC2ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: byte[])
                public constructor(arg0: int, arg1: byte[], arg2: int)
                public getEffectiveKeyBits(): int
                public getIV(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class RC5ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: int, arg1: int, arg2: int)
                public constructor(arg0: int, arg1: int, arg2: int, arg3: byte[])
                public constructor(arg0: int, arg1: int, arg2: int, arg3: byte[], arg4: int)
                public getVersion(): int
                public getRounds(): int
                public getWordSize(): int
                public getIV(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class SecretKeySpec implements java.security.spec.KeySpec , javax.crypto.SecretKey {
                public constructor(arg0: byte[], arg1: java.lang.String | string)
                public constructor(arg0: byte[], arg1: int, arg2: int, arg3: java.lang.String | string)
                public getAlgorithm(): string
                public getFormat(): string
                public getEncoded(): byte[]
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public static class: java.lang.Class<any>
            }
        }
        class AEADBadTagException extends javax.crypto.BadPaddingException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class BadPaddingException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class Cipher {
            public static ENCRYPT_MODE: int
            public static DECRYPT_MODE: int
            public static WRAP_MODE: int
            public static UNWRAP_MODE: int
            public static PUBLIC_KEY: int
            public static PRIVATE_KEY: int
            public static SECRET_KEY: int
            protected constructor(arg0: javax.crypto.CipherSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public static getInstance(arg0: java.lang.String | string): javax.crypto.Cipher
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.crypto.Cipher
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.crypto.Cipher
            public getProvider(): java.security.Provider
            public getAlgorithm(): string
            public getBlockSize(): int
            public getOutputSize(arg0: int): int
            public getIV(): byte[]
            public getParameters(): java.security.AlgorithmParameters
            public getExemptionMechanism(): javax.crypto.ExemptionMechanism
            public init(arg0: int, arg1: java.security.Key): void
            public init(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
            public init(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec): void
            public init(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
            public init(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters): void
            public init(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
            public init(arg0: int, arg1: java.security.cert.Certificate): void
            public init(arg0: int, arg1: java.security.cert.Certificate, arg2: java.security.SecureRandom): void
            public update(arg0: byte[]): byte[]
            public update(arg0: byte[], arg1: int, arg2: int): byte[]
            public update(arg0: byte[], arg1: int, arg2: int, arg3: byte[]): int
            public update(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
            public update(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer): int
            public doFinal(): byte[]
            public doFinal(arg0: byte[], arg1: int): int
            public doFinal(arg0: byte[]): byte[]
            public doFinal(arg0: byte[], arg1: int, arg2: int): byte[]
            public doFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[]): int
            public doFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
            public doFinal(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer): int
            public wrap(arg0: java.security.Key): byte[]
            public unwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
            public static getMaxAllowedKeyLength(arg0: java.lang.String | string): int
            public static getMaxAllowedParameterSpec(arg0: java.lang.String | string): java.security.spec.AlgorithmParameterSpec
            public updateAAD(arg0: byte[]): void
            public updateAAD(arg0: byte[], arg1: int, arg2: int): void
            public updateAAD(arg0: java.nio.ByteBuffer): void
            public static class: java.lang.Class<any>
        }
        class CipherInputStream extends java.io.FilterInputStream {
            public constructor(arg0: java.io.InputStream, arg1: javax.crypto.Cipher)
            protected constructor(arg0: java.io.InputStream)
            public read(): int
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public skip(arg0: long): long
            public available(): int
            public close(): void
            public markSupported(): boolean
            public static class: java.lang.Class<any>
        }
        class CipherOutputStream extends java.io.FilterOutputStream {
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: javax.crypto.Cipher)
            protected constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
            public write(arg0: int): void
            public write(arg0: byte[]): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public flush(): void
            public close(): void
            public static class: java.lang.Class<any>
        }
        abstract class CipherSpi {
            public constructor()
            protected engineSetMode(arg0: java.lang.String | string): void
            protected engineSetPadding(arg0: java.lang.String | string): void
            protected engineGetBlockSize(): int
            protected engineGetOutputSize(arg0: int): int
            protected engineGetIV(): byte[]
            protected engineGetParameters(): java.security.AlgorithmParameters
            protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
            protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
            protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
            protected engineUpdate(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer): int
            protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
            protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
            protected engineDoFinal(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer): int
            protected engineWrap(arg0: java.security.Key): byte[]
            protected engineUnwrap(arg0: byte[], arg1: java.lang.String | string, arg2: int): java.security.Key
            protected engineGetKeySize(arg0: java.security.Key): int
            protected engineUpdateAAD(arg0: byte[], arg1: int, arg2: int): void
            protected engineUpdateAAD(arg0: java.nio.ByteBuffer): void
            public static class: java.lang.Class<any>
        }
        class CryptoAllPermission extends javax.crypto.CryptoPermission {
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public newPermissionCollection(): java.security.PermissionCollection
            public static class: java.lang.Class<any>
        }
        class CryptoPermission extends java.security.Permission {
            public implies(arg0: java.security.Permission): boolean
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public getActions(): string
            public newPermissionCollection(): java.security.PermissionCollection
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class CryptoPermissions extends java.security.PermissionCollection implements java.io.Serializable {
            public add(arg0: java.security.Permission): void
            public implies(arg0: java.security.Permission): boolean
            public elements(): java.util.Enumeration<java.security.Permission>
            public static class: java.lang.Class<any>
        }
        class CryptoPolicyParser {
            public static class: java.lang.Class<any>
        }
        class EncryptedPrivateKeyInfo {
            public constructor(arg0: byte[])
            public constructor(arg0: java.lang.String | string, arg1: byte[])
            public constructor(arg0: java.security.AlgorithmParameters, arg1: byte[])
            public getAlgName(): string
            public getAlgParameters(): java.security.AlgorithmParameters
            public getEncryptedData(): byte[]
            public getKeySpec(arg0: javax.crypto.Cipher): java.security.spec.PKCS8EncodedKeySpec
            public getKeySpec(arg0: java.security.Key): java.security.spec.PKCS8EncodedKeySpec
            public getKeySpec(arg0: java.security.Key, arg1: java.lang.String | string): java.security.spec.PKCS8EncodedKeySpec
            public getKeySpec(arg0: java.security.Key, arg1: java.security.Provider): java.security.spec.PKCS8EncodedKeySpec
            public getEncoded(): byte[]
            public static class: java.lang.Class<any>
        }
        class ExemptionMechanism {
            protected constructor(arg0: javax.crypto.ExemptionMechanismSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public getName(): string
            public static getInstance(arg0: java.lang.String | string): javax.crypto.ExemptionMechanism
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.crypto.ExemptionMechanism
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.crypto.ExemptionMechanism
            public getProvider(): java.security.Provider
            public isCryptoAllowed(arg0: java.security.Key): boolean
            public getOutputSize(arg0: int): int
            public init(arg0: java.security.Key): void
            public init(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
            public init(arg0: java.security.Key, arg1: java.security.AlgorithmParameters): void
            public genExemptionBlob(): byte[]
            public genExemptionBlob(arg0: byte[]): int
            public genExemptionBlob(arg0: byte[], arg1: int): int
            protected finalize(): void
            public static class: java.lang.Class<any>
        }
        class ExemptionMechanismException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        abstract class ExemptionMechanismSpi {
            public constructor()
            protected engineGetOutputSize(arg0: int): int
            protected engineInit(arg0: java.security.Key): void
            protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
            protected engineInit(arg0: java.security.Key, arg1: java.security.AlgorithmParameters): void
            protected engineGenExemptionBlob(): byte[]
            protected engineGenExemptionBlob(arg0: byte[], arg1: int): int
            public static class: java.lang.Class<any>
        }
        class IllegalBlockSizeException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class JceSecurityManager extends java.lang.SecurityManager {
            public static class: java.lang.Class<any>
        }
        class KeyAgreement {
            protected constructor(arg0: javax.crypto.KeyAgreementSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public getAlgorithm(): string
            public static getInstance(arg0: java.lang.String | string): javax.crypto.KeyAgreement
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.crypto.KeyAgreement
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.crypto.KeyAgreement
            public getProvider(): java.security.Provider
            public init(arg0: java.security.Key): void
            public init(arg0: java.security.Key, arg1: java.security.SecureRandom): void
            public init(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
            public init(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec, arg2: java.security.SecureRandom): void
            public doPhase(arg0: java.security.Key, arg1: boolean): java.security.Key
            public generateSecret(): byte[]
            public generateSecret(arg0: byte[], arg1: int): int
            public generateSecret(arg0: java.lang.String | string): javax.crypto.SecretKey
            public static class: java.lang.Class<any>
        }
        abstract class KeyAgreementSpi {
            public constructor()
            protected engineInit(arg0: java.security.Key, arg1: java.security.SecureRandom): void
            protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec, arg2: java.security.SecureRandom): void
            protected engineDoPhase(arg0: java.security.Key, arg1: boolean): java.security.Key
            protected engineGenerateSecret(): byte[]
            protected engineGenerateSecret(arg0: byte[], arg1: int): int
            protected engineGenerateSecret(arg0: java.lang.String | string): javax.crypto.SecretKey
            public static class: java.lang.Class<any>
        }
        class KeyGenerator {
            protected constructor(arg0: javax.crypto.KeyGeneratorSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public getAlgorithm(): string
            public static getInstance(arg0: java.lang.String | string): javax.crypto.KeyGenerator
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.crypto.KeyGenerator
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.crypto.KeyGenerator
            public getProvider(): java.security.Provider
            public init(arg0: java.security.SecureRandom): void
            public init(arg0: java.security.spec.AlgorithmParameterSpec): void
            public init(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
            public init(arg0: int): void
            public init(arg0: int, arg1: java.security.SecureRandom): void
            public generateKey(): javax.crypto.SecretKey
            public static class: java.lang.Class<any>
        }
        abstract class KeyGeneratorSpi {
            public constructor()
            protected engineInit(arg0: java.security.SecureRandom): void
            protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
            protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
            protected engineGenerateKey(): javax.crypto.SecretKey
            public static class: java.lang.Class<any>
        }
        class Mac implements java.lang.Cloneable {
            protected constructor(arg0: javax.crypto.MacSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public getAlgorithm(): string
            public static getInstance(arg0: java.lang.String | string): javax.crypto.Mac
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.crypto.Mac
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.crypto.Mac
            public getProvider(): java.security.Provider
            public getMacLength(): int
            public init(arg0: java.security.Key): void
            public init(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
            public update(arg0: byte): void
            public update(arg0: byte[]): void
            public update(arg0: byte[], arg1: int, arg2: int): void
            public update(arg0: java.nio.ByteBuffer): void
            public doFinal(): byte[]
            public doFinal(arg0: byte[], arg1: int): void
            public doFinal(arg0: byte[]): byte[]
            public reset(): void
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        abstract class MacSpi {
            public constructor()
            protected engineGetMacLength(): int
            protected engineInit(arg0: java.security.Key, arg1: java.security.spec.AlgorithmParameterSpec): void
            protected engineUpdate(arg0: byte): void
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
            protected engineUpdate(arg0: java.nio.ByteBuffer): void
            protected engineDoFinal(): byte[]
            protected engineReset(): void
            public clone(): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class NoSuchPaddingException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class NullCipher extends javax.crypto.Cipher {
            public constructor()
            public static class: java.lang.Class<any>
        }
        class NullCipherSpi extends javax.crypto.CipherSpi {
            protected constructor()
            public engineSetMode(arg0: java.lang.String | string): void
            public engineSetPadding(arg0: java.lang.String | string): void
            protected engineGetBlockSize(): int
            protected engineGetOutputSize(arg0: int): int
            protected engineGetIV(): byte[]
            protected engineGetParameters(): java.security.AlgorithmParameters
            protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.SecureRandom): void
            protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom): void
            protected engineInit(arg0: int, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.security.SecureRandom): void
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int): byte[]
            protected engineUpdate(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
            protected engineDoFinal(arg0: byte[], arg1: int, arg2: int): byte[]
            protected engineDoFinal(arg0: byte[], arg1: int, arg2: int, arg3: byte[], arg4: int): int
            protected engineGetKeySize(arg0: java.security.Key): int
            public static class: java.lang.Class<any>
        }
        class SealedObject implements java.io.Serializable {
            protected encodedParams: byte[]
            public constructor(arg0: java.io.Serializable, arg1: javax.crypto.Cipher)
            protected constructor(arg0: javax.crypto.SealedObject)
            public getAlgorithm(): string
            public getObject(arg0: java.security.Key): java.lang.Object
            public getObject(arg0: javax.crypto.Cipher): java.lang.Object
            public getObject(arg0: java.security.Key, arg1: java.lang.String | string): java.lang.Object
            public static class: java.lang.Class<any>
        }
        interface SecretKey extends java.security.Key , javax.security.auth.Destroyable {
            serialVersionUID: long
        }
        class SecretKeyFactory {
            protected constructor(arg0: javax.crypto.SecretKeyFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
            public static getInstance(arg0: java.lang.String | string): javax.crypto.SecretKeyFactory
            public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.crypto.SecretKeyFactory
            public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.crypto.SecretKeyFactory
            public getProvider(): java.security.Provider
            public getAlgorithm(): string
            public generateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
            public getKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
            public translateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
            public static class: java.lang.Class<any>
        }
        abstract class SecretKeyFactorySpi {
            public constructor()
            protected engineGenerateSecret(arg0: java.security.spec.KeySpec): javax.crypto.SecretKey
            protected engineGetKeySpec(arg0: javax.crypto.SecretKey, arg1: java.lang.Class<any>): java.security.spec.KeySpec
            protected engineTranslateKey(arg0: javax.crypto.SecretKey): javax.crypto.SecretKey
            public static class: java.lang.Class<any>
        }
        class ShortBufferException extends java.security.GeneralSecurityException {
            public constructor()
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
    }
    namespace net {
        namespace ssl {
            class CertPathTrustManagerParameters implements javax.net.ssl.ManagerFactoryParameters {
                public constructor(arg0: java.security.cert.CertPathParameters)
                public getParameters(): java.security.cert.CertPathParameters
                public static class: java.lang.Class<any>
            }
            abstract class ExtendedSSLSession implements javax.net.ssl.SSLSession {
                public constructor()
                public getLocalSupportedSignatureAlgorithms(): java.lang.String[]
                public getPeerSupportedSignatureAlgorithms(): java.lang.String[]
                public getRequestedServerNames(): java.util.List<javax.net.ssl.SNIServerName>
                public static class: java.lang.Class<any>
            }
            class HandshakeCompletedEvent extends java.util.EventObject {
                public constructor(arg0: javax.net.ssl.SSLSocket, arg1: javax.net.ssl.SSLSession)
                public getSession(): javax.net.ssl.SSLSession
                public getCipherSuite(): string
                public getLocalCertificates(): java.security.cert.Certificate[]
                public getPeerCertificates(): java.security.cert.Certificate[]
                public getPeerCertificateChain(): javax.security.cert.X509Certificate[]
                public getPeerPrincipal(): java.security.Principal
                public getLocalPrincipal(): java.security.Principal
                public getSocket(): javax.net.ssl.SSLSocket
                public static class: java.lang.Class<any>
            }
            interface HandshakeCompletedListener extends java.util.EventListener {
                handshakeCompleted(arg0: javax.net.ssl.HandshakeCompletedEvent): void
            }
            interface HostnameVerifier {
                verify(arg0: java.lang.String | string, arg1: javax.net.ssl.SSLSession): boolean
            }
            interface HostnameVerifier$$Lambda {
                (arg0: java.lang.String | string, arg1: javax.net.ssl.SSLSession): boolean
            }
            abstract class HttpsURLConnection extends java.net.HttpURLConnection {
                protected hostnameVerifier: javax.net.ssl.HostnameVerifier
                protected constructor(arg0: java.net.URL)
                public getCipherSuite(): string
                public getLocalCertificates(): java.security.cert.Certificate[]
                public getServerCertificates(): java.security.cert.Certificate[]
                public getPeerPrincipal(): java.security.Principal
                public getLocalPrincipal(): java.security.Principal
                public static setDefaultHostnameVerifier(arg0: javax.net.ssl.HostnameVerifier | javax.net.ssl.HostnameVerifier$$Lambda): void
                public static getDefaultHostnameVerifier(): javax.net.ssl.HostnameVerifier
                public setHostnameVerifier(arg0: javax.net.ssl.HostnameVerifier | javax.net.ssl.HostnameVerifier$$Lambda): void
                public getHostnameVerifier(): javax.net.ssl.HostnameVerifier
                public static setDefaultSSLSocketFactory(arg0: javax.net.ssl.SSLSocketFactory): void
                public static getDefaultSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                public setSSLSocketFactory(arg0: javax.net.ssl.SSLSocketFactory): void
                public getSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                public static class: java.lang.Class<any>
            }
            interface KeyManager {
            }
            class KeyManagerFactory {
                public static getDefaultAlgorithm(): string
                protected constructor(arg0: javax.net.ssl.KeyManagerFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                public getAlgorithm(): string
                public static getInstance(arg0: java.lang.String | string): javax.net.ssl.KeyManagerFactory
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.net.ssl.KeyManagerFactory
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.net.ssl.KeyManagerFactory
                public getProvider(): java.security.Provider
                public init(arg0: java.security.KeyStore, arg1: char[]): void
                public init(arg0: javax.net.ssl.ManagerFactoryParameters): void
                public getKeyManagers(): javax.net.ssl.KeyManager[]
                public static class: java.lang.Class<any>
            }
            abstract class KeyManagerFactorySpi {
                public constructor()
                protected engineInit(arg0: java.security.KeyStore, arg1: char[]): void
                protected engineInit(arg0: javax.net.ssl.ManagerFactoryParameters): void
                protected engineGetKeyManagers(): javax.net.ssl.KeyManager[]
                public static class: java.lang.Class<any>
            }
            class KeyStoreBuilderParameters implements javax.net.ssl.ManagerFactoryParameters {
                public constructor(arg0: java.security.KeyStore$Builder)
                public constructor(arg0: java.util.List<java.security.KeyStore$Builder>)
                public getParameters(): java.util.List<java.security.KeyStore$Builder>
                public static class: java.lang.Class<any>
            }
            interface ManagerFactoryParameters {
            }
            class SNIHostName extends javax.net.ssl.SNIServerName {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: byte[])
                public getAsciiName(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static createSNIMatcher(arg0: java.lang.String | string): javax.net.ssl.SNIMatcher
                public static class: java.lang.Class<any>
            }
            abstract class SNIMatcher {
                protected constructor(arg0: int)
                public getType(): int
                public matches(arg0: javax.net.ssl.SNIServerName): boolean
                public static class: java.lang.Class<any>
            }
            abstract class SNIServerName {
                protected constructor(arg0: int, arg1: byte[])
                public getType(): int
                public getEncoded(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SSLContext {
                protected constructor(arg0: javax.net.ssl.SSLContextSpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                public static getDefault(): javax.net.ssl.SSLContext
                public static setDefault(arg0: javax.net.ssl.SSLContext): void
                public static getInstance(arg0: java.lang.String | string): javax.net.ssl.SSLContext
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.net.ssl.SSLContext
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.net.ssl.SSLContext
                public getProtocol(): string
                public getProvider(): java.security.Provider
                public init(arg0: javax.net.ssl.KeyManager[], arg1: javax.net.ssl.TrustManager[], arg2: java.security.SecureRandom): void
                public getSocketFactory(): javax.net.ssl.SSLSocketFactory
                public getServerSocketFactory(): javax.net.ssl.SSLServerSocketFactory
                public createSSLEngine(): javax.net.ssl.SSLEngine
                public createSSLEngine(arg0: java.lang.String | string, arg1: int): javax.net.ssl.SSLEngine
                public getServerSessionContext(): javax.net.ssl.SSLSessionContext
                public getClientSessionContext(): javax.net.ssl.SSLSessionContext
                public getDefaultSSLParameters(): javax.net.ssl.SSLParameters
                public getSupportedSSLParameters(): javax.net.ssl.SSLParameters
                public static class: java.lang.Class<any>
            }
            abstract class SSLContextSpi {
                public constructor()
                protected engineInit(arg0: javax.net.ssl.KeyManager[], arg1: javax.net.ssl.TrustManager[], arg2: java.security.SecureRandom): void
                protected engineGetSocketFactory(): javax.net.ssl.SSLSocketFactory
                protected engineGetServerSocketFactory(): javax.net.ssl.SSLServerSocketFactory
                protected engineCreateSSLEngine(): javax.net.ssl.SSLEngine
                protected engineCreateSSLEngine(arg0: java.lang.String | string, arg1: int): javax.net.ssl.SSLEngine
                protected engineGetServerSessionContext(): javax.net.ssl.SSLSessionContext
                protected engineGetClientSessionContext(): javax.net.ssl.SSLSessionContext
                protected engineGetDefaultSSLParameters(): javax.net.ssl.SSLParameters
                protected engineGetSupportedSSLParameters(): javax.net.ssl.SSLParameters
                public static class: java.lang.Class<any>
            }
            abstract class SSLEngine {
                protected constructor()
                protected constructor(arg0: java.lang.String | string, arg1: int)
                public getPeerHost(): string
                public getPeerPort(): int
                public wrap(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer): javax.net.ssl.SSLEngineResult
                public wrap(arg0: java.nio.ByteBuffer[], arg1: java.nio.ByteBuffer): javax.net.ssl.SSLEngineResult
                public wrap(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int, arg3: java.nio.ByteBuffer): javax.net.ssl.SSLEngineResult
                public unwrap(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer): javax.net.ssl.SSLEngineResult
                public unwrap(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer[]): javax.net.ssl.SSLEngineResult
                public unwrap(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer[], arg2: int, arg3: int): javax.net.ssl.SSLEngineResult
                public getDelegatedTask(): java.lang.Runnable
                public closeInbound(): void
                public isInboundDone(): boolean
                public closeOutbound(): void
                public isOutboundDone(): boolean
                public getSupportedCipherSuites(): java.lang.String[]
                public getEnabledCipherSuites(): java.lang.String[]
                public setEnabledCipherSuites(arg0: java.lang.String[]): void
                public getSupportedProtocols(): java.lang.String[]
                public getEnabledProtocols(): java.lang.String[]
                public setEnabledProtocols(arg0: java.lang.String[]): void
                public getSession(): javax.net.ssl.SSLSession
                public getHandshakeSession(): javax.net.ssl.SSLSession
                public beginHandshake(): void
                public getHandshakeStatus(): javax.net.ssl.SSLEngineResult$HandshakeStatus
                public setUseClientMode(arg0: boolean): void
                public getUseClientMode(): boolean
                public setNeedClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getWantClientAuth(): boolean
                public setEnableSessionCreation(arg0: boolean): void
                public getEnableSessionCreation(): boolean
                public getSSLParameters(): javax.net.ssl.SSLParameters
                public setSSLParameters(arg0: javax.net.ssl.SSLParameters): void
                public static class: java.lang.Class<any>
            }
            class SSLEngineResult {
                public constructor(arg0: javax.net.ssl.SSLEngineResult$Status, arg1: javax.net.ssl.SSLEngineResult$HandshakeStatus, arg2: int, arg3: int)
                public getStatus(): javax.net.ssl.SSLEngineResult$Status
                public getHandshakeStatus(): javax.net.ssl.SSLEngineResult$HandshakeStatus
                public bytesConsumed(): int
                public bytesProduced(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SSLException extends java.io.IOException {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Throwable)
                public static class: java.lang.Class<any>
            }
            class SSLHandshakeException extends javax.net.ssl.SSLException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class SSLKeyException extends javax.net.ssl.SSLException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class SSLParameters {
                public constructor()
                public constructor(arg0: java.lang.String[])
                public constructor(arg0: java.lang.String[], arg1: java.lang.String[])
                public getCipherSuites(): java.lang.String[]
                public setCipherSuites(arg0: java.lang.String[]): void
                public getProtocols(): java.lang.String[]
                public setProtocols(arg0: java.lang.String[]): void
                public getWantClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setNeedClientAuth(arg0: boolean): void
                public getAlgorithmConstraints(): java.security.AlgorithmConstraints
                public setAlgorithmConstraints(arg0: java.security.AlgorithmConstraints): void
                public getEndpointIdentificationAlgorithm(): string
                public setEndpointIdentificationAlgorithm(arg0: java.lang.String | string): void
                public setServerNames(arg0: java.util.List<javax.net.ssl.SNIServerName>): void
                public getServerNames(): java.util.List<javax.net.ssl.SNIServerName>
                public setSNIMatchers(arg0: java.util.Collection<javax.net.ssl.SNIMatcher>): void
                public getSNIMatchers(): java.util.Collection<javax.net.ssl.SNIMatcher>
                public setUseCipherSuitesOrder(arg0: boolean): void
                public getUseCipherSuitesOrder(): boolean
                public static class: java.lang.Class<any>
            }
            class SSLPeerUnverifiedException extends javax.net.ssl.SSLException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class SSLPermission extends java.security.BasicPermission {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class SSLProtocolException extends javax.net.ssl.SSLException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            abstract class SSLServerSocket extends java.net.ServerSocket {
                protected constructor()
                protected constructor(arg0: int)
                protected constructor(arg0: int, arg1: int)
                protected constructor(arg0: int, arg1: int, arg2: java.net.InetAddress)
                public getEnabledCipherSuites(): java.lang.String[]
                public setEnabledCipherSuites(arg0: java.lang.String[]): void
                public getSupportedCipherSuites(): java.lang.String[]
                public getSupportedProtocols(): java.lang.String[]
                public getEnabledProtocols(): java.lang.String[]
                public setEnabledProtocols(arg0: java.lang.String[]): void
                public setNeedClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getWantClientAuth(): boolean
                public setUseClientMode(arg0: boolean): void
                public getUseClientMode(): boolean
                public setEnableSessionCreation(arg0: boolean): void
                public getEnableSessionCreation(): boolean
                public getSSLParameters(): javax.net.ssl.SSLParameters
                public setSSLParameters(arg0: javax.net.ssl.SSLParameters): void
                public static class: java.lang.Class<any>
            }
            abstract class SSLServerSocketFactory extends javax.net.ServerSocketFactory {
                protected constructor()
                public static getDefault(): javax.net.ServerSocketFactory
                public getDefaultCipherSuites(): java.lang.String[]
                public getSupportedCipherSuites(): java.lang.String[]
                public static class: java.lang.Class<any>
            }
            interface SSLSession {
                getId(): byte[]
                getSessionContext(): javax.net.ssl.SSLSessionContext
                getCreationTime(): long
                getLastAccessedTime(): long
                invalidate(): void
                isValid(): boolean
                putValue(arg0: java.lang.String | string, arg1: java.lang.Object): void
                getValue(arg0: java.lang.String | string): java.lang.Object
                removeValue(arg0: java.lang.String | string): void
                getValueNames(): java.lang.String[]
                getPeerCertificates(): java.security.cert.Certificate[]
                getLocalCertificates(): java.security.cert.Certificate[]
                getPeerCertificateChain(): javax.security.cert.X509Certificate[]
                getPeerPrincipal(): java.security.Principal
                getLocalPrincipal(): java.security.Principal
                getCipherSuite(): string
                getProtocol(): string
                getPeerHost(): string
                getPeerPort(): int
                getPacketBufferSize(): int
                getApplicationBufferSize(): int
            }
            class SSLSessionBindingEvent extends java.util.EventObject {
                public constructor(arg0: javax.net.ssl.SSLSession, arg1: java.lang.String | string)
                public getName(): string
                public getSession(): javax.net.ssl.SSLSession
                public static class: java.lang.Class<any>
            }
            interface SSLSessionBindingListener extends java.util.EventListener {
                valueBound(arg0: javax.net.ssl.SSLSessionBindingEvent): void
                valueUnbound(arg0: javax.net.ssl.SSLSessionBindingEvent): void
            }
            interface SSLSessionContext {
                getSession(arg0: byte[]): javax.net.ssl.SSLSession
                getIds(): java.util.Enumeration<byte[]>
                setSessionTimeout(arg0: int): void
                getSessionTimeout(): int
                setSessionCacheSize(arg0: int): void
                getSessionCacheSize(): int
            }
            abstract class SSLSocket extends java.net.Socket {
                protected constructor()
                protected constructor(arg0: java.lang.String | string, arg1: int)
                protected constructor(arg0: java.net.InetAddress, arg1: int)
                protected constructor(arg0: java.lang.String | string, arg1: int, arg2: java.net.InetAddress, arg3: int)
                protected constructor(arg0: java.net.InetAddress, arg1: int, arg2: java.net.InetAddress, arg3: int)
                public getSupportedCipherSuites(): java.lang.String[]
                public getEnabledCipherSuites(): java.lang.String[]
                public setEnabledCipherSuites(arg0: java.lang.String[]): void
                public getSupportedProtocols(): java.lang.String[]
                public getEnabledProtocols(): java.lang.String[]
                public setEnabledProtocols(arg0: java.lang.String[]): void
                public getSession(): javax.net.ssl.SSLSession
                public getHandshakeSession(): javax.net.ssl.SSLSession
                public addHandshakeCompletedListener(arg0: javax.net.ssl.HandshakeCompletedListener): void
                public removeHandshakeCompletedListener(arg0: javax.net.ssl.HandshakeCompletedListener): void
                public startHandshake(): void
                public setUseClientMode(arg0: boolean): void
                public getUseClientMode(): boolean
                public setNeedClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getWantClientAuth(): boolean
                public setEnableSessionCreation(arg0: boolean): void
                public getEnableSessionCreation(): boolean
                public getSSLParameters(): javax.net.ssl.SSLParameters
                public setSSLParameters(arg0: javax.net.ssl.SSLParameters): void
                public static class: java.lang.Class<any>
            }
            abstract class SSLSocketFactory extends javax.net.SocketFactory {
                public constructor()
                public static getDefault(): javax.net.SocketFactory
                public getDefaultCipherSuites(): java.lang.String[]
                public getSupportedCipherSuites(): java.lang.String[]
                public createSocket(arg0: java.net.Socket, arg1: java.lang.String | string, arg2: int, arg3: boolean): java.net.Socket
                public createSocket(arg0: java.net.Socket, arg1: java.io.InputStream, arg2: boolean): java.net.Socket
                public static class: java.lang.Class<any>
            }
            class StandardConstants {
                public static SNI_HOST_NAME: int
                public static class: java.lang.Class<any>
            }
            interface TrustManager {
            }
            class TrustManagerFactory {
                public static getDefaultAlgorithm(): string
                protected constructor(arg0: javax.net.ssl.TrustManagerFactorySpi, arg1: java.security.Provider, arg2: java.lang.String | string)
                public getAlgorithm(): string
                public static getInstance(arg0: java.lang.String | string): javax.net.ssl.TrustManagerFactory
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): javax.net.ssl.TrustManagerFactory
                public static getInstance(arg0: java.lang.String | string, arg1: java.security.Provider): javax.net.ssl.TrustManagerFactory
                public getProvider(): java.security.Provider
                public init(arg0: java.security.KeyStore): void
                public init(arg0: javax.net.ssl.ManagerFactoryParameters): void
                public getTrustManagers(): javax.net.ssl.TrustManager[]
                public static class: java.lang.Class<any>
            }
            abstract class TrustManagerFactorySpi {
                public constructor()
                protected engineInit(arg0: java.security.KeyStore): void
                protected engineInit(arg0: javax.net.ssl.ManagerFactoryParameters): void
                protected engineGetTrustManagers(): javax.net.ssl.TrustManager[]
                public static class: java.lang.Class<any>
            }
            abstract class X509ExtendedKeyManager implements javax.net.ssl.X509KeyManager {
                protected constructor()
                public chooseEngineClientAlias(arg0: java.lang.String[], arg1: java.security.Principal[], arg2: javax.net.ssl.SSLEngine): string
                public chooseEngineServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: javax.net.ssl.SSLEngine): string
                public static class: java.lang.Class<any>
            }
            abstract class X509ExtendedTrustManager implements javax.net.ssl.X509TrustManager {
                public constructor()
                public checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: java.net.Socket): void
                public checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: java.net.Socket): void
                public checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: javax.net.ssl.SSLEngine): void
                public checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: javax.net.ssl.SSLEngine): void
                public static class: java.lang.Class<any>
            }
            interface X509KeyManager extends javax.net.ssl.KeyManager {
                getClientAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                chooseClientAlias(arg0: java.lang.String[], arg1: java.security.Principal[], arg2: java.net.Socket): string
                getServerAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                chooseServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: java.net.Socket): string
                getCertificateChain(arg0: java.lang.String | string): java.security.cert.X509Certificate[]
                getPrivateKey(arg0: java.lang.String | string): java.security.PrivateKey
            }
            interface X509TrustManager extends javax.net.ssl.TrustManager {
                checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string): void
                checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string): void
                getAcceptedIssuers(): java.security.cert.X509Certificate[]
            }
        }
        abstract class ServerSocketFactory {
            protected constructor()
            public static getDefault(): javax.net.ServerSocketFactory
            public createServerSocket(): java.net.ServerSocket
            public createServerSocket(arg0: int): java.net.ServerSocket
            public createServerSocket(arg0: int, arg1: int): java.net.ServerSocket
            public createServerSocket(arg0: int, arg1: int, arg2: java.net.InetAddress): java.net.ServerSocket
            public static class: java.lang.Class<any>
        }
        abstract class SocketFactory {
            protected constructor()
            public static getDefault(): javax.net.SocketFactory
            public createSocket(): java.net.Socket
            public createSocket(arg0: java.lang.String | string, arg1: int): java.net.Socket
            public createSocket(arg0: java.lang.String | string, arg1: int, arg2: java.net.InetAddress, arg3: int): java.net.Socket
            public createSocket(arg0: java.net.InetAddress, arg1: int): java.net.Socket
            public createSocket(arg0: java.net.InetAddress, arg1: int, arg2: java.net.InetAddress, arg3: int): java.net.Socket
            public static class: java.lang.Class<any>
        }
    }
    namespace security {
        namespace auth {
            namespace callback {
                interface Callback {
                }
                interface CallbackHandler {
                    handle(arg0: javax.security.auth.callback.Callback[]): void
                }
                interface CallbackHandler$$Lambda {
                    (arg0: javax.security.auth.callback.Callback[]): void
                }
                class ChoiceCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String[], arg2: int, arg3: boolean)
                    public getPrompt(): string
                    public getChoices(): java.lang.String[]
                    public getDefaultChoice(): int
                    public allowMultipleSelections(): boolean
                    public setSelectedIndex(arg0: int): void
                    public setSelectedIndexes(arg0: int[]): void
                    public getSelectedIndexes(): int[]
                    public static class: java.lang.Class<any>
                }
                class ConfirmationCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public static UNSPECIFIED_OPTION: int
                    public static YES_NO_OPTION: int
                    public static YES_NO_CANCEL_OPTION: int
                    public static OK_CANCEL_OPTION: int
                    public static YES: int
                    public static NO: int
                    public static CANCEL: int
                    public static OK: int
                    public static INFORMATION: int
                    public static WARNING: int
                    public static ERROR: int
                    public constructor(arg0: int, arg1: int, arg2: int)
                    public constructor(arg0: int, arg1: java.lang.String[], arg2: int)
                    public constructor(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int)
                    public constructor(arg0: java.lang.String | string, arg1: int, arg2: java.lang.String[], arg3: int)
                    public getPrompt(): string
                    public getMessageType(): int
                    public getOptionType(): int
                    public getOptions(): java.lang.String[]
                    public getDefaultOption(): int
                    public setSelectedIndex(arg0: int): void
                    public getSelectedIndex(): int
                    public static class: java.lang.Class<any>
                }
                class LanguageCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public constructor()
                    public setLocale(arg0: java.util.Locale): void
                    public getLocale(): java.util.Locale
                    public static class: java.lang.Class<any>
                }
                class NameCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                    public getPrompt(): string
                    public getDefaultName(): string
                    public setName(arg0: java.lang.String | string): void
                    public getName(): string
                    public static class: java.lang.Class<any>
                }
                class PasswordCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public constructor(arg0: java.lang.String | string, arg1: boolean)
                    public getPrompt(): string
                    public isEchoOn(): boolean
                    public setPassword(arg0: char[]): void
                    public getPassword(): char[]
                    public clearPassword(): void
                    public static class: java.lang.Class<any>
                }
                class TextInputCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                    public getPrompt(): string
                    public getDefaultText(): string
                    public setText(arg0: java.lang.String | string): void
                    public getText(): string
                    public static class: java.lang.Class<any>
                }
                class TextOutputCallback implements javax.security.auth.callback.Callback , java.io.Serializable {
                    public static INFORMATION: int
                    public static WARNING: int
                    public static ERROR: int
                    public constructor(arg0: int, arg1: java.lang.String | string)
                    public getMessageType(): int
                    public getMessage(): string
                    public static class: java.lang.Class<any>
                }
                class UnsupportedCallbackException extends java.lang.Exception {
                    public constructor(arg0: javax.security.auth.callback.Callback)
                    public constructor(arg0: javax.security.auth.callback.Callback, arg1: java.lang.String | string)
                    public getCallback(): javax.security.auth.callback.Callback
                    public static class: java.lang.Class<any>
                }
            }
            namespace login {
                class AccountException extends javax.security.auth.login.LoginException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class AccountExpiredException extends javax.security.auth.login.AccountException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class AccountLockedException extends javax.security.auth.login.AccountException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class AccountNotFoundException extends javax.security.auth.login.AccountException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class AppConfigurationEntry {
                    public constructor(arg0: java.lang.String | string, arg1: javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag, arg2: java.util.Map<java.lang.String, any>)
                    public getLoginModuleName(): string
                    public getControlFlag(): javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag
                    public getOptions(): java.util.Map<java.lang.String, any>
                    public static class: java.lang.Class<any>
                }
                abstract class Configuration {
                    protected constructor()
                    public static getConfiguration(): javax.security.auth.login.Configuration
                    public static setConfiguration(arg0: javax.security.auth.login.Configuration): void
                    public static getInstance(arg0: java.lang.String | string, arg1: javax.security.auth.login.Configuration$Parameters): javax.security.auth.login.Configuration
                    public static getInstance(arg0: java.lang.String | string, arg1: javax.security.auth.login.Configuration$Parameters, arg2: java.lang.String | string): javax.security.auth.login.Configuration
                    public static getInstance(arg0: java.lang.String | string, arg1: javax.security.auth.login.Configuration$Parameters, arg2: java.security.Provider): javax.security.auth.login.Configuration
                    public getProvider(): java.security.Provider
                    public getType(): string
                    public getParameters(): javax.security.auth.login.Configuration$Parameters
                    public getAppConfigurationEntry(arg0: java.lang.String | string): javax.security.auth.login.AppConfigurationEntry[]
                    public refresh(): void
                    public static class: java.lang.Class<any>
                }
                abstract class ConfigurationSpi {
                    public constructor()
                    protected engineGetAppConfigurationEntry(arg0: java.lang.String | string): javax.security.auth.login.AppConfigurationEntry[]
                    protected engineRefresh(): void
                    public static class: java.lang.Class<any>
                }
                class CredentialException extends javax.security.auth.login.LoginException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class CredentialExpiredException extends javax.security.auth.login.CredentialException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class CredentialNotFoundException extends javax.security.auth.login.CredentialException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class FailedLoginException extends javax.security.auth.login.LoginException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
                class LoginContext {
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.String | string, arg1: javax.security.auth.Subject)
                    public constructor(arg0: java.lang.String | string, arg1: javax.security.auth.callback.CallbackHandler | javax.security.auth.callback.CallbackHandler$$Lambda)
                    public constructor(arg0: java.lang.String | string, arg1: javax.security.auth.Subject, arg2: javax.security.auth.callback.CallbackHandler | javax.security.auth.callback.CallbackHandler$$Lambda)
                    public constructor(arg0: java.lang.String | string, arg1: javax.security.auth.Subject, arg2: javax.security.auth.callback.CallbackHandler | javax.security.auth.callback.CallbackHandler$$Lambda, arg3: javax.security.auth.login.Configuration)
                    public login(): void
                    public logout(): void
                    public getSubject(): javax.security.auth.Subject
                    public static class: java.lang.Class<any>
                }
                class LoginException extends java.security.GeneralSecurityException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public static class: java.lang.Class<any>
                }
            }
            namespace spi {
                interface LoginModule {
                    initialize(arg0: javax.security.auth.Subject, arg1: javax.security.auth.callback.CallbackHandler | javax.security.auth.callback.CallbackHandler$$Lambda, arg2: java.util.Map<java.lang.String, any>, arg3: java.util.Map<java.lang.String, any>): void
                    login(): boolean
                    commit(): boolean
                    abort(): boolean
                    logout(): boolean
                }
            }
            namespace x500 {
                class X500Principal implements java.security.Principal , java.io.Serializable {
                    public static RFC1779: string
                    public static RFC2253: string
                    public static CANONICAL: string
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.String | string, arg1: java.util.Map<java.lang.String, java.lang.String>)
                    public constructor(arg0: byte[])
                    public constructor(arg0: java.io.InputStream)
                    public getName(): string
                    public getName(arg0: java.lang.String | string): string
                    public getName(arg0: java.lang.String | string, arg1: java.util.Map<java.lang.String, java.lang.String>): string
                    public getEncoded(): byte[]
                    public toString(): string
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public static class: java.lang.Class<any>
                }
                class X500PrivateCredential implements javax.security.auth.Destroyable {
                    public constructor(arg0: java.security.cert.X509Certificate, arg1: java.security.PrivateKey)
                    public constructor(arg0: java.security.cert.X509Certificate, arg1: java.security.PrivateKey, arg2: java.lang.String | string)
                    public getCertificate(): java.security.cert.X509Certificate
                    public getPrivateKey(): java.security.PrivateKey
                    public getAlias(): string
                    public destroy(): void
                    public isDestroyed(): boolean
                    public static class: java.lang.Class<any>
                }
            }
            class AuthPermission extends java.security.BasicPermission {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class DestroyFailedException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface Destroyable {
                destroy(): void
                isDestroyed(): boolean
            }
            class PrivateCredentialPermission extends java.security.Permission {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public getCredentialClass(): string
                public getPrincipals(): java.lang.String[][]
                public implies(arg0: java.security.Permission): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getActions(): string
                public newPermissionCollection(): java.security.PermissionCollection
                public static class: java.lang.Class<any>
            }
            class RefreshFailedException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface Refreshable {
                isCurrent(): boolean
                refresh(): void
            }
            class Subject implements java.io.Serializable {
                public constructor()
                public constructor(arg0: boolean, arg1: java.util.Set<java.security.Principal>, arg2: java.util.Set<any>, arg3: java.util.Set<any>)
                public setReadOnly(): void
                public isReadOnly(): boolean
                public static getSubject(arg0: java.security.AccessControlContext): javax.security.auth.Subject
                public static doAs<T>(arg0: javax.security.auth.Subject, arg1: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>): T
                public static doAs<T>(arg0: javax.security.auth.Subject, arg1: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>): T
                public static doAsPrivileged<T>(arg0: javax.security.auth.Subject, arg1: java.security.PrivilegedAction<T> | java.security.PrivilegedAction$$Lambda<T>, arg2: java.security.AccessControlContext): T
                public static doAsPrivileged<T>(arg0: javax.security.auth.Subject, arg1: java.security.PrivilegedExceptionAction<T> | java.security.PrivilegedExceptionAction$$Lambda<T>, arg2: java.security.AccessControlContext): T
                public getPrincipals(): java.util.Set<java.security.Principal>
                public getPrincipals<T extends java.security.Principal>(arg0: java.lang.Class<T>): java.util.Set<T>
                public getPublicCredentials<T extends java.security.Principal>(): java.util.Set<java.lang.Object>
                public getPrivateCredentials<T extends java.security.Principal>(): java.util.Set<java.lang.Object>
                public getPublicCredentials<T>(arg0: java.lang.Class<T>): java.util.Set<T>
                public getPrivateCredentials<T>(arg0: java.lang.Class<T>): java.util.Set<T>
                public equals<T>(arg0: java.lang.Object): boolean
                public toString<T>(): string
                public hashCode<T>(): int
                public static class: java.lang.Class<any>
            }
            class SubjectDomainCombiner implements java.security.DomainCombiner {
                public constructor(arg0: javax.security.auth.Subject)
                public getSubject(): javax.security.auth.Subject
                public combine(arg0: java.security.ProtectionDomain[], arg1: java.security.ProtectionDomain[]): java.security.ProtectionDomain[]
                public static class: java.lang.Class<any>
            }
            class SubjectDomainCombiner$$Lambda implements java.security.DomainCombiner {
                public constructor(arg0: javax.security.auth.Subject)
            }
        }
        namespace cert {
            abstract class Certificate {
                public constructor()
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getEncoded(): byte[]
                public verify(arg0: java.security.PublicKey): void
                public verify(arg0: java.security.PublicKey, arg1: java.lang.String | string): void
                public toString(): string
                public getPublicKey(): java.security.PublicKey
                public static class: java.lang.Class<any>
            }
            class CertificateEncodingException extends javax.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CertificateException extends java.lang.Exception {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CertificateExpiredException extends javax.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CertificateNotYetValidException extends javax.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class CertificateParsingException extends javax.security.cert.CertificateException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            abstract class X509Certificate extends javax.security.cert.Certificate {
                public constructor()
                public static getInstance(arg0: java.io.InputStream): javax.security.cert.X509Certificate
                public static getInstance(arg0: byte[]): javax.security.cert.X509Certificate
                public checkValidity(): void
                public checkValidity(arg0: java.util.Date): void
                public getVersion(): int
                public getSerialNumber(): java.math.BigInteger
                public getIssuerDN(): java.security.Principal
                public getSubjectDN(): java.security.Principal
                public getNotBefore(): java.util.Date
                public getNotAfter(): java.util.Date
                public getSigAlgName(): string
                public getSigAlgOID(): string
                public getSigAlgParams(): byte[]
                public static class: java.lang.Class<any>
            }
        }
    }
}
declare namespace jdk {
    namespace internal {
        namespace org {
            namespace objectweb {
                namespace asm {
                    namespace commons {
                        abstract class AdviceAdapter extends jdk.internal.org.objectweb.asm.commons.GeneratorAdapter implements jdk.internal.org.objectweb.asm.Opcodes {
                            protected methodAccess: int
                            protected methodDesc: string
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string)
                            public visitCode(): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitInsn(arg0: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            protected onMethodEnter(): void
                            protected onMethodExit(arg0: int): void
                            public static class: java.lang.Class<any>
                        }
                        class AnalyzerAdapter extends jdk.internal.org.objectweb.asm.MethodVisitor {
                            public locals: java.util.List<java.lang.Object>
                            public stack: java.util.List<java.lang.Object>
                            public uninitializedTypes: java.util.Map<java.lang.Object, java.lang.Object>
                            public constructor(arg0: java.lang.String | string, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: jdk.internal.org.objectweb.asm.MethodVisitor)
                            protected constructor(arg0: int, arg1: java.lang.String | string, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: jdk.internal.org.objectweb.asm.MethodVisitor)
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public static class: java.lang.Class<any>
                        }
                        class CodeSizeEvaluator extends jdk.internal.org.objectweb.asm.MethodVisitor implements jdk.internal.org.objectweb.asm.Opcodes {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor)
                            public getMinSize(): int
                            public getMaxSize(): int
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public static class: java.lang.Class<any>
                        }
                        class GeneratorAdapter extends jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter {
                            public static ADD: int
                            public static SUB: int
                            public static MUL: int
                            public static DIV: int
                            public static REM: int
                            public static NEG: int
                            public static SHL: int
                            public static SHR: int
                            public static USHR: int
                            public static AND: int
                            public static OR: int
                            public static XOR: int
                            public static EQ: int
                            public static NE: int
                            public static LT: int
                            public static GE: int
                            public static GT: int
                            public static LE: int
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string)
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.commons.Method, arg2: jdk.internal.org.objectweb.asm.MethodVisitor)
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.commons.Method, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Type[], arg4: jdk.internal.org.objectweb.asm.ClassVisitor)
                            public push(arg0: boolean): void
                            public push(arg0: int): void
                            public push(arg0: long): void
                            public push(arg0: float): void
                            public push(arg0: double): void
                            public push(arg0: java.lang.String | string): void
                            public push(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public push(arg0: jdk.internal.org.objectweb.asm.Handle): void
                            public loadThis(): void
                            public loadArg(arg0: int): void
                            public loadArgs(arg0: int, arg1: int): void
                            public loadArgs(): void
                            public loadArgArray(): void
                            public storeArg(arg0: int): void
                            public getLocalType(arg0: int): jdk.internal.org.objectweb.asm.Type
                            protected setLocalType(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public loadLocal(arg0: int): void
                            public loadLocal(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public storeLocal(arg0: int): void
                            public storeLocal(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public arrayLoad(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public arrayStore(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public pop(): void
                            public pop2(): void
                            public dup(): void
                            public dup2(): void
                            public dupX1(): void
                            public dupX2(): void
                            public dup2X1(): void
                            public dup2X2(): void
                            public swap(): void
                            public swap(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public math(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public not(): void
                            public iinc(arg0: int, arg1: int): void
                            public cast(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public box(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public valueOf(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public unbox(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public newLabel(): jdk.internal.org.objectweb.asm.Label
                            public mark(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public mark(): jdk.internal.org.objectweb.asm.Label
                            public ifCmp(arg0: jdk.internal.org.objectweb.asm.Type, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label): void
                            public ifICmp(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public ifZCmp(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public ifNull(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifNonNull(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public goTo(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ret(arg0: int): void
                            public tableSwitch(arg0: int[], arg1: jdk.internal.org.objectweb.asm.commons.TableSwitchGenerator): void
                            public tableSwitch(arg0: int[], arg1: jdk.internal.org.objectweb.asm.commons.TableSwitchGenerator, arg2: boolean): void
                            public returnValue(): void
                            public getStatic(arg0: jdk.internal.org.objectweb.asm.Type, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Type): void
                            public putStatic(arg0: jdk.internal.org.objectweb.asm.Type, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Type): void
                            public getField(arg0: jdk.internal.org.objectweb.asm.Type, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Type): void
                            public putField(arg0: jdk.internal.org.objectweb.asm.Type, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Type): void
                            public invokeVirtual(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.commons.Method): void
                            public invokeConstructor(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.commons.Method): void
                            public invokeStatic(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.commons.Method): void
                            public invokeInterface(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.commons.Method): void
                            public invokeDynamic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public newInstance(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public newArray(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public arrayLength(): void
                            public throwException(): void
                            public throwException(arg0: jdk.internal.org.objectweb.asm.Type, arg1: java.lang.String | string): void
                            public checkCast(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public instanceOf(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public monitorEnter(): void
                            public monitorExit(): void
                            public endMethod(): void
                            public catchException(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Type): void
                            public static class: java.lang.Class<any>
                        }
                        class InstructionAdapter extends jdk.internal.org.objectweb.asm.MethodVisitor {
                            public static OBJECT_TYPE: jdk.internal.org.objectweb.asm.Type
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor)
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public nop(): void
                            public aconst(arg0: java.lang.Object): void
                            public iconst(arg0: int): void
                            public lconst(arg0: long): void
                            public fconst(arg0: float): void
                            public dconst(arg0: double): void
                            public tconst(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public hconst(arg0: jdk.internal.org.objectweb.asm.Handle): void
                            public load(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public aload(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public store(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public astore(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public pop(): void
                            public pop2(): void
                            public dup(): void
                            public dup2(): void
                            public dupX1(): void
                            public dupX2(): void
                            public dup2X1(): void
                            public dup2X2(): void
                            public swap(): void
                            public add(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public sub(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public mul(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public div(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public rem(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public neg(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public shl(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public shr(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public ushr(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public and(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public or(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public xor(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public iinc(arg0: int, arg1: int): void
                            public cast(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.Type): void
                            public lcmp(): void
                            public cmpl(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public cmpg(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public ifeq(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifne(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public iflt(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifge(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifgt(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifle(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ificmpeq(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ificmpne(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ificmplt(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ificmpge(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ificmpgt(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ificmple(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifacmpeq(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifacmpne(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public goTo(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public jsr(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ret(arg0: int): void
                            public tableswitch(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public lookupswitch(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public areturn(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public getstatic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public putstatic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public getfield(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public putfield(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public invokevirtual(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public invokevirtual(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: boolean): void
                            public invokespecial(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public invokespecial(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: boolean): void
                            public invokestatic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public invokestatic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: boolean): void
                            public invokeinterface(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public invokedynamic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, arg3: java.lang.Object[]): void
                            public anew(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public newarray(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public arraylength(): void
                            public athrow(): void
                            public checkcast(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public instanceOf(arg0: jdk.internal.org.objectweb.asm.Type): void
                            public monitorenter(): void
                            public monitorexit(): void
                            public multianewarray(arg0: java.lang.String | string, arg1: int): void
                            public ifnull(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public ifnonnull(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public mark(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public static class: java.lang.Class<any>
                        }
                        class JSRInlinerAdapter extends jdk.internal.org.objectweb.asm.tree.MethodNode implements jdk.internal.org.objectweb.asm.Opcodes {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[])
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String | string, arg6: java.lang.String[])
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class LocalVariablesSorter extends jdk.internal.org.objectweb.asm.MethodVisitor {
                            protected firstLocal: int
                            protected nextLocal: int
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.MethodVisitor)
                            protected constructor(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.MethodVisitor)
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public newLocal(arg0: jdk.internal.org.objectweb.asm.Type): int
                            protected updateNewLocals(arg0: java.lang.Object[]): void
                            protected setLocalType(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type): void
                            protected newLocalMapping(arg0: jdk.internal.org.objectweb.asm.Type): int
                            public static class: java.lang.Class<any>
                        }
                        class Method {
                            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                            public constructor(arg0: java.lang.String | string, arg1: jdk.internal.org.objectweb.asm.Type, arg2: jdk.internal.org.objectweb.asm.Type[])
                            public static getMethod(arg0: java.lang.reflect.Method): jdk.internal.org.objectweb.asm.commons.Method
                            public static getMethod(arg0: java.lang.reflect.Constructor<any>): jdk.internal.org.objectweb.asm.commons.Method
                            public static getMethod(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.commons.Method
                            public static getMethod(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.commons.Method
                            public getName(): string
                            public getDescriptor(): string
                            public getReturnType(): jdk.internal.org.objectweb.asm.Type
                            public getArgumentTypes(): jdk.internal.org.objectweb.asm.Type[]
                            public toString(): string
                            public equals(arg0: java.lang.Object): boolean
                            public hashCode(): int
                            public static class: java.lang.Class<any>
                        }
                        abstract class Remapper {
                            public constructor()
                            public mapDesc(arg0: java.lang.String | string): string
                            public mapType(arg0: java.lang.String | string): string
                            public mapTypes(arg0: java.lang.String[]): java.lang.String[]
                            public mapMethodDesc(arg0: java.lang.String | string): string
                            public mapValue(arg0: java.lang.Object): java.lang.Object
                            public mapSignature(arg0: java.lang.String | string, arg1: boolean): string
                            protected createRemappingSignatureAdapter(arg0: jdk.internal.org.objectweb.asm.signature.SignatureVisitor): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public mapMethodName(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): string
                            public mapInvokeDynamicMethodName(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                            public mapFieldName(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): string
                            public map(arg0: java.lang.String | string): string
                            public static class: java.lang.Class<any>
                        }
                        class RemappingAnnotationAdapter extends jdk.internal.org.objectweb.asm.AnnotationVisitor {
                            protected remapper: jdk.internal.org.objectweb.asm.commons.Remapper
                            public constructor(arg0: jdk.internal.org.objectweb.asm.AnnotationVisitor, arg1: jdk.internal.org.objectweb.asm.commons.Remapper)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.AnnotationVisitor, arg2: jdk.internal.org.objectweb.asm.commons.Remapper)
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public static class: java.lang.Class<any>
                        }
                        class RemappingClassAdapter extends jdk.internal.org.objectweb.asm.ClassVisitor {
                            protected remapper: jdk.internal.org.objectweb.asm.commons.Remapper
                            protected className: string
                            public constructor(arg0: jdk.internal.org.objectweb.asm.ClassVisitor, arg1: jdk.internal.org.objectweb.asm.commons.Remapper)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.ClassVisitor, arg2: jdk.internal.org.objectweb.asm.commons.Remapper)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            protected createRemappingFieldAdapter(arg0: jdk.internal.org.objectweb.asm.FieldVisitor): jdk.internal.org.objectweb.asm.FieldVisitor
                            protected createRemappingMethodAdapter(arg0: int, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.MethodVisitor): jdk.internal.org.objectweb.asm.MethodVisitor
                            protected createRemappingAnnotationAdapter(arg0: jdk.internal.org.objectweb.asm.AnnotationVisitor): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public static class: java.lang.Class<any>
                        }
                        class RemappingFieldAdapter extends jdk.internal.org.objectweb.asm.FieldVisitor {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.FieldVisitor, arg1: jdk.internal.org.objectweb.asm.commons.Remapper)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.FieldVisitor, arg2: jdk.internal.org.objectweb.asm.commons.Remapper)
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public static class: java.lang.Class<any>
                        }
                        class RemappingMethodAdapter extends jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter {
                            protected remapper: jdk.internal.org.objectweb.asm.commons.Remapper
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.MethodVisitor, arg3: jdk.internal.org.objectweb.asm.commons.Remapper)
                            protected constructor(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.MethodVisitor, arg4: jdk.internal.org.objectweb.asm.commons.Remapper)
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public static class: java.lang.Class<any>
                        }
                        class RemappingSignatureAdapter extends jdk.internal.org.objectweb.asm.signature.SignatureVisitor {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.signature.SignatureVisitor, arg1: jdk.internal.org.objectweb.asm.commons.Remapper)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.signature.SignatureVisitor, arg2: jdk.internal.org.objectweb.asm.commons.Remapper)
                            public visitClassType(arg0: java.lang.String | string): void
                            public visitInnerClassType(arg0: java.lang.String | string): void
                            public visitFormalTypeParameter(arg0: java.lang.String | string): void
                            public visitTypeVariable(arg0: java.lang.String | string): void
                            public visitArrayType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitBaseType(arg0: char): void
                            public visitClassBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitExceptionType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterface(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterfaceBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitParameterType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitReturnType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitSuperclass(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitTypeArgument(): void
                            public visitTypeArgument(arg0: char): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class SerialVersionUIDAdder extends jdk.internal.org.objectweb.asm.ClassVisitor {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.ClassVisitor)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.ClassVisitor)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitEnd(): void
                            public hasSVUID(): boolean
                            protected addSVUID(arg0: long): void
                            protected computeSVUID(): long
                            protected computeSHAdigest(arg0: byte[]): byte[]
                            public static class: java.lang.Class<any>
                        }
                        class SimpleRemapper extends jdk.internal.org.objectweb.asm.commons.Remapper {
                            public constructor(arg0: java.util.Map<java.lang.String, java.lang.String>)
                            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                            public mapMethodName(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): string
                            public mapFieldName(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): string
                            public map(arg0: java.lang.String | string): string
                            public static class: java.lang.Class<any>
                        }
                        class StaticInitMerger extends jdk.internal.org.objectweb.asm.ClassVisitor {
                            public constructor(arg0: java.lang.String | string, arg1: jdk.internal.org.objectweb.asm.ClassVisitor)
                            protected constructor(arg0: int, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.ClassVisitor)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        interface TableSwitchGenerator {
                            generateCase(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            generateDefault(): void
                        }
                        class TryCatchBlockSorter extends jdk.internal.org.objectweb.asm.tree.MethodNode {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[])
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String | string, arg6: java.lang.String[])
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                    }
                    namespace signature {
                        class SignatureReader {
                            public constructor(arg0: java.lang.String | string)
                            public accept(arg0: jdk.internal.org.objectweb.asm.signature.SignatureVisitor): void
                            public acceptType(arg0: jdk.internal.org.objectweb.asm.signature.SignatureVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        abstract class SignatureVisitor {
                            public static EXTENDS: char
                            public static SUPER: char
                            public static INSTANCEOF: char
                            protected api: int
                            public constructor(arg0: int)
                            public visitFormalTypeParameter(arg0: java.lang.String | string): void
                            public visitClassBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterfaceBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitSuperclass(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterface(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitParameterType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitReturnType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitExceptionType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitBaseType(arg0: char): void
                            public visitTypeVariable(arg0: java.lang.String | string): void
                            public visitArrayType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitClassType(arg0: java.lang.String | string): void
                            public visitInnerClassType(arg0: java.lang.String | string): void
                            public visitTypeArgument(): void
                            public visitTypeArgument(arg0: char): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class SignatureWriter extends jdk.internal.org.objectweb.asm.signature.SignatureVisitor {
                            public constructor()
                            public visitFormalTypeParameter(arg0: java.lang.String | string): void
                            public visitClassBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterfaceBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitSuperclass(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterface(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitParameterType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitReturnType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitExceptionType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitBaseType(arg0: char): void
                            public visitTypeVariable(arg0: java.lang.String | string): void
                            public visitArrayType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitClassType(arg0: java.lang.String | string): void
                            public visitInnerClassType(arg0: java.lang.String | string): void
                            public visitTypeArgument(): void
                            public visitTypeArgument(arg0: char): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitEnd(): void
                            public toString(): string
                            public static class: java.lang.Class<any>
                        }
                    }
                    namespace tree {
                        namespace analysis {
                            class Analyzer<V extends jdk.internal.org.objectweb.asm.tree.analysis.Value> implements jdk.internal.org.objectweb.asm.Opcodes {
                                public constructor(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Interpreter<V>)
                                public analyze(arg0: java.lang.String | string, arg1: jdk.internal.org.objectweb.asm.tree.MethodNode): jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>[]
                                public getFrames(): jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>[]
                                public getHandlers(arg0: int): java.util.List<jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode>
                                protected init(arg0: java.lang.String | string, arg1: jdk.internal.org.objectweb.asm.tree.MethodNode): void
                                protected newFrame(arg0: int, arg1: int): jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>
                                protected newFrame(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>): jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>
                                protected newControlFlowEdge(arg0: int, arg1: int): void
                                protected newControlFlowExceptionEdge(arg0: int, arg1: int): boolean
                                protected newControlFlowExceptionEdge(arg0: int, arg1: jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode): boolean
                                public static class: java.lang.Class<any>
                            }
                            class AnalyzerException extends java.lang.Exception {
                                public node: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                                public constructor(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.lang.String | string)
                                public constructor(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.lang.String | string, arg2: java.lang.Throwable)
                                public constructor(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.lang.String | string, arg2: java.lang.Object, arg3: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda)
                                public static class: java.lang.Class<any>
                            }
                            class BasicInterpreter extends jdk.internal.org.objectweb.asm.tree.analysis.Interpreter<jdk.internal.org.objectweb.asm.tree.analysis.BasicValue> implements jdk.internal.org.objectweb.asm.Opcodes {
                                public constructor()
                                protected constructor(arg0: int)
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public newOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg3: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List<jdk.internal.org.objectweb.asm.tree.analysis.BasicValue>): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): void
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): void
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg3: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public newOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public static class: java.lang.Class<any>
                            }
                            class BasicValue implements jdk.internal.org.objectweb.asm.tree.analysis.Value {
                                public static UNINITIALIZED_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public static INT_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public static FLOAT_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public static LONG_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public static DOUBLE_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public static REFERENCE_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public static RETURNADDRESS_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public constructor(arg0: jdk.internal.org.objectweb.asm.Type)
                                public getType(): jdk.internal.org.objectweb.asm.Type
                                public getSize(): int
                                public isReference(): boolean
                                public equals(arg0: java.lang.Object): boolean
                                public hashCode(): int
                                public toString(): string
                                public static class: java.lang.Class<any>
                            }
                            class BasicValue$$Lambda implements jdk.internal.org.objectweb.asm.tree.analysis.Value {
                                public static UNINITIALIZED_VALUE: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                            }
                            class BasicVerifier extends jdk.internal.org.objectweb.asm.tree.analysis.BasicInterpreter {
                                public constructor()
                                protected constructor(arg0: int)
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg3: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List<jdk.internal.org.objectweb.asm.tree.analysis.BasicValue>): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): void
                                protected isArrayValue(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): boolean
                                protected getElementValue(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                protected isSubTypeOf(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): boolean
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): void
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg3: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public static class: java.lang.Class<any>
                            }
                            class Frame<V extends jdk.internal.org.objectweb.asm.tree.analysis.Value> {
                                public constructor(arg0: int, arg1: int)
                                public constructor(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>)
                                public init(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>): jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>
                                public setReturn(arg0: V): void
                                public getLocals(): int
                                public getMaxStackSize(): int
                                public getLocal(arg0: int): V
                                public setLocal(arg0: int, arg1: V): void
                                public getStackSize(): int
                                public getStack(arg0: int): V
                                public clearStack(): void
                                public pop(): V
                                public push(arg0: V): void
                                public execute(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Interpreter<V>): void
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Interpreter<V>): boolean
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Frame<V>, arg1: boolean[]): boolean
                                public toString(): string
                                public static class: java.lang.Class<any>
                            }
                            abstract class Interpreter<V extends jdk.internal.org.objectweb.asm.tree.analysis.Value> {
                                protected api: int
                                protected constructor(arg0: int)
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): V
                                public newOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): V
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: V): V
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: V): V
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: V, arg2: V): V
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: V, arg2: V, arg3: V): V
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List<V>): V
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: V, arg2: V): void
                                public merge(arg0: V, arg1: V): V
                                public static class: java.lang.Class<any>
                            }
                            class SimpleVerifier extends jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier {
                                public constructor()
                                public constructor(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.Type, arg2: boolean)
                                public constructor(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.Type, arg2: java.util.List<jdk.internal.org.objectweb.asm.Type>, arg3: boolean)
                                protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.Type, arg2: jdk.internal.org.objectweb.asm.Type, arg3: java.util.List<jdk.internal.org.objectweb.asm.Type>, arg4: boolean)
                                public setClassLoader(arg0: java.lang.ClassLoader): void
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                protected isArrayValue(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): boolean
                                protected getElementValue(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                protected isSubTypeOf(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): boolean
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.BasicValue | jdk.internal.org.objectweb.asm.tree.analysis.BasicValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.BasicValue
                                protected isInterface(arg0: jdk.internal.org.objectweb.asm.Type): boolean
                                protected getSuperClass(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.Type
                                protected isAssignableFrom(arg0: jdk.internal.org.objectweb.asm.Type, arg1: jdk.internal.org.objectweb.asm.Type): boolean
                                protected getClass(arg0: jdk.internal.org.objectweb.asm.Type): java.lang.Class<any>
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public static class: java.lang.Class<any>
                            }
                            class SmallSet<E> extends java.util.AbstractSet<E> implements java.util.Iterator<E> {
                                public iterator(): java.util.Iterator<E>
                                public size(): int
                                public hasNext(): boolean
                                public next(): E
                                public remove(): void
                                public static class: java.lang.Class<any>
                            }
                            class SourceInterpreter extends jdk.internal.org.objectweb.asm.tree.analysis.Interpreter<jdk.internal.org.objectweb.asm.tree.analysis.SourceValue> implements jdk.internal.org.objectweb.asm.Opcodes {
                                public constructor()
                                protected constructor(arg0: int)
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public newOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda, arg3: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List<jdk.internal.org.objectweb.asm.tree.analysis.SourceValue>): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda): void
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.SourceValue | jdk.internal.org.objectweb.asm.tree.analysis.SourceValue$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.SourceValue
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public returnOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): void
                                public naryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: java.util.List): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public ternaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg3: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public binaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda, arg2: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public unaryOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public copyOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.analysis.Value | jdk.internal.org.objectweb.asm.tree.analysis.Value$$Lambda): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public newOperation(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public newValue(arg0: jdk.internal.org.objectweb.asm.Type): jdk.internal.org.objectweb.asm.tree.analysis.Value
                                public static class: java.lang.Class<any>
                            }
                            class SourceValue implements jdk.internal.org.objectweb.asm.tree.analysis.Value {
                                public size: int
                                public insns: java.util.Set<jdk.internal.org.objectweb.asm.tree.AbstractInsnNode>
                                public constructor(arg0: int)
                                public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode)
                                public constructor(arg0: int, arg1: java.util.Set<jdk.internal.org.objectweb.asm.tree.AbstractInsnNode>)
                                public getSize(): int
                                public equals(arg0: java.lang.Object): boolean
                                public hashCode(): int
                                public static class: java.lang.Class<any>
                            }
                            class SourceValue$$Lambda implements jdk.internal.org.objectweb.asm.tree.analysis.Value {
                                public size: int
                            }
                            class Subroutine {
                                public copy(): jdk.internal.org.objectweb.asm.tree.analysis.Subroutine
                                public merge(arg0: jdk.internal.org.objectweb.asm.tree.analysis.Subroutine): boolean
                                public static class: java.lang.Class<any>
                            }
                            interface Value {
                                getSize(): int
                            }
                            interface Value$$Lambda {
                                (): int
                            }
                        }
                        abstract class AbstractInsnNode {
                            public static INSN: int
                            public static INT_INSN: int
                            public static VAR_INSN: int
                            public static TYPE_INSN: int
                            public static FIELD_INSN: int
                            public static METHOD_INSN: int
                            public static INVOKE_DYNAMIC_INSN: int
                            public static JUMP_INSN: int
                            public static LABEL: int
                            public static LDC_INSN: int
                            public static IINC_INSN: int
                            public static TABLESWITCH_INSN: int
                            public static LOOKUPSWITCH_INSN: int
                            public static MULTIANEWARRAY_INSN: int
                            public static FRAME: int
                            public static LINE: int
                            protected opcode: int
                            public visibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public invisibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            protected constructor(arg0: int)
                            public getOpcode(): int
                            public getType(): int
                            public getPrevious(): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public getNext(): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            protected acceptAnnotations(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            protected cloneAnnotations(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class AnnotationNode extends jdk.internal.org.objectweb.asm.AnnotationVisitor {
                            public desc: string
                            public values: java.util.List<java.lang.Object>
                            public constructor(arg0: java.lang.String | string)
                            public constructor(arg0: int, arg1: java.lang.String | string)
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitEnd(): void
                            public check(arg0: int): void
                            public accept(arg0: jdk.internal.org.objectweb.asm.AnnotationVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class ClassNode extends jdk.internal.org.objectweb.asm.ClassVisitor {
                            public version: int
                            public access: int
                            public name: string
                            public signature: string
                            public superName: string
                            public interfaces: java.util.List<java.lang.String>
                            public sourceFile: string
                            public sourceDebug: string
                            public outerClass: string
                            public outerMethod: string
                            public outerMethodDesc: string
                            public visibleAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>
                            public invisibleAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>
                            public visibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public invisibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public attrs: java.util.List<jdk.internal.org.objectweb.asm.Attribute>
                            public innerClasses: java.util.List<jdk.internal.org.objectweb.asm.tree.InnerClassNode>
                            public fields: java.util.List<jdk.internal.org.objectweb.asm.tree.FieldNode>
                            public methods: java.util.List<jdk.internal.org.objectweb.asm.tree.MethodNode>
                            public constructor()
                            public constructor(arg0: int)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                            public visitEnd(): void
                            public check(arg0: int): void
                            public accept(arg0: jdk.internal.org.objectweb.asm.ClassVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class FieldInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public owner: string
                            public name: string
                            public desc: string
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string)
                            public setOpcode(arg0: int): void
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class FieldNode extends jdk.internal.org.objectweb.asm.FieldVisitor {
                            public access: int
                            public name: string
                            public desc: string
                            public signature: string
                            public value: java.lang.Object
                            public visibleAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>
                            public invisibleAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>
                            public visibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public invisibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public attrs: java.util.List<jdk.internal.org.objectweb.asm.Attribute>
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object)
                            public constructor(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.Object)
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitEnd(): void
                            public check(arg0: int): void
                            public accept(arg0: jdk.internal.org.objectweb.asm.ClassVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class FrameNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public type: int
                            public local: java.util.List<java.lang.Object>
                            public stack: java.util.List<java.lang.Object>
                            public constructor(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[])
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class IincInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public var: int
                            public incr: int
                            public constructor(arg0: int, arg1: int)
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class InnerClassNode {
                            public name: string
                            public outerName: string
                            public innerName: string
                            public access: int
                            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int)
                            public accept(arg0: jdk.internal.org.objectweb.asm.ClassVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class InsnList {
                            public constructor()
                            public size(): int
                            public getFirst(): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public getLast(): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public get(arg0: int): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public contains(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): boolean
                            public indexOf(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public iterator(): java.util.ListIterator<jdk.internal.org.objectweb.asm.tree.AbstractInsnNode>
                            public iterator(arg0: int): java.util.ListIterator<jdk.internal.org.objectweb.asm.tree.AbstractInsnNode>
                            public toArray(): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode[]
                            public set(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): void
                            public add(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): void
                            public add(arg0: jdk.internal.org.objectweb.asm.tree.InsnList): void
                            public insert(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): void
                            public insert(arg0: jdk.internal.org.objectweb.asm.tree.InsnList): void
                            public insert(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): void
                            public insert(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.InsnList): void
                            public insertBefore(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): void
                            public insertBefore(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode, arg1: jdk.internal.org.objectweb.asm.tree.InsnList): void
                            public remove(arg0: jdk.internal.org.objectweb.asm.tree.AbstractInsnNode): void
                            public clear(): void
                            public resetLabels(): void
                            public static class: java.lang.Class<any>
                        }
                        class InsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public constructor(arg0: int)
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class IntInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public operand: int
                            public constructor(arg0: int, arg1: int)
                            public setOpcode(arg0: int): void
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class InvokeDynamicInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public name: string
                            public desc: string
                            public bsm: jdk.internal.org.objectweb.asm.Handle
                            public bsmArgs: java.lang.Object[]
                            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[])
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class JumpInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public label: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.tree.LabelNode)
                            public setOpcode(arg0: int): void
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class LabelNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public constructor()
                            public constructor(arg0: jdk.internal.org.objectweb.asm.Label)
                            public getType(): int
                            public getLabel(): jdk.internal.org.objectweb.asm.Label
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public resetLabel(): void
                            public static class: java.lang.Class<any>
                        }
                        class LdcInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public cst: java.lang.Object
                            public constructor(arg0: java.lang.Object)
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class LineNumberNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public line: int
                            public start: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.tree.LabelNode)
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class LocalVariableAnnotationNode extends jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode {
                            public start: java.util.List<jdk.internal.org.objectweb.asm.tree.LabelNode>
                            public end: java.util.List<jdk.internal.org.objectweb.asm.tree.LabelNode>
                            public index: java.util.List<java.lang.Integer>
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.tree.LabelNode[], arg3: jdk.internal.org.objectweb.asm.tree.LabelNode[], arg4: int[], arg5: java.lang.String | string)
                            public constructor(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.TypePath, arg3: jdk.internal.org.objectweb.asm.tree.LabelNode[], arg4: jdk.internal.org.objectweb.asm.tree.LabelNode[], arg5: int[], arg6: java.lang.String | string)
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor, arg1: boolean): void
                            public static class: java.lang.Class<any>
                        }
                        class LocalVariableNode {
                            public name: string
                            public desc: string
                            public signature: string
                            public start: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public end: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public index: int
                            public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.tree.LabelNode, arg4: jdk.internal.org.objectweb.asm.tree.LabelNode, arg5: int)
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class LookupSwitchInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public dflt: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public keys: java.util.List<java.lang.Integer>
                            public labels: java.util.List<jdk.internal.org.objectweb.asm.tree.LabelNode>
                            public constructor(arg0: jdk.internal.org.objectweb.asm.tree.LabelNode, arg1: int[], arg2: jdk.internal.org.objectweb.asm.tree.LabelNode[])
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class MethodInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public owner: string
                            public name: string
                            public desc: string
                            public itf: boolean
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string)
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean)
                            public setOpcode(arg0: int): void
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class MethodNode extends jdk.internal.org.objectweb.asm.MethodVisitor {
                            public access: int
                            public name: string
                            public desc: string
                            public signature: string
                            public exceptions: java.util.List<java.lang.String>
                            public parameters: java.util.List<jdk.internal.org.objectweb.asm.tree.ParameterNode>
                            public visibleAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>
                            public invisibleAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>
                            public visibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public invisibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public attrs: java.util.List<jdk.internal.org.objectweb.asm.Attribute>
                            public annotationDefault: java.lang.Object
                            public visibleParameterAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>[]
                            public invisibleParameterAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.AnnotationNode>[]
                            public instructions: jdk.internal.org.objectweb.asm.tree.InsnList
                            public tryCatchBlocks: java.util.List<jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode>
                            public maxStack: int
                            public maxLocals: int
                            public localVariables: java.util.List<jdk.internal.org.objectweb.asm.tree.LocalVariableNode>
                            public visibleLocalVariableAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.LocalVariableAnnotationNode>
                            public invisibleLocalVariableAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.LocalVariableAnnotationNode>
                            public constructor()
                            public constructor(arg0: int)
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[])
                            public constructor(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[])
                            public visitParameter(arg0: java.lang.String | string, arg1: int): void
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitCode(): void
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitEnd(): void
                            protected getLabelNode(arg0: jdk.internal.org.objectweb.asm.Label): jdk.internal.org.objectweb.asm.tree.LabelNode
                            public check(arg0: int): void
                            public accept(arg0: jdk.internal.org.objectweb.asm.ClassVisitor): void
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class MultiANewArrayInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public desc: string
                            public dims: int
                            public constructor(arg0: java.lang.String | string, arg1: int)
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class ParameterNode {
                            public name: string
                            public access: int
                            public constructor(arg0: java.lang.String | string, arg1: int)
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class TableSwitchInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public min: int
                            public max: int
                            public dflt: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public labels: java.util.List<jdk.internal.org.objectweb.asm.tree.LabelNode>
                            public constructor(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.tree.LabelNode, ...arg3: jdk.internal.org.objectweb.asm.tree.LabelNode[])
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class TryCatchBlockNode {
                            public start: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public end: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public handler: jdk.internal.org.objectweb.asm.tree.LabelNode
                            public type: string
                            public visibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public invisibleTypeAnnotations: java.util.List<jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode>
                            public constructor(arg0: jdk.internal.org.objectweb.asm.tree.LabelNode, arg1: jdk.internal.org.objectweb.asm.tree.LabelNode, arg2: jdk.internal.org.objectweb.asm.tree.LabelNode, arg3: java.lang.String | string)
                            public updateIndex(arg0: int): void
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public static class: java.lang.Class<any>
                        }
                        class TypeAnnotationNode extends jdk.internal.org.objectweb.asm.tree.AnnotationNode {
                            public typeRef: int
                            public typePath: jdk.internal.org.objectweb.asm.TypePath
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string)
                            public constructor(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.TypePath, arg3: java.lang.String | string)
                            public static class: java.lang.Class<any>
                        }
                        class TypeInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public desc: string
                            public constructor(arg0: int, arg1: java.lang.String | string)
                            public setOpcode(arg0: int): void
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                        class VarInsnNode extends jdk.internal.org.objectweb.asm.tree.AbstractInsnNode {
                            public var: int
                            public constructor(arg0: int, arg1: int)
                            public setOpcode(arg0: int): void
                            public getType(): int
                            public accept(arg0: jdk.internal.org.objectweb.asm.MethodVisitor): void
                            public clone(arg0: java.util.Map<jdk.internal.org.objectweb.asm.tree.LabelNode, jdk.internal.org.objectweb.asm.tree.LabelNode>): jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
                            public static class: java.lang.Class<any>
                        }
                    }
                    namespace util {
                        interface ASMifiable {
                            asmify(arg0: java.lang.StringBuffer, arg1: java.lang.String | string, arg2: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.String>): void
                        }
                        interface ASMifiable$$Lambda {
                            (arg0: java.lang.StringBuffer, arg1: java.lang.String | string, arg2: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.String>): void
                        }
                        class ASMifier extends jdk.internal.org.objectweb.asm.util.Printer {
                            protected name: string
                            protected id: int
                            protected labelNames: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.String>
                            public constructor()
                            protected constructor(arg0: int, arg1: java.lang.String | string, arg2: int)
                            public static main(arg0: java.lang.String[]): void
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitClassAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitClassTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitClassAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitClassEnd(): void
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitAnnotationEnd(): void
                            public visitFieldAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitFieldTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitFieldAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitFieldEnd(): void
                            public visitParameter(arg0: java.lang.String | string, arg1: int): void
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitMethodAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitMethodTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitMethodAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitCode(): void
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitMethodEnd(): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitTypeAnnotation(arg0: java.lang.String | string, arg1: int, arg2: jdk.internal.org.objectweb.asm.TypePath, arg3: java.lang.String | string, arg4: boolean): jdk.internal.org.objectweb.asm.util.ASMifier
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            protected createASMifier(arg0: java.lang.String | string, arg1: int): jdk.internal.org.objectweb.asm.util.ASMifier
                            protected appendConstant(arg0: java.lang.Object): void
                            protected declareLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            protected appendLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethodTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethodAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.util.Printer
                            public visitFieldTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitFieldAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Printer
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.util.Printer
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public static class: java.lang.Class<any>
                        }
                        class CheckAnnotationAdapter extends jdk.internal.org.objectweb.asm.AnnotationVisitor {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.AnnotationVisitor)
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class CheckClassAdapter extends jdk.internal.org.objectweb.asm.ClassVisitor {
                            public static main(arg0: java.lang.String[]): void
                            public static verify(arg0: jdk.internal.org.objectweb.asm.ClassReader, arg1: java.lang.ClassLoader, arg2: boolean, arg3: java.io.PrintWriter): void
                            public static verify(arg0: jdk.internal.org.objectweb.asm.ClassReader, arg1: boolean, arg2: java.io.PrintWriter): void
                            public constructor(arg0: jdk.internal.org.objectweb.asm.ClassVisitor)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.ClassVisitor, arg1: boolean)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.ClassVisitor, arg2: boolean)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitEnd(): void
                            public static checkClassSignature(arg0: java.lang.String | string): void
                            public static checkMethodSignature(arg0: java.lang.String | string): void
                            public static checkFieldSignature(arg0: java.lang.String | string): void
                            public static class: java.lang.Class<any>
                        }
                        class CheckFieldAdapter extends jdk.internal.org.objectweb.asm.FieldVisitor {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.FieldVisitor)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.FieldVisitor)
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class CheckMethodAdapter extends jdk.internal.org.objectweb.asm.MethodVisitor {
                            public version: int
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor, arg1: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.Integer>)
                            protected constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor, arg2: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.Integer>)
                            public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.MethodVisitor, arg4: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.Integer>)
                            public visitParameter(arg0: java.lang.String | string, arg1: int): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitCode(): void
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class CheckSignatureAdapter extends jdk.internal.org.objectweb.asm.signature.SignatureVisitor {
                            public static CLASS_SIGNATURE: int
                            public static METHOD_SIGNATURE: int
                            public static TYPE_SIGNATURE: int
                            public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.signature.SignatureVisitor)
                            protected constructor(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.signature.SignatureVisitor)
                            public visitFormalTypeParameter(arg0: java.lang.String | string): void
                            public visitClassBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterfaceBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitSuperclass(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterface(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitParameterType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitReturnType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitExceptionType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitBaseType(arg0: char): void
                            public visitTypeVariable(arg0: java.lang.String | string): void
                            public visitArrayType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitClassType(arg0: java.lang.String | string): void
                            public visitInnerClassType(arg0: java.lang.String | string): void
                            public visitTypeArgument(): void
                            public visitTypeArgument(arg0: char): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        abstract class Printer {
                            public static OPCODES: java.lang.String[]
                            public static TYPES: java.lang.String[]
                            public static HANDLE_TAG: java.lang.String[]
                            protected api: int
                            protected buf: java.lang.StringBuffer
                            public text: java.util.List<java.lang.Object>
                            protected constructor(arg0: int)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitClassAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassEnd(): void
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Printer
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Printer
                            public visitAnnotationEnd(): void
                            public visitFieldAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitFieldTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitFieldAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitFieldEnd(): void
                            public visitParameter(arg0: java.lang.String | string, arg1: int): void
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethodAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethodTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethodAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitCode(): void
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitMethodEnd(): void
                            public getText(): java.util.List<java.lang.Object>
                            public print(arg0: java.io.PrintWriter): void
                            public static appendString(arg0: java.lang.StringBuffer, arg1: java.lang.String | string): void
                            public static class: java.lang.Class<any>
                        }
                        interface Textifiable {
                            textify(arg0: java.lang.StringBuffer, arg1: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.String>): void
                        }
                        interface Textifiable$$Lambda {
                            (arg0: java.lang.StringBuffer, arg1: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.String>): void
                        }
                        class Textifier extends jdk.internal.org.objectweb.asm.util.Printer {
                            public static INTERNAL_NAME: int
                            public static FIELD_DESCRIPTOR: int
                            public static FIELD_SIGNATURE: int
                            public static METHOD_DESCRIPTOR: int
                            public static METHOD_SIGNATURE: int
                            public static CLASS_SIGNATURE: int
                            public static TYPE_DECLARATION: int
                            public static CLASS_DECLARATION: int
                            public static PARAMETERS_DECLARATION: int
                            public static HANDLE_DESCRIPTOR: int
                            protected tab: string
                            protected tab2: string
                            protected tab3: string
                            protected ltab: string
                            protected labelNames: java.util.Map<jdk.internal.org.objectweb.asm.Label, java.lang.String>
                            public constructor()
                            protected constructor(arg0: int)
                            public static main(arg0: java.lang.String[]): void
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitClassAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitClassTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitClassEnd(): void
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitAnnotationEnd(): void
                            public visitFieldAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitFieldTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitFieldAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitFieldEnd(): void
                            public visitParameter(arg0: java.lang.String | string, arg1: int): void
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitMethodAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitMethodTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitMethodAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitCode(): void
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitMethodEnd(): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.util.Textifier
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            protected createTextifier(): jdk.internal.org.objectweb.asm.util.Textifier
                            protected appendDescriptor(arg0: int, arg1: java.lang.String | string): void
                            protected appendLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            protected appendHandle(arg0: jdk.internal.org.objectweb.asm.Handle): void
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethodAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.util.Printer
                            public visitFieldAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Printer
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.util.Printer
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.util.Printer
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.util.Printer
                            public visitClassAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.util.Printer
                            public static class: java.lang.Class<any>
                        }
                        class TraceAnnotationVisitor extends jdk.internal.org.objectweb.asm.AnnotationVisitor {
                            public constructor(arg0: jdk.internal.org.objectweb.asm.util.Printer)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.AnnotationVisitor, arg1: jdk.internal.org.objectweb.asm.util.Printer)
                            public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                            public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class TraceClassVisitor extends jdk.internal.org.objectweb.asm.ClassVisitor {
                            public p: jdk.internal.org.objectweb.asm.util.Printer
                            public constructor(arg0: java.io.PrintWriter)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.ClassVisitor, arg1: java.io.PrintWriter)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.ClassVisitor, arg1: jdk.internal.org.objectweb.asm.util.Printer, arg2: java.io.PrintWriter)
                            public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                            public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                            public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                            public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class TraceFieldVisitor extends jdk.internal.org.objectweb.asm.FieldVisitor {
                            public p: jdk.internal.org.objectweb.asm.util.Printer
                            public constructor(arg0: jdk.internal.org.objectweb.asm.util.Printer)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.FieldVisitor, arg1: jdk.internal.org.objectweb.asm.util.Printer)
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class TraceMethodVisitor extends jdk.internal.org.objectweb.asm.MethodVisitor {
                            public p: jdk.internal.org.objectweb.asm.util.Printer
                            public constructor(arg0: jdk.internal.org.objectweb.asm.util.Printer)
                            public constructor(arg0: jdk.internal.org.objectweb.asm.MethodVisitor, arg1: jdk.internal.org.objectweb.asm.util.Printer)
                            public visitParameter(arg0: java.lang.String | string, arg1: int): void
                            public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                            public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitCode(): void
                            public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                            public visitInsn(arg0: int): void
                            public visitIntInsn(arg0: int, arg1: int): void
                            public visitVarInsn(arg0: int, arg1: int): void
                            public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                            public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                            public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                            public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                            public visitLdcInsn(arg0: java.lang.Object): void
                            public visitIincInsn(arg0: int, arg1: int): void
                            public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                            public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                            public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                            public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                            public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                            public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                            public visitMaxs(arg0: int, arg1: int): void
                            public visitEnd(): void
                            public static class: java.lang.Class<any>
                        }
                        class TraceSignatureVisitor extends jdk.internal.org.objectweb.asm.signature.SignatureVisitor {
                            public constructor(arg0: int)
                            public visitFormalTypeParameter(arg0: java.lang.String | string): void
                            public visitClassBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterfaceBound(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitSuperclass(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitInterface(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitParameterType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitReturnType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitExceptionType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitBaseType(arg0: char): void
                            public visitTypeVariable(arg0: java.lang.String | string): void
                            public visitArrayType(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitClassType(arg0: java.lang.String | string): void
                            public visitInnerClassType(arg0: java.lang.String | string): void
                            public visitTypeArgument(): void
                            public visitTypeArgument(arg0: char): jdk.internal.org.objectweb.asm.signature.SignatureVisitor
                            public visitEnd(): void
                            public getDeclaration(): string
                            public getReturnType(): string
                            public getExceptions(): string
                            public static class: java.lang.Class<any>
                        }
                    }
                    abstract class AnnotationVisitor {
                        protected api: int
                        protected av: jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public constructor(arg0: int)
                        public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.AnnotationVisitor)
                        public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                        public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    class AnnotationWriter extends jdk.internal.org.objectweb.asm.AnnotationVisitor {
                        public visit(arg0: java.lang.String | string, arg1: java.lang.Object): void
                        public visitEnum(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        public visitAnnotation(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitArray(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    class Attribute {
                        public type: string
                        protected constructor(arg0: java.lang.String | string)
                        public isUnknown(): boolean
                        public isCodeAttribute(): boolean
                        protected getLabels(): jdk.internal.org.objectweb.asm.Label[]
                        protected read(arg0: jdk.internal.org.objectweb.asm.ClassReader, arg1: int, arg2: int, arg3: char[], arg4: int, arg5: jdk.internal.org.objectweb.asm.Label[]): jdk.internal.org.objectweb.asm.Attribute
                        protected write(arg0: jdk.internal.org.objectweb.asm.ClassWriter, arg1: byte[], arg2: int, arg3: int, arg4: int): jdk.internal.org.objectweb.asm.ByteVector
                        public static class: java.lang.Class<any>
                    }
                    class ByteVector {
                        public constructor()
                        public constructor(arg0: int)
                        public putByte(arg0: int): jdk.internal.org.objectweb.asm.ByteVector
                        public putShort(arg0: int): jdk.internal.org.objectweb.asm.ByteVector
                        public putInt(arg0: int): jdk.internal.org.objectweb.asm.ByteVector
                        public putLong(arg0: long): jdk.internal.org.objectweb.asm.ByteVector
                        public putUTF8(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.ByteVector
                        public putByteArray(arg0: byte[], arg1: int, arg2: int): jdk.internal.org.objectweb.asm.ByteVector
                        public static class: java.lang.Class<any>
                    }
                    class ClassReader {
                        public static SKIP_CODE: int
                        public static SKIP_DEBUG: int
                        public static SKIP_FRAMES: int
                        public static EXPAND_FRAMES: int
                        public b: byte[]
                        public header: int
                        public constructor(arg0: byte[])
                        public constructor(arg0: byte[], arg1: int, arg2: int)
                        public getAccess(): int
                        public getClassName(): string
                        public getSuperName(): string
                        public getInterfaces(): java.lang.String[]
                        public constructor(arg0: java.io.InputStream)
                        public constructor(arg0: java.lang.String | string)
                        public accept(arg0: jdk.internal.org.objectweb.asm.ClassVisitor, arg1: int): void
                        public accept(arg0: jdk.internal.org.objectweb.asm.ClassVisitor, arg1: jdk.internal.org.objectweb.asm.Attribute[], arg2: int): void
                        protected readLabel(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label[]): jdk.internal.org.objectweb.asm.Label
                        public getItemCount(): int
                        public getItem(arg0: int): int
                        public getMaxStringLength(): int
                        public readByte(arg0: int): int
                        public readUnsignedShort(arg0: int): int
                        public readShort(arg0: int): short
                        public readInt(arg0: int): int
                        public readLong(arg0: int): long
                        public readUTF8(arg0: int, arg1: char[]): string
                        public readClass(arg0: int, arg1: char[]): string
                        public readConst(arg0: int, arg1: char[]): java.lang.Object
                        public static class: java.lang.Class<any>
                    }
                    abstract class ClassVisitor {
                        protected api: int
                        protected cv: jdk.internal.org.objectweb.asm.ClassVisitor
                        public constructor(arg0: int)
                        public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.ClassVisitor)
                        public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                        public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                        public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                        public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                        public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    class ClassWriter extends jdk.internal.org.objectweb.asm.ClassVisitor {
                        public static COMPUTE_MAXS: int
                        public static COMPUTE_FRAMES: int
                        public constructor(arg0: int)
                        public constructor(arg0: jdk.internal.org.objectweb.asm.ClassReader, arg1: int)
                        public visit(arg0: int, arg1: int, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String[]): void
                        public visitSource(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public visitOuterClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                        public visitInnerClass(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int): void
                        public visitField(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.Object): jdk.internal.org.objectweb.asm.FieldVisitor
                        public visitMethod(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String[]): jdk.internal.org.objectweb.asm.MethodVisitor
                        public visitEnd(): void
                        public toByteArray(): byte[]
                        public newConst(arg0: java.lang.Object): int
                        public newUTF8(arg0: java.lang.String | string): int
                        public newClass(arg0: java.lang.String | string): int
                        public newMethodType(arg0: java.lang.String | string): int
                        public newHandle(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): int
                        public newInvokeDynamic(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): int
                        public newField(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): int
                        public newMethod(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: boolean): int
                        public newNameType(arg0: java.lang.String | string, arg1: java.lang.String | string): int
                        protected getCommonSuperClass(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                        public static class: java.lang.Class<any>
                    }
                    class Context {
                        public static class: java.lang.Class<any>
                    }
                    class Edge {
                        public static class: java.lang.Class<any>
                    }
                    abstract class FieldVisitor {
                        protected api: int
                        protected fv: jdk.internal.org.objectweb.asm.FieldVisitor
                        public constructor(arg0: int)
                        public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.FieldVisitor)
                        public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    class FieldWriter extends jdk.internal.org.objectweb.asm.FieldVisitor {
                        public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    class Frame {
                        public static class: java.lang.Class<any>
                    }
                    class Handle {
                        public constructor(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string)
                        public getTag(): int
                        public getOwner(): string
                        public getName(): string
                        public getDesc(): string
                        public equals(arg0: java.lang.Object): boolean
                        public hashCode(): int
                        public toString(): string
                        public static class: java.lang.Class<any>
                    }
                    class Handler {
                        public static class: java.lang.Class<any>
                    }
                    class Item {
                        public static class: java.lang.Class<any>
                    }
                    class Label {
                        public info: java.lang.Object
                        public constructor()
                        public getOffset(): int
                        public toString(): string
                        public static class: java.lang.Class<any>
                    }
                    abstract class MethodVisitor {
                        protected api: int
                        protected mv: jdk.internal.org.objectweb.asm.MethodVisitor
                        public constructor(arg0: int)
                        public constructor(arg0: int, arg1: jdk.internal.org.objectweb.asm.MethodVisitor)
                        public visitParameter(arg0: java.lang.String | string, arg1: int): void
                        public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                        public visitCode(): void
                        public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                        public visitInsn(arg0: int): void
                        public visitIntInsn(arg0: int, arg1: int): void
                        public visitVarInsn(arg0: int, arg1: int): void
                        public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                        public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                        public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                        public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                        public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                        public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                        public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                        public visitLdcInsn(arg0: java.lang.Object): void
                        public visitIincInsn(arg0: int, arg1: int): void
                        public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                        public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                        public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                        public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                        public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                        public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                        public visitMaxs(arg0: int, arg1: int): void
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    class MethodWriter extends jdk.internal.org.objectweb.asm.MethodVisitor {
                        public visitParameter(arg0: java.lang.String | string, arg1: int): void
                        public visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAnnotation(arg0: java.lang.String | string, arg1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTypeAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitParameterAnnotation(arg0: int, arg1: java.lang.String | string, arg2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitAttribute(arg0: jdk.internal.org.objectweb.asm.Attribute): void
                        public visitCode(): void
                        public visitFrame(arg0: int, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: java.lang.Object[]): void
                        public visitInsn(arg0: int): void
                        public visitIntInsn(arg0: int, arg1: int): void
                        public visitVarInsn(arg0: int, arg1: int): void
                        public visitTypeInsn(arg0: int, arg1: java.lang.String | string): void
                        public visitFieldInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                        public visitMethodInsn(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: boolean): void
                        public visitInvokeDynamicInsn(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: jdk.internal.org.objectweb.asm.Handle, ...arg3: java.lang.Object[]): void
                        public visitJumpInsn(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                        public visitLabel(arg0: jdk.internal.org.objectweb.asm.Label): void
                        public visitLdcInsn(arg0: java.lang.Object): void
                        public visitIincInsn(arg0: int, arg1: int): void
                        public visitTableSwitchInsn(arg0: int, arg1: int, arg2: jdk.internal.org.objectweb.asm.Label, ...arg3: jdk.internal.org.objectweb.asm.Label[]): void
                        public visitLookupSwitchInsn(arg0: jdk.internal.org.objectweb.asm.Label, arg1: int[], arg2: jdk.internal.org.objectweb.asm.Label[]): void
                        public visitMultiANewArrayInsn(arg0: java.lang.String | string, arg1: int): void
                        public visitInsnAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitTryCatchBlock(arg0: jdk.internal.org.objectweb.asm.Label, arg1: jdk.internal.org.objectweb.asm.Label, arg2: jdk.internal.org.objectweb.asm.Label, arg3: java.lang.String | string): void
                        public visitTryCatchAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: java.lang.String | string, arg3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitLocalVariable(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.objectweb.asm.Label, arg4: jdk.internal.org.objectweb.asm.Label, arg5: int): void
                        public visitLocalVariableAnnotation(arg0: int, arg1: jdk.internal.org.objectweb.asm.TypePath, arg2: jdk.internal.org.objectweb.asm.Label[], arg3: jdk.internal.org.objectweb.asm.Label[], arg4: int[], arg5: java.lang.String | string, arg6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor
                        public visitLineNumber(arg0: int, arg1: jdk.internal.org.objectweb.asm.Label): void
                        public visitMaxs(arg0: int, arg1: int): void
                        public visitEnd(): void
                        public static class: java.lang.Class<any>
                    }
                    interface Opcodes {
                        ASM4: int
                        ASM5: int
                        V1_1: int
                        V1_2: int
                        V1_3: int
                        V1_4: int
                        V1_5: int
                        V1_6: int
                        V1_7: int
                        V1_8: int
                        ACC_PUBLIC: int
                        ACC_PRIVATE: int
                        ACC_PROTECTED: int
                        ACC_STATIC: int
                        ACC_FINAL: int
                        ACC_SUPER: int
                        ACC_SYNCHRONIZED: int
                        ACC_VOLATILE: int
                        ACC_BRIDGE: int
                        ACC_VARARGS: int
                        ACC_TRANSIENT: int
                        ACC_NATIVE: int
                        ACC_INTERFACE: int
                        ACC_ABSTRACT: int
                        ACC_STRICT: int
                        ACC_SYNTHETIC: int
                        ACC_ANNOTATION: int
                        ACC_ENUM: int
                        ACC_MANDATED: int
                        ACC_DEPRECATED: int
                        T_BOOLEAN: int
                        T_CHAR: int
                        T_FLOAT: int
                        T_DOUBLE: int
                        T_BYTE: int
                        T_SHORT: int
                        T_INT: int
                        T_LONG: int
                        H_GETFIELD: int
                        H_GETSTATIC: int
                        H_PUTFIELD: int
                        H_PUTSTATIC: int
                        H_INVOKEVIRTUAL: int
                        H_INVOKESTATIC: int
                        H_INVOKESPECIAL: int
                        H_NEWINVOKESPECIAL: int
                        H_INVOKEINTERFACE: int
                        F_NEW: int
                        F_FULL: int
                        F_APPEND: int
                        F_CHOP: int
                        F_SAME: int
                        F_SAME1: int
                        TOP: java.lang.Integer
                        INTEGER: java.lang.Integer
                        FLOAT: java.lang.Integer
                        DOUBLE: java.lang.Integer
                        LONG: java.lang.Integer
                        NULL: java.lang.Integer
                        UNINITIALIZED_THIS: java.lang.Integer
                        NOP: int
                        ACONST_NULL: int
                        ICONST_M1: int
                        ICONST_0: int
                        ICONST_1: int
                        ICONST_2: int
                        ICONST_3: int
                        ICONST_4: int
                        ICONST_5: int
                        LCONST_0: int
                        LCONST_1: int
                        FCONST_0: int
                        FCONST_1: int
                        FCONST_2: int
                        DCONST_0: int
                        DCONST_1: int
                        BIPUSH: int
                        SIPUSH: int
                        LDC: int
                        ILOAD: int
                        LLOAD: int
                        FLOAD: int
                        DLOAD: int
                        ALOAD: int
                        IALOAD: int
                        LALOAD: int
                        FALOAD: int
                        DALOAD: int
                        AALOAD: int
                        BALOAD: int
                        CALOAD: int
                        SALOAD: int
                        ISTORE: int
                        LSTORE: int
                        FSTORE: int
                        DSTORE: int
                        ASTORE: int
                        IASTORE: int
                        LASTORE: int
                        FASTORE: int
                        DASTORE: int
                        AASTORE: int
                        BASTORE: int
                        CASTORE: int
                        SASTORE: int
                        POP: int
                        POP2: int
                        DUP: int
                        DUP_X1: int
                        DUP_X2: int
                        DUP2: int
                        DUP2_X1: int
                        DUP2_X2: int
                        SWAP: int
                        IADD: int
                        LADD: int
                        FADD: int
                        DADD: int
                        ISUB: int
                        LSUB: int
                        FSUB: int
                        DSUB: int
                        IMUL: int
                        LMUL: int
                        FMUL: int
                        DMUL: int
                        IDIV: int
                        LDIV: int
                        FDIV: int
                        DDIV: int
                        IREM: int
                        LREM: int
                        FREM: int
                        DREM: int
                        INEG: int
                        LNEG: int
                        FNEG: int
                        DNEG: int
                        ISHL: int
                        LSHL: int
                        ISHR: int
                        LSHR: int
                        IUSHR: int
                        LUSHR: int
                        IAND: int
                        LAND: int
                        IOR: int
                        LOR: int
                        IXOR: int
                        LXOR: int
                        IINC: int
                        I2L: int
                        I2F: int
                        I2D: int
                        L2I: int
                        L2F: int
                        L2D: int
                        F2I: int
                        F2L: int
                        F2D: int
                        D2I: int
                        D2L: int
                        D2F: int
                        I2B: int
                        I2C: int
                        I2S: int
                        LCMP: int
                        FCMPL: int
                        FCMPG: int
                        DCMPL: int
                        DCMPG: int
                        IFEQ: int
                        IFNE: int
                        IFLT: int
                        IFGE: int
                        IFGT: int
                        IFLE: int
                        IF_ICMPEQ: int
                        IF_ICMPNE: int
                        IF_ICMPLT: int
                        IF_ICMPGE: int
                        IF_ICMPGT: int
                        IF_ICMPLE: int
                        IF_ACMPEQ: int
                        IF_ACMPNE: int
                        GOTO: int
                        JSR: int
                        RET: int
                        TABLESWITCH: int
                        LOOKUPSWITCH: int
                        IRETURN: int
                        LRETURN: int
                        FRETURN: int
                        DRETURN: int
                        ARETURN: int
                        RETURN: int
                        GETSTATIC: int
                        PUTSTATIC: int
                        GETFIELD: int
                        PUTFIELD: int
                        INVOKEVIRTUAL: int
                        INVOKESPECIAL: int
                        INVOKESTATIC: int
                        INVOKEINTERFACE: int
                        INVOKEDYNAMIC: int
                        NEW: int
                        NEWARRAY: int
                        ANEWARRAY: int
                        ARRAYLENGTH: int
                        ATHROW: int
                        CHECKCAST: int
                        INSTANCEOF: int
                        MONITORENTER: int
                        MONITOREXIT: int
                        MULTIANEWARRAY: int
                        IFNULL: int
                        IFNONNULL: int
                    }
                    class Type {
                        public static VOID: int
                        public static BOOLEAN: int
                        public static CHAR: int
                        public static BYTE: int
                        public static SHORT: int
                        public static INT: int
                        public static FLOAT: int
                        public static LONG: int
                        public static DOUBLE: int
                        public static ARRAY: int
                        public static OBJECT: int
                        public static METHOD: int
                        public static VOID_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static BOOLEAN_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static CHAR_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static BYTE_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static SHORT_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static INT_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static FLOAT_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static LONG_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static DOUBLE_TYPE: jdk.internal.org.objectweb.asm.Type
                        public static getType(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.Type
                        public static getObjectType(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.Type
                        public static getMethodType(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.Type
                        public static getMethodType(arg0: jdk.internal.org.objectweb.asm.Type, ...arg1: jdk.internal.org.objectweb.asm.Type[]): jdk.internal.org.objectweb.asm.Type
                        public static getType(arg0: java.lang.Class<any>): jdk.internal.org.objectweb.asm.Type
                        public static getType(arg0: java.lang.reflect.Constructor<any>): jdk.internal.org.objectweb.asm.Type
                        public static getType(arg0: java.lang.reflect.Method): jdk.internal.org.objectweb.asm.Type
                        public static getArgumentTypes(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.Type[]
                        public static getArgumentTypes(arg0: java.lang.reflect.Method): jdk.internal.org.objectweb.asm.Type[]
                        public static getReturnType(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.Type
                        public static getReturnType(arg0: java.lang.reflect.Method): jdk.internal.org.objectweb.asm.Type
                        public static getArgumentsAndReturnSizes(arg0: java.lang.String | string): int
                        public getSort(): int
                        public getDimensions(): int
                        public getElementType(): jdk.internal.org.objectweb.asm.Type
                        public getClassName(): string
                        public getInternalName(): string
                        public getArgumentTypes(): jdk.internal.org.objectweb.asm.Type[]
                        public getReturnType(): jdk.internal.org.objectweb.asm.Type
                        public getArgumentsAndReturnSizes(): int
                        public getDescriptor(): string
                        public static getMethodDescriptor(arg0: jdk.internal.org.objectweb.asm.Type, ...arg1: jdk.internal.org.objectweb.asm.Type[]): string
                        public static getInternalName(arg0: java.lang.Class<any>): string
                        public static getDescriptor(arg0: java.lang.Class<any>): string
                        public static getConstructorDescriptor(arg0: java.lang.reflect.Constructor<any>): string
                        public static getMethodDescriptor(arg0: java.lang.reflect.Method): string
                        public getSize(): int
                        public getOpcode(arg0: int): int
                        public equals(arg0: java.lang.Object): boolean
                        public hashCode(): int
                        public toString(): string
                        public static class: java.lang.Class<any>
                    }
                    class TypePath {
                        public static ARRAY_ELEMENT: int
                        public static INNER_TYPE: int
                        public static WILDCARD_BOUND: int
                        public static TYPE_ARGUMENT: int
                        public getLength(): int
                        public getStep(arg0: int): int
                        public getStepArgument(arg0: int): int
                        public static fromString(arg0: java.lang.String | string): jdk.internal.org.objectweb.asm.TypePath
                        public toString(): string
                        public static class: java.lang.Class<any>
                    }
                    class TypeReference {
                        public static CLASS_TYPE_PARAMETER: int
                        public static METHOD_TYPE_PARAMETER: int
                        public static CLASS_EXTENDS: int
                        public static CLASS_TYPE_PARAMETER_BOUND: int
                        public static METHOD_TYPE_PARAMETER_BOUND: int
                        public static FIELD: int
                        public static METHOD_RETURN: int
                        public static METHOD_RECEIVER: int
                        public static METHOD_FORMAL_PARAMETER: int
                        public static THROWS: int
                        public static LOCAL_VARIABLE: int
                        public static RESOURCE_VARIABLE: int
                        public static EXCEPTION_PARAMETER: int
                        public static INSTANCEOF: int
                        public static NEW: int
                        public static CONSTRUCTOR_REFERENCE: int
                        public static METHOD_REFERENCE: int
                        public static CAST: int
                        public static CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: int
                        public static METHOD_INVOCATION_TYPE_ARGUMENT: int
                        public static CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: int
                        public static METHOD_REFERENCE_TYPE_ARGUMENT: int
                        public constructor(arg0: int)
                        public static newTypeReference(arg0: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newTypeParameterReference(arg0: int, arg1: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newTypeParameterBoundReference(arg0: int, arg1: int, arg2: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newSuperTypeReference(arg0: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newFormalParameterReference(arg0: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newExceptionReference(arg0: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newTryCatchReference(arg0: int): jdk.internal.org.objectweb.asm.TypeReference
                        public static newTypeArgumentReference(arg0: int, arg1: int): jdk.internal.org.objectweb.asm.TypeReference
                        public getSort(): int
                        public getTypeParameterIndex(): int
                        public getTypeParameterBoundIndex(): int
                        public getSuperTypeIndex(): int
                        public getFormalParameterIndex(): int
                        public getExceptionIndex(): int
                        public getTryCatchBlockIndex(): int
                        public getTypeArgumentIndex(): int
                        public getValue(): int
                        public static class: java.lang.Class<any>
                    }
                }
            }
            namespace xml {
                namespace sax {
                    namespace helpers {
                        class DefaultHandler implements jdk.internal.org.xml.sax.EntityResolver , jdk.internal.org.xml.sax.DTDHandler , jdk.internal.org.xml.sax.ContentHandler , jdk.internal.org.xml.sax.ErrorHandler {
                            public constructor()
                            public resolveEntity(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.xml.sax.InputSource
                            public notationDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public unparsedEntityDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                            public setDocumentLocator(arg0: jdk.internal.org.xml.sax.Locator): void
                            public startDocument(): void
                            public endDocument(): void
                            public startPrefixMapping(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public endPrefixMapping(arg0: java.lang.String | string): void
                            public startElement(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.xml.sax.Attributes): void
                            public endElement(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                            public characters(arg0: char[], arg1: int, arg2: int): void
                            public ignorableWhitespace(arg0: char[], arg1: int, arg2: int): void
                            public processingInstruction(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                            public skippedEntity(arg0: java.lang.String | string): void
                            public warning(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                            public error(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                            public fatalError(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                            public static class: java.lang.Class<any>
                        }
                    }
                    interface Attributes {
                        getLength(): int
                        getURI(arg0: int): string
                        getLocalName(arg0: int): string
                        getQName(arg0: int): string
                        getType(arg0: int): string
                        getValue(arg0: int): string
                        getIndex(arg0: java.lang.String | string, arg1: java.lang.String | string): int
                        getIndex(arg0: java.lang.String | string): int
                        getType(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                        getType(arg0: java.lang.String | string): string
                        getValue(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                        getValue(arg0: java.lang.String | string): string
                    }
                    interface ContentHandler {
                        setDocumentLocator(arg0: jdk.internal.org.xml.sax.Locator): void
                        startDocument(): void
                        endDocument(): void
                        startPrefixMapping(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        endPrefixMapping(arg0: java.lang.String | string): void
                        startElement(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.xml.sax.Attributes): void
                        endElement(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        characters(arg0: char[], arg1: int, arg2: int): void
                        ignorableWhitespace(arg0: char[], arg1: int, arg2: int): void
                        processingInstruction(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        skippedEntity(arg0: java.lang.String | string): void
                    }
                    interface DTDHandler {
                        notationDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        unparsedEntityDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                    }
                    interface EntityResolver {
                        resolveEntity(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.xml.sax.InputSource
                    }
                    interface EntityResolver$$Lambda {
                        (arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.xml.sax.InputSource
                    }
                    interface ErrorHandler {
                        warning(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                        error(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                        fatalError(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                    }
                    class InputSource {
                        public constructor()
                        public constructor(arg0: java.lang.String | string)
                        public constructor(arg0: java.io.InputStream)
                        public constructor(arg0: java.io.Reader)
                        public setPublicId(arg0: java.lang.String | string): void
                        public getPublicId(): string
                        public setSystemId(arg0: java.lang.String | string): void
                        public getSystemId(): string
                        public setByteStream(arg0: java.io.InputStream): void
                        public getByteStream(): java.io.InputStream
                        public setEncoding(arg0: java.lang.String | string): void
                        public getEncoding(): string
                        public setCharacterStream(arg0: java.io.Reader): void
                        public getCharacterStream(): java.io.Reader
                        public static class: java.lang.Class<any>
                    }
                    interface Locator {
                        getPublicId(): string
                        getSystemId(): string
                        getLineNumber(): int
                        getColumnNumber(): int
                    }
                    class SAXException extends java.lang.Exception {
                        public constructor()
                        public constructor(arg0: java.lang.String | string)
                        public constructor(arg0: java.lang.Exception)
                        public constructor(arg0: java.lang.String | string, arg1: java.lang.Exception)
                        public getMessage(): string
                        public getException(): java.lang.Exception
                        public getCause(): java.lang.Throwable
                        public toString(): string
                        public static class: java.lang.Class<any>
                    }
                    class SAXNotRecognizedException extends jdk.internal.org.xml.sax.SAXException {
                        public constructor()
                        public constructor(arg0: java.lang.String | string)
                        public static class: java.lang.Class<any>
                    }
                    class SAXNotSupportedException extends jdk.internal.org.xml.sax.SAXException {
                        public constructor()
                        public constructor(arg0: java.lang.String | string)
                        public static class: java.lang.Class<any>
                    }
                    class SAXParseException extends jdk.internal.org.xml.sax.SAXException {
                        public constructor(arg0: java.lang.String | string, arg1: jdk.internal.org.xml.sax.Locator)
                        public constructor(arg0: java.lang.String | string, arg1: jdk.internal.org.xml.sax.Locator, arg2: java.lang.Exception)
                        public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int, arg4: int)
                        public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: int, arg4: int, arg5: java.lang.Exception)
                        public getPublicId(): string
                        public getSystemId(): string
                        public getLineNumber(): int
                        public getColumnNumber(): int
                        public toString(): string
                        public static class: java.lang.Class<any>
                    }
                    interface XMLReader {
                        getFeature(arg0: java.lang.String | string): boolean
                        setFeature(arg0: java.lang.String | string, arg1: boolean): void
                        getProperty(arg0: java.lang.String | string): java.lang.Object
                        setProperty(arg0: java.lang.String | string, arg1: java.lang.Object): void
                        setEntityResolver(arg0: jdk.internal.org.xml.sax.EntityResolver | jdk.internal.org.xml.sax.EntityResolver$$Lambda): void
                        getEntityResolver(): jdk.internal.org.xml.sax.EntityResolver
                        setDTDHandler(arg0: jdk.internal.org.xml.sax.DTDHandler): void
                        getDTDHandler(): jdk.internal.org.xml.sax.DTDHandler
                        setContentHandler(arg0: jdk.internal.org.xml.sax.ContentHandler): void
                        getContentHandler(): jdk.internal.org.xml.sax.ContentHandler
                        setErrorHandler(arg0: jdk.internal.org.xml.sax.ErrorHandler): void
                        getErrorHandler(): jdk.internal.org.xml.sax.ErrorHandler
                        parse(arg0: jdk.internal.org.xml.sax.InputSource): void
                        parse(arg0: java.lang.String | string): void
                    }
                }
            }
        }
        namespace util {
            namespace xml {
                namespace impl {
                    class Attrs implements jdk.internal.org.xml.sax.Attributes {
                        public constructor()
                        public setLength(arg0: char): void
                        public getLength(): int
                        public getURI(arg0: int): string
                        public getLocalName(arg0: int): string
                        public getQName(arg0: int): string
                        public getType(arg0: int): string
                        public getValue(arg0: int): string
                        public getIndex(arg0: java.lang.String | string, arg1: java.lang.String | string): int
                        public getIndex(arg0: java.lang.String | string): int
                        public getType(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                        public getType(arg0: java.lang.String | string): string
                        public getValue(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                        public getValue(arg0: java.lang.String | string): string
                        public isDeclared(arg0: int): boolean
                        public isDeclared(arg0: java.lang.String | string): boolean
                        public isDeclared(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
                        public isSpecified(arg0: int): boolean
                        public isSpecified(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
                        public isSpecified(arg0: java.lang.String | string): boolean
                        public static class: java.lang.Class<any>
                    }
                    class Input {
                        public pubid: string
                        public sysid: string
                        public xmlenc: string
                        public xmlver: char
                        public src: java.io.Reader
                        public chars: char[]
                        public chLen: int
                        public chIdx: int
                        public next: jdk.internal.util.xml.impl.Input
                        public constructor(arg0: int)
                        public constructor(arg0: char[])
                        public constructor()
                        public static class: java.lang.Class<any>
                    }
                    class Pair {
                        public name: string
                        public value: string
                        public num: int
                        public chars: char[]
                        public id: int
                        public list: jdk.internal.util.xml.impl.Pair
                        public next: jdk.internal.util.xml.impl.Pair
                        public constructor()
                        public qname(): string
                        public local(): string
                        public pref(): string
                        public eqpref(arg0: char[]): boolean
                        public eqname(arg0: char[]): boolean
                        public static class: java.lang.Class<any>
                    }
                    abstract class Parser {
                        public static FAULT: string
                        protected static BUFFSIZE_READER: int
                        protected static BUFFSIZE_PARSER: int
                        public static EOS: char
                        protected mIsSAlone: boolean
                        protected mIsSAloneSet: boolean
                        protected mIsNSAware: boolean
                        protected mPh: int
                        protected static PH_BEFORE_DOC: int
                        protected static PH_DOC_START: int
                        protected static PH_MISC_DTD: int
                        protected static PH_DTD: int
                        protected static PH_DTD_MISC: int
                        protected static PH_DOCELM: int
                        protected static PH_DOCELM_MISC: int
                        protected static PH_AFTER_DOC: int
                        protected mEvt: int
                        protected static EV_NULL: int
                        protected static EV_ELM: int
                        protected static EV_ELMS: int
                        protected static EV_ELME: int
                        protected static EV_TEXT: int
                        protected static EV_WSPC: int
                        protected static EV_PI: int
                        protected static EV_CDAT: int
                        protected static EV_COMM: int
                        protected static EV_DTD: int
                        protected static EV_ENT: int
                        protected mBuff: char[]
                        protected mBuffIdx: int
                        protected mPref: jdk.internal.util.xml.impl.Pair
                        protected mElm: jdk.internal.util.xml.impl.Pair
                        protected mAttL: jdk.internal.util.xml.impl.Pair
                        protected mDoc: jdk.internal.util.xml.impl.Input
                        protected mInp: jdk.internal.util.xml.impl.Input
                        protected mAttrs: jdk.internal.util.xml.impl.Attrs
                        protected constructor()
                        protected init(): void
                        protected cleanup(): void
                        protected step(): int
                        protected name(arg0: boolean): string
                        protected qname(arg0: boolean): char[]
                        protected eqstr(arg0: char): string
                        protected wsskip(): char
                        protected docType(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        protected comm(arg0: char[], arg1: int): void
                        protected pi(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        protected newPrefix(): void
                        protected skippedEnt(arg0: java.lang.String | string): void
                        protected resolveEnt(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): jdk.internal.org.xml.sax.InputSource
                        protected notDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        protected unparsedEntDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                        protected panic(arg0: java.lang.String | string): void
                        protected bflash(): void
                        protected bflash_ws(): void
                        protected setinp(arg0: jdk.internal.org.xml.sax.InputSource): void
                        protected push(arg0: jdk.internal.util.xml.impl.Input): void
                        protected pop(): void
                        protected chtyp(arg0: char): char
                        protected getch(): char
                        protected bkch(): void
                        protected setch(arg0: char): void
                        protected find(arg0: jdk.internal.util.xml.impl.Pair, arg1: char[]): jdk.internal.util.xml.impl.Pair
                        protected pair(arg0: jdk.internal.util.xml.impl.Pair): jdk.internal.util.xml.impl.Pair
                        protected del(arg0: jdk.internal.util.xml.impl.Pair): jdk.internal.util.xml.impl.Pair
                        public static class: java.lang.Class<any>
                    }
                    class ParserSAX extends jdk.internal.util.xml.impl.Parser implements jdk.internal.org.xml.sax.XMLReader , jdk.internal.org.xml.sax.Locator {
                        public static FEATURE_NS: string
                        public static FEATURE_PREF: string
                        public constructor()
                        public getContentHandler(): jdk.internal.org.xml.sax.ContentHandler
                        public setContentHandler(arg0: jdk.internal.org.xml.sax.ContentHandler): void
                        public getDTDHandler(): jdk.internal.org.xml.sax.DTDHandler
                        public setDTDHandler(arg0: jdk.internal.org.xml.sax.DTDHandler): void
                        public getErrorHandler(): jdk.internal.org.xml.sax.ErrorHandler
                        public setErrorHandler(arg0: jdk.internal.org.xml.sax.ErrorHandler): void
                        public getEntityResolver(): jdk.internal.org.xml.sax.EntityResolver
                        public setEntityResolver(arg0: jdk.internal.org.xml.sax.EntityResolver | jdk.internal.org.xml.sax.EntityResolver$$Lambda): void
                        public getPublicId(): string
                        public getSystemId(): string
                        public getLineNumber(): int
                        public getColumnNumber(): int
                        public parse(arg0: java.lang.String | string): void
                        public parse(arg0: jdk.internal.org.xml.sax.InputSource): void
                        public parse(arg0: java.io.InputStream, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                        public parse(arg0: jdk.internal.org.xml.sax.InputSource, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                        protected docType(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        protected comm(arg0: char[], arg1: int): void
                        protected pi(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        protected newPrefix(): void
                        protected skippedEnt(arg0: java.lang.String | string): void
                        protected resolveEnt(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): jdk.internal.org.xml.sax.InputSource
                        protected notDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        protected unparsedEntDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                        protected panic(arg0: java.lang.String | string): void
                        protected bflash(): void
                        protected bflash_ws(): void
                        public getFeature(arg0: java.lang.String | string): boolean
                        public setFeature(arg0: java.lang.String | string, arg1: boolean): void
                        public getProperty(arg0: java.lang.String | string): java.lang.Object
                        public setProperty(arg0: java.lang.String | string, arg1: java.lang.Object): void
                        public static class: java.lang.Class<any>
                    }
                    class ReaderUTF16 extends java.io.Reader {
                        public constructor(arg0: java.io.InputStream, arg1: char)
                        public read(arg0: char[], arg1: int, arg2: int): int
                        public read(): int
                        public close(): void
                        public static class: java.lang.Class<any>
                    }
                    class ReaderUTF8 extends java.io.Reader {
                        public constructor(arg0: java.io.InputStream)
                        public read(arg0: char[], arg1: int, arg2: int): int
                        public read(): int
                        public close(): void
                        public static class: java.lang.Class<any>
                    }
                    class SAXParserImpl extends jdk.internal.util.xml.SAXParser {
                        public constructor()
                        public getXMLReader(): jdk.internal.org.xml.sax.XMLReader
                        public isNamespaceAware(): boolean
                        public isValidating(): boolean
                        public parse(arg0: java.io.InputStream, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                        public parse(arg0: jdk.internal.org.xml.sax.InputSource, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                        public static class: java.lang.Class<any>
                    }
                    class XMLStreamWriterImpl implements jdk.internal.util.xml.XMLStreamWriter {
                        public static CLOSE_START_TAG: char
                        public static OPEN_START_TAG: char
                        public static OPEN_END_TAG: string
                        public static CLOSE_END_TAG: char
                        public static START_CDATA: string
                        public static END_CDATA: string
                        public static CLOSE_EMPTY_ELEMENT: string
                        public static ENCODING_PREFIX: string
                        public static SPACE: char
                        public static AMPERSAND: char
                        public static DOUBLEQUOT: char
                        public static SEMICOLON: char
                        public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda)
                        public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string)
                        public writeStartDocument(): void
                        public writeStartDocument(arg0: java.lang.String | string): void
                        public writeStartDocument(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public writeStartDocument(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        public writeDTD(arg0: java.lang.String | string): void
                        public writeStartElement(arg0: java.lang.String | string): void
                        public writeEmptyElement(arg0: java.lang.String | string): void
                        public writeAttribute(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public writeEndDocument(): void
                        public writeEndElement(): void
                        public writeCData(arg0: java.lang.String | string): void
                        public writeCharacters(arg0: java.lang.String | string): void
                        public writeCharacters(arg0: char[], arg1: int, arg2: int): void
                        public close(): void
                        public flush(): void
                        public setDoIndent(arg0: boolean): void
                        public static class: java.lang.Class<any>
                    }
                    class XMLWriter {
                        public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.String | string, arg2: java.nio.charset.Charset)
                        public canEncode(arg0: char): boolean
                        public write(arg0: java.lang.String | string): void
                        public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
                        public write(arg0: char[], arg1: int, arg2: int): void
                        public static class: java.lang.Class<any>
                    }
                }
                class PropertiesDefaultHandler extends jdk.internal.org.xml.sax.helpers.DefaultHandler {
                    public constructor()
                    public load(arg0: java.util.Properties, arg1: java.io.InputStream): void
                    public store(arg0: java.util.Properties, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda, arg2: java.lang.String | string, arg3: java.lang.String | string): void
                    public startElement(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: jdk.internal.org.xml.sax.Attributes): void
                    public characters(arg0: char[], arg1: int, arg2: int): void
                    public endElement(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                    public notationDecl(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                    public resolveEntity(arg0: java.lang.String | string, arg1: java.lang.String | string): jdk.internal.org.xml.sax.InputSource
                    public error(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                    public fatalError(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                    public warning(arg0: jdk.internal.org.xml.sax.SAXParseException): void
                    public static class: java.lang.Class<any>
                }
                abstract class SAXParser {
                    protected constructor()
                    public parse(arg0: java.io.InputStream, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                    public parse(arg0: java.lang.String | string, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                    public parse(arg0: java.io.File, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                    public parse(arg0: jdk.internal.org.xml.sax.InputSource, arg1: jdk.internal.org.xml.sax.helpers.DefaultHandler): void
                    public getXMLReader(): jdk.internal.org.xml.sax.XMLReader
                    public isNamespaceAware(): boolean
                    public isValidating(): boolean
                    public isXIncludeAware(): boolean
                    public static class: java.lang.Class<any>
                }
                class XMLStreamException extends java.lang.Exception {
                    protected nested: java.lang.Throwable
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.Throwable)
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                    public getNestedException(): java.lang.Throwable
                    public static class: java.lang.Class<any>
                }
                interface XMLStreamWriter {
                    DEFAULT_XML_VERSION: string
                    DEFAULT_ENCODING: string
                    writeStartElement(arg0: java.lang.String | string): void
                    writeEmptyElement(arg0: java.lang.String | string): void
                    writeEndElement(): void
                    writeEndDocument(): void
                    close(): void
                    flush(): void
                    writeAttribute(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                    writeCData(arg0: java.lang.String | string): void
                    writeDTD(arg0: java.lang.String | string): void
                    writeStartDocument(): void
                    writeStartDocument(arg0: java.lang.String | string): void
                    writeStartDocument(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                    writeCharacters(arg0: java.lang.String | string): void
                    writeCharacters(arg0: char[], arg1: int, arg2: int): void
                }
            }
        }
    }
}
declare namespace sun {
    namespace invoke {
        namespace empty {
            class Empty {
                public static class: java.lang.Class<any>
            }
        }
        namespace util {
            class BytecodeDescriptor {
                public static parseMethod(arg0: java.lang.String | string, arg1: java.lang.ClassLoader): java.util.List<java.lang.Class<any>>
                public static unparse(arg0: java.lang.Class<any>): string
                public static unparse(arg0: java.lang.invoke.MethodType): string
                public static unparse(arg0: java.lang.Object): string
                public static unparseMethod(arg0: java.lang.Class<any>, arg1: java.util.List<java.lang.Class<any>>): string
                public static class: java.lang.Class<any>
            }
            class BytecodeName {
                public static toBytecodeName(arg0: java.lang.String | string): string
                public static toSourceName(arg0: java.lang.String | string): string
                public static parseBytecodeName(arg0: java.lang.String | string): java.lang.Object[]
                public static unparseBytecodeName(arg0: java.lang.Object[]): string
                public static toDisplayName(arg0: java.lang.String | string): string
                public static isSafeBytecodeName(arg0: java.lang.String | string): boolean
                public static isSafeBytecodeChar(arg0: char): boolean
                public static class: java.lang.Class<any>
            }
            class ValueConversions {
                public constructor()
                public static unboxExact(arg0: sun.invoke.util.Wrapper): java.lang.invoke.MethodHandle
                public static unboxExact(arg0: sun.invoke.util.Wrapper, arg1: boolean): java.lang.invoke.MethodHandle
                public static unboxWiden(arg0: sun.invoke.util.Wrapper): java.lang.invoke.MethodHandle
                public static unboxCast(arg0: sun.invoke.util.Wrapper): java.lang.invoke.MethodHandle
                public static primitiveConversion(arg0: sun.invoke.util.Wrapper, arg1: java.lang.Object, arg2: boolean): java.lang.Number
                public static widenSubword(arg0: java.lang.Object): int
                public static boxExact(arg0: sun.invoke.util.Wrapper): java.lang.invoke.MethodHandle
                public static zeroConstantFunction(arg0: sun.invoke.util.Wrapper): java.lang.invoke.MethodHandle
                public static ignore(): java.lang.invoke.MethodHandle
                public static cast(): java.lang.invoke.MethodHandle
                public static convertPrimitive(arg0: sun.invoke.util.Wrapper, arg1: sun.invoke.util.Wrapper): java.lang.invoke.MethodHandle
                public static convertPrimitive(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): java.lang.invoke.MethodHandle
                public static class: java.lang.Class<any>
            }
            class VerifyAccess {
                public static isMemberAccessible(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>, arg2: int, arg3: java.lang.Class<any>, arg4: int): boolean
                public static isClassAccessible(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>, arg2: int): boolean
                public static isTypeVisible(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): boolean
                public static isTypeVisible(arg0: java.lang.invoke.MethodType, arg1: java.lang.Class<any>): boolean
                public static isSamePackage(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): boolean
                public static getPackageName(arg0: java.lang.Class<any>): string
                public static isSamePackageMember(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): boolean
                public static classLoaderIsAncestor(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): boolean
                public static class: java.lang.Class<any>
            }
            class VerifyType {
                public static isNullConversion(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>, arg2: boolean): boolean
                public static isNullReferenceConversion(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): boolean
                public static isNullType(arg0: java.lang.Class<any>): boolean
                public static isNullConversion(arg0: java.lang.invoke.MethodType, arg1: java.lang.invoke.MethodType, arg2: boolean): boolean
                public static canPassUnchecked(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>): int
                public static isSpreadArgType(arg0: java.lang.Class<any>): boolean
                public static spreadArgElementType(arg0: java.lang.Class<any>, arg1: int): java.lang.Class<any>
                public static class: java.lang.Class<any>
            }
            class Wrapper extends java.lang.Enum<sun.invoke.util.Wrapper> {
                public static BOOLEAN: sun.invoke.util.Wrapper
                public static BYTE: sun.invoke.util.Wrapper
                public static SHORT: sun.invoke.util.Wrapper
                public static CHAR: sun.invoke.util.Wrapper
                public static INT: sun.invoke.util.Wrapper
                public static LONG: sun.invoke.util.Wrapper
                public static FLOAT: sun.invoke.util.Wrapper
                public static DOUBLE: sun.invoke.util.Wrapper
                public static OBJECT: sun.invoke.util.Wrapper
                public static VOID: sun.invoke.util.Wrapper
                public static values(): sun.invoke.util.Wrapper[]
                public static valueOf(arg0: java.lang.String | string): sun.invoke.util.Wrapper
                public detailString(): string
                public bitWidth(): int
                public stackSlots(): int
                public isSingleWord(): boolean
                public isDoubleWord(): boolean
                public isNumeric(): boolean
                public isIntegral(): boolean
                public isSubwordOrInt(): boolean
                public isSigned(): boolean
                public isUnsigned(): boolean
                public isFloating(): boolean
                public isOther(): boolean
                public isConvertibleFrom(arg0: sun.invoke.util.Wrapper): boolean
                public zero(): java.lang.Object
                public zero<T>(arg0: java.lang.Class<T>): T
                public static forPrimitiveType<T>(arg0: java.lang.Class<any>): sun.invoke.util.Wrapper
                public static forWrapperType<T>(arg0: java.lang.Class<any>): sun.invoke.util.Wrapper
                public static forBasicType<T>(arg0: char): sun.invoke.util.Wrapper
                public static forBasicType<T>(arg0: java.lang.Class<any>): sun.invoke.util.Wrapper
                public primitiveType<T>(): java.lang.Class<any>
                public wrapperType<T>(): java.lang.Class<any>
                public wrapperType<T>(arg0: java.lang.Class<T>): java.lang.Class<T>
                public static asWrapperType<T>(arg0: java.lang.Class<T>): java.lang.Class<T>
                public static asPrimitiveType<T>(arg0: java.lang.Class<T>): java.lang.Class<T>
                public static isWrapperType<T>(arg0: java.lang.Class<any>): boolean
                public static isPrimitiveType<T>(arg0: java.lang.Class<any>): boolean
                public static basicTypeChar<T>(arg0: java.lang.Class<any>): char
                public basicTypeChar<T>(): char
                public wrapperSimpleName<T>(): string
                public primitiveSimpleName<T>(): string
                public cast<T>(arg0: java.lang.Object, arg1: java.lang.Class<T>): T
                public convert<T>(arg0: java.lang.Object, arg1: java.lang.Class<T>): T
                public wrap<T>(arg0: java.lang.Object): java.lang.Object
                public wrap<T>(arg0: int): java.lang.Object
                public makeArray<T>(arg0: int): java.lang.Object
                public arrayType<T>(): java.lang.Class<any>
                public copyArrayUnboxing<T>(arg0: java.lang.Object[], arg1: int, arg2: java.lang.Object, arg3: int, arg4: int): void
                public copyArrayBoxing<T>(arg0: java.lang.Object, arg1: int, arg2: java.lang.Object[], arg3: int, arg4: int): void
                public static class: java.lang.Class<any>
            }
        }
        interface WrapperInstance {
            getWrapperInstanceTarget(): java.lang.invoke.MethodHandle
            getWrapperInstanceType(): java.lang.Class<any>
        }
    }
    namespace launcher {
        class LauncherHelper extends java.lang.Enum<sun.launcher.LauncherHelper> {
            public static INSTANCE: sun.launcher.LauncherHelper
            public static values(): sun.launcher.LauncherHelper[]
            public static valueOf(arg0: java.lang.String | string): sun.launcher.LauncherHelper
            public static checkAndLoadMain(arg0: boolean, arg1: int, arg2: java.lang.String | string): java.lang.Class<any>
            public static getApplicationClass(): java.lang.Class<any>
            public static class: java.lang.Class<any>
        }
    }
    namespace net {
        namespace dns {
            abstract class ResolverConfiguration {
                protected constructor()
                public static open(): sun.net.dns.ResolverConfiguration
                public searchlist(): java.util.List<java.lang.String>
                public nameservers(): java.util.List<java.lang.String>
                public options(): sun.net.dns.ResolverConfiguration$Options
                public static class: java.lang.Class<any>
            }
        }
        namespace ftp {
            namespace impl {
                class DefaultFtpClientProvider extends sun.net.ftp.FtpClientProvider {
                    public constructor()
                    public createFtpClient(): sun.net.ftp.FtpClient
                    public static class: java.lang.Class<any>
                }
                class FtpClient extends sun.net.ftp.FtpClient {
                    protected constructor()
                    public static create(): sun.net.ftp.FtpClient
                    public enablePassiveMode(arg0: boolean): sun.net.ftp.FtpClient
                    public isPassiveModeEnabled(): boolean
                    public setConnectTimeout(arg0: int): sun.net.ftp.FtpClient
                    public getConnectTimeout(): int
                    public setReadTimeout(arg0: int): sun.net.ftp.FtpClient
                    public getReadTimeout(): int
                    public setProxy(arg0: java.net.Proxy): sun.net.ftp.FtpClient
                    public getProxy(): java.net.Proxy
                    public isConnected(): boolean
                    public getServerAddress(): java.net.SocketAddress
                    public connect(arg0: java.net.SocketAddress): sun.net.ftp.FtpClient
                    public connect(arg0: java.net.SocketAddress, arg1: int): sun.net.ftp.FtpClient
                    public login(arg0: java.lang.String | string, arg1: char[]): sun.net.ftp.FtpClient
                    public login(arg0: java.lang.String | string, arg1: char[], arg2: java.lang.String | string): sun.net.ftp.FtpClient
                    public close(): void
                    public isLoggedIn(): boolean
                    public changeDirectory(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                    public changeToParentDirectory(): sun.net.ftp.FtpClient
                    public getWorkingDirectory(): string
                    public setRestartOffset(arg0: long): sun.net.ftp.FtpClient
                    public getFile(arg0: java.lang.String | string, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda): sun.net.ftp.FtpClient
                    public getFileStream(arg0: java.lang.String | string): java.io.InputStream
                    public putFileStream(arg0: java.lang.String | string, arg1: boolean): java.io.OutputStream
                    public putFile(arg0: java.lang.String | string, arg1: java.io.InputStream, arg2: boolean): sun.net.ftp.FtpClient
                    public appendFile(arg0: java.lang.String | string, arg1: java.io.InputStream): sun.net.ftp.FtpClient
                    public rename(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.net.ftp.FtpClient
                    public deleteFile(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                    public makeDirectory(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                    public removeDirectory(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                    public noop(): sun.net.ftp.FtpClient
                    public getStatus(arg0: java.lang.String | string): string
                    public getFeatures(): java.util.List<java.lang.String>
                    public abort(): sun.net.ftp.FtpClient
                    public completePending(): sun.net.ftp.FtpClient
                    public reInit(): sun.net.ftp.FtpClient
                    public setType(arg0: sun.net.ftp.FtpClient$TransferType): sun.net.ftp.FtpClient
                    public list(arg0: java.lang.String | string): java.io.InputStream
                    public nameList(arg0: java.lang.String | string): java.io.InputStream
                    public getSize(arg0: java.lang.String | string): long
                    public getLastModified(arg0: java.lang.String | string): java.util.Date
                    public setDirParser(arg0: sun.net.ftp.FtpDirParser | sun.net.ftp.FtpDirParser$$Lambda): sun.net.ftp.FtpClient
                    public listFiles(arg0: java.lang.String | string): java.util.Iterator<sun.net.ftp.FtpDirEntry>
                    public useKerberos(): sun.net.ftp.FtpClient
                    public getWelcomeMsg(): string
                    public getLastReplyCode(): sun.net.ftp.FtpReplyCode
                    public getLastResponseString(): string
                    public getLastTransferSize(): long
                    public getLastFileName(): string
                    public startSecureSession(): sun.net.ftp.FtpClient
                    public endSecureSession(): sun.net.ftp.FtpClient
                    public allocate(arg0: long): sun.net.ftp.FtpClient
                    public structureMount(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                    public getSystem(): string
                    public getHelp(arg0: java.lang.String | string): string
                    public siteCmd(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                    public static class: java.lang.Class<any>
                }
            }
            abstract class FtpClient implements java.io.Closeable {
                public static defaultPort(): int
                protected constructor()
                public static create(): sun.net.ftp.FtpClient
                public static create(arg0: java.net.InetSocketAddress): sun.net.ftp.FtpClient
                public static create(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public enablePassiveMode(arg0: boolean): sun.net.ftp.FtpClient
                public isPassiveModeEnabled(): boolean
                public setConnectTimeout(arg0: int): sun.net.ftp.FtpClient
                public getConnectTimeout(): int
                public setReadTimeout(arg0: int): sun.net.ftp.FtpClient
                public getReadTimeout(): int
                public setProxy(arg0: java.net.Proxy): sun.net.ftp.FtpClient
                public getProxy(): java.net.Proxy
                public isConnected(): boolean
                public connect(arg0: java.net.SocketAddress): sun.net.ftp.FtpClient
                public connect(arg0: java.net.SocketAddress, arg1: int): sun.net.ftp.FtpClient
                public getServerAddress(): java.net.SocketAddress
                public login(arg0: java.lang.String | string, arg1: char[]): sun.net.ftp.FtpClient
                public login(arg0: java.lang.String | string, arg1: char[], arg2: java.lang.String | string): sun.net.ftp.FtpClient
                public close(): void
                public isLoggedIn(): boolean
                public changeDirectory(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public changeToParentDirectory(): sun.net.ftp.FtpClient
                public getWorkingDirectory(): string
                public setRestartOffset(arg0: long): sun.net.ftp.FtpClient
                public getFile(arg0: java.lang.String | string, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda): sun.net.ftp.FtpClient
                public getFileStream(arg0: java.lang.String | string): java.io.InputStream
                public putFileStream(arg0: java.lang.String | string): java.io.OutputStream
                public putFileStream(arg0: java.lang.String | string, arg1: boolean): java.io.OutputStream
                public putFile(arg0: java.lang.String | string, arg1: java.io.InputStream): sun.net.ftp.FtpClient
                public putFile(arg0: java.lang.String | string, arg1: java.io.InputStream, arg2: boolean): sun.net.ftp.FtpClient
                public appendFile(arg0: java.lang.String | string, arg1: java.io.InputStream): sun.net.ftp.FtpClient
                public rename(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.net.ftp.FtpClient
                public deleteFile(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public makeDirectory(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public removeDirectory(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public noop(): sun.net.ftp.FtpClient
                public getStatus(arg0: java.lang.String | string): string
                public getFeatures(): java.util.List<java.lang.String>
                public abort(): sun.net.ftp.FtpClient
                public completePending(): sun.net.ftp.FtpClient
                public reInit(): sun.net.ftp.FtpClient
                public setType(arg0: sun.net.ftp.FtpClient$TransferType): sun.net.ftp.FtpClient
                public setBinaryType(): sun.net.ftp.FtpClient
                public setAsciiType(): sun.net.ftp.FtpClient
                public list(arg0: java.lang.String | string): java.io.InputStream
                public nameList(arg0: java.lang.String | string): java.io.InputStream
                public getSize(arg0: java.lang.String | string): long
                public getLastModified(arg0: java.lang.String | string): java.util.Date
                public setDirParser(arg0: sun.net.ftp.FtpDirParser | sun.net.ftp.FtpDirParser$$Lambda): sun.net.ftp.FtpClient
                public listFiles(arg0: java.lang.String | string): java.util.Iterator<sun.net.ftp.FtpDirEntry>
                public useKerberos(): sun.net.ftp.FtpClient
                public getWelcomeMsg(): string
                public getLastReplyCode(): sun.net.ftp.FtpReplyCode
                public getLastResponseString(): string
                public getLastTransferSize(): long
                public getLastFileName(): string
                public startSecureSession(): sun.net.ftp.FtpClient
                public endSecureSession(): sun.net.ftp.FtpClient
                public allocate(arg0: long): sun.net.ftp.FtpClient
                public structureMount(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public getSystem(): string
                public getHelp(arg0: java.lang.String | string): string
                public siteCmd(arg0: java.lang.String | string): sun.net.ftp.FtpClient
                public static class: java.lang.Class<any>
            }
            abstract class FtpClientProvider {
                public createFtpClient(): sun.net.ftp.FtpClient
                protected constructor()
                public static provider(): sun.net.ftp.FtpClientProvider
                public static class: java.lang.Class<any>
            }
            class FtpDirEntry {
                public constructor(arg0: java.lang.String | string)
                public getName(): string
                public getUser(): string
                public setUser(arg0: java.lang.String | string): sun.net.ftp.FtpDirEntry
                public getGroup(): string
                public setGroup(arg0: java.lang.String | string): sun.net.ftp.FtpDirEntry
                public getSize(): long
                public setSize(arg0: long): sun.net.ftp.FtpDirEntry
                public getType(): sun.net.ftp.FtpDirEntry$Type
                public setType(arg0: sun.net.ftp.FtpDirEntry$Type): sun.net.ftp.FtpDirEntry
                public getLastModified(): java.util.Date
                public setLastModified(arg0: java.util.Date): sun.net.ftp.FtpDirEntry
                public canRead(arg0: sun.net.ftp.FtpDirEntry$Permission): boolean
                public canWrite(arg0: sun.net.ftp.FtpDirEntry$Permission): boolean
                public canExexcute(arg0: sun.net.ftp.FtpDirEntry$Permission): boolean
                public setPermissions(arg0: boolean[][]): sun.net.ftp.FtpDirEntry
                public addFact(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.net.ftp.FtpDirEntry
                public getFact(arg0: java.lang.String | string): string
                public getCreated(): java.util.Date
                public setCreated(arg0: java.util.Date): sun.net.ftp.FtpDirEntry
                public toString(): string
                public static class: java.lang.Class<any>
            }
            interface FtpDirParser {
                parseLine(arg0: java.lang.String | string): sun.net.ftp.FtpDirEntry
            }
            interface FtpDirParser$$Lambda {
                (arg0: java.lang.String | string): sun.net.ftp.FtpDirEntry
            }
            class FtpLoginException extends java.io.IOException {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class FtpProtocolException extends java.lang.Exception {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: sun.net.ftp.FtpReplyCode)
                public getReplyCode(): sun.net.ftp.FtpReplyCode
                public static class: java.lang.Class<any>
            }
            class FtpReplyCode extends java.lang.Enum<sun.net.ftp.FtpReplyCode> {
                public static RESTART_MARKER: sun.net.ftp.FtpReplyCode
                public static SERVICE_READY_IN: sun.net.ftp.FtpReplyCode
                public static DATA_CONNECTION_ALREADY_OPEN: sun.net.ftp.FtpReplyCode
                public static FILE_STATUS_OK: sun.net.ftp.FtpReplyCode
                public static COMMAND_OK: sun.net.ftp.FtpReplyCode
                public static NOT_IMPLEMENTED: sun.net.ftp.FtpReplyCode
                public static SYSTEM_STATUS: sun.net.ftp.FtpReplyCode
                public static DIRECTORY_STATUS: sun.net.ftp.FtpReplyCode
                public static FILE_STATUS: sun.net.ftp.FtpReplyCode
                public static HELP_MESSAGE: sun.net.ftp.FtpReplyCode
                public static NAME_SYSTEM_TYPE: sun.net.ftp.FtpReplyCode
                public static SERVICE_READY: sun.net.ftp.FtpReplyCode
                public static SERVICE_CLOSING: sun.net.ftp.FtpReplyCode
                public static DATA_CONNECTION_OPEN: sun.net.ftp.FtpReplyCode
                public static CLOSING_DATA_CONNECTION: sun.net.ftp.FtpReplyCode
                public static ENTERING_PASSIVE_MODE: sun.net.ftp.FtpReplyCode
                public static ENTERING_EXT_PASSIVE_MODE: sun.net.ftp.FtpReplyCode
                public static LOGGED_IN: sun.net.ftp.FtpReplyCode
                public static SECURELY_LOGGED_IN: sun.net.ftp.FtpReplyCode
                public static SECURITY_EXCHANGE_OK: sun.net.ftp.FtpReplyCode
                public static SECURITY_EXCHANGE_COMPLETE: sun.net.ftp.FtpReplyCode
                public static FILE_ACTION_OK: sun.net.ftp.FtpReplyCode
                public static PATHNAME_CREATED: sun.net.ftp.FtpReplyCode
                public static NEED_PASSWORD: sun.net.ftp.FtpReplyCode
                public static NEED_ACCOUNT: sun.net.ftp.FtpReplyCode
                public static NEED_ADAT: sun.net.ftp.FtpReplyCode
                public static NEED_MORE_ADAT: sun.net.ftp.FtpReplyCode
                public static FILE_ACTION_PENDING: sun.net.ftp.FtpReplyCode
                public static SERVICE_NOT_AVAILABLE: sun.net.ftp.FtpReplyCode
                public static CANT_OPEN_DATA_CONNECTION: sun.net.ftp.FtpReplyCode
                public static CONNECTION_CLOSED: sun.net.ftp.FtpReplyCode
                public static NEED_SECURITY_RESOURCE: sun.net.ftp.FtpReplyCode
                public static FILE_ACTION_NOT_TAKEN: sun.net.ftp.FtpReplyCode
                public static ACTION_ABORTED: sun.net.ftp.FtpReplyCode
                public static INSUFFICIENT_STORAGE: sun.net.ftp.FtpReplyCode
                public static COMMAND_UNRECOGNIZED: sun.net.ftp.FtpReplyCode
                public static INVALID_PARAMETER: sun.net.ftp.FtpReplyCode
                public static BAD_SEQUENCE: sun.net.ftp.FtpReplyCode
                public static NOT_IMPLEMENTED_FOR_PARAMETER: sun.net.ftp.FtpReplyCode
                public static NOT_LOGGED_IN: sun.net.ftp.FtpReplyCode
                public static NEED_ACCOUNT_FOR_STORING: sun.net.ftp.FtpReplyCode
                public static PROT_LEVEL_DENIED: sun.net.ftp.FtpReplyCode
                public static REQUEST_DENIED: sun.net.ftp.FtpReplyCode
                public static FAILED_SECURITY_CHECK: sun.net.ftp.FtpReplyCode
                public static UNSUPPORTED_PROT_LEVEL: sun.net.ftp.FtpReplyCode
                public static PROT_LEVEL_NOT_SUPPORTED_BY_SECURITY: sun.net.ftp.FtpReplyCode
                public static FILE_UNAVAILABLE: sun.net.ftp.FtpReplyCode
                public static PAGE_TYPE_UNKNOWN: sun.net.ftp.FtpReplyCode
                public static EXCEEDED_STORAGE: sun.net.ftp.FtpReplyCode
                public static FILE_NAME_NOT_ALLOWED: sun.net.ftp.FtpReplyCode
                public static PROTECTED_REPLY: sun.net.ftp.FtpReplyCode
                public static UNKNOWN_ERROR: sun.net.ftp.FtpReplyCode
                public static values(): sun.net.ftp.FtpReplyCode[]
                public static valueOf(arg0: java.lang.String | string): sun.net.ftp.FtpReplyCode
                public getValue(): int
                public isPositivePreliminary(): boolean
                public isPositiveCompletion(): boolean
                public isPositiveIntermediate(): boolean
                public isTransientNegative(): boolean
                public isPermanentNegative(): boolean
                public isProtectedReply(): boolean
                public isSyntax(): boolean
                public isInformation(): boolean
                public isConnection(): boolean
                public isAuthentication(): boolean
                public isUnspecified(): boolean
                public isFileSystem(): boolean
                public static find(arg0: int): sun.net.ftp.FtpReplyCode
                public static class: java.lang.Class<any>
            }
        }
        namespace idn {
            class Punycode {
                public constructor()
                public static encode(arg0: java.lang.StringBuffer, arg1: boolean[]): java.lang.StringBuffer
                public static decode(arg0: java.lang.StringBuffer, arg1: boolean[]): java.lang.StringBuffer
                public static class: java.lang.Class<any>
            }
            class StringPrep {
                public static DEFAULT: int
                public static ALLOW_UNASSIGNED: int
                public constructor(arg0: java.io.InputStream)
                public prepare(arg0: sun.text.normalizer.UCharacterIterator, arg1: int): java.lang.StringBuffer
                public static class: java.lang.Class<any>
            }
            class StringPrepDataReader implements sun.text.normalizer.ICUBinary$Authenticate {
                public constructor(arg0: java.io.InputStream)
                public read(arg0: byte[], arg1: char[]): void
                public getDataFormatVersion(): byte[]
                public isDataVersionAcceptable(arg0: byte[]): boolean
                public readIndexes(arg0: int): int[]
                public getUnicodeVersion(): byte[]
                public static class: java.lang.Class<any>
            }
            class UCharacterDirection implements sun.net.idn.UCharacterEnums$ECharacterDirection {
                public static toString(arg0: int): string
                public static class: java.lang.Class<any>
            }
            class UCharacterEnums {
                public static class: java.lang.Class<any>
            }
        }
        namespace sdp {
            class SdpSupport {
                public static createSocket(): java.io.FileDescriptor
                public static convertSocket(arg0: java.io.FileDescriptor): void
                public static class: java.lang.Class<any>
            }
        }
        namespace smtp {
            class SmtpClient extends sun.net.TransferProtocolClient {
                public closeServer(): void
                public to(arg0: java.lang.String | string): void
                public from(arg0: java.lang.String | string): void
                public startMessage(): java.io.PrintStream
                public constructor(arg0: java.lang.String | string)
                public constructor()
                public constructor(arg0: int)
                public getMailHost(): string
                public static class: java.lang.Class<any>
            }
            class SmtpProtocolException extends java.io.IOException {
                public static class: java.lang.Class<any>
            }
        }
        namespace spi {
            class DefaultProxySelector extends java.net.ProxySelector {
                public constructor()
                public select(arg0: java.net.URI): java.util.List<java.net.Proxy>
                public connectFailed(arg0: java.net.URI, arg1: java.net.SocketAddress, arg2: java.io.IOException): void
                public static class: java.lang.Class<any>
            }
        }
        namespace util {
            class IPAddressUtil {
                public constructor()
                public static textToNumericFormatV4(arg0: java.lang.String | string): byte[]
                public static textToNumericFormatV6(arg0: java.lang.String | string): byte[]
                public static isIPv4LiteralAddress(arg0: java.lang.String | string): boolean
                public static isIPv6LiteralAddress(arg0: java.lang.String | string): boolean
                public static convertFromIPv4MappedAddress(arg0: byte[]): byte[]
                public static class: java.lang.Class<any>
            }
            class URLUtil {
                public constructor()
                public static urlNoFragString(arg0: java.net.URL): string
                public static getConnectPermission(arg0: java.net.URL): java.security.Permission
                public static class: java.lang.Class<any>
            }
        }
        namespace www {
            namespace content {
                namespace text {
                    class Generic extends sun.net.www.content.text.plain {
                        public constructor()
                        public static class: java.lang.Class<any>
                    }
                    class PlainTextInputStream extends java.io.FilterInputStream {
                        public static class: java.lang.Class<any>
                    }
                    class plain extends java.net.ContentHandler {
                        public constructor()
                        public getContent(arg0: java.net.URLConnection): java.lang.Object
                        public static class: java.lang.Class<any>
                    }
                }
            }
            namespace http {
                class ChunkedInputStream extends java.io.InputStream implements sun.net.www.http.Hurryable {
                    public constructor(arg0: java.io.InputStream, arg1: sun.net.www.http.HttpClient, arg2: sun.net.www.MessageHeader)
                    public read(): int
                    public read(arg0: byte[], arg1: int, arg2: int): int
                    public available(): int
                    public close(): void
                    public hurry(): boolean
                    public static class: java.lang.Class<any>
                }
                class ChunkedInputStream$$Lambda extends java.io.InputStream implements sun.net.www.http.Hurryable {
                    public constructor(arg0: java.io.InputStream, arg1: sun.net.www.http.HttpClient, arg2: sun.net.www.MessageHeader)
                }
                class ChunkedOutputStream extends java.io.PrintStream {
                    public constructor(arg0: java.io.PrintStream)
                    public constructor(arg0: java.io.PrintStream, arg1: int)
                    public checkError(): boolean
                    public write(arg0: byte[], arg1: int, arg2: int): void
                    public write(arg0: int): void
                    public reset(): void
                    public size(): int
                    public close(): void
                    public flush(): void
                    public static class: java.lang.Class<any>
                }
                class HttpCapture {
                    public sent(arg0: int): void
                    public received(arg0: int): void
                    public flush(): void
                    public static getCapture(arg0: java.net.URL): sun.net.www.http.HttpCapture
                    public static class: java.lang.Class<any>
                }
                class HttpCaptureInputStream extends java.io.FilterInputStream {
                    public constructor(arg0: java.io.InputStream, arg1: sun.net.www.http.HttpCapture)
                    public read(): int
                    public close(): void
                    public read(arg0: byte[]): int
                    public read(arg0: byte[], arg1: int, arg2: int): int
                    public static class: java.lang.Class<any>
                }
                class HttpCaptureOutputStream extends java.io.FilterOutputStream {
                    public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: sun.net.www.http.HttpCapture)
                    public write(arg0: int): void
                    public write(arg0: byte[]): void
                    public write(arg0: byte[], arg1: int, arg2: int): void
                    public flush(): void
                    public static class: java.lang.Class<any>
                }
                class HttpClient extends sun.net.NetworkClient {
                    protected cachedHttpClient: boolean
                    protected inCache: boolean
                    protected proxyDisabled: boolean
                    public usingProxy: boolean
                    protected host: string
                    protected port: int
                    protected static kac: sun.net.www.http.KeepAliveCache
                    protected url: java.net.URL
                    public reuse: boolean
                    protected getDefaultPort(): int
                    public static resetProperties(): void
                    public getHttpKeepAliveSet(): boolean
                    protected constructor()
                    protected constructor(arg0: java.net.URL, arg1: boolean)
                    public constructor(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int)
                    protected constructor(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int)
                    protected static newHttpProxy(arg0: java.lang.String | string, arg1: int, arg2: java.lang.String | string): java.net.Proxy
                    public constructor(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean, arg4: int)
                    public static New(arg0: java.net.URL): sun.net.www.http.HttpClient
                    public static New(arg0: java.net.URL, arg1: boolean): sun.net.www.http.HttpClient
                    public static New(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int, arg3: boolean, arg4: sun.net.www.protocol.http.HttpURLConnection): sun.net.www.http.HttpClient
                    public static New(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int, arg3: sun.net.www.protocol.http.HttpURLConnection): sun.net.www.http.HttpClient
                    public static New(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): sun.net.www.http.HttpClient
                    public static New(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean, arg4: int, arg5: sun.net.www.protocol.http.HttpURLConnection): sun.net.www.http.HttpClient
                    public finished(): void
                    protected available(): boolean
                    protected putInKeepAliveCache(): void
                    protected isInKeepAliveCache(): boolean
                    public closeIdleConnection(): void
                    public openServer(arg0: java.lang.String | string, arg1: int): void
                    public needsTunneling(): boolean
                    public isCachedConnection(): boolean
                    public afterConnect(): void
                    protected openServer(): void
                    public getURLFile(): string
                    public writeRequests(arg0: sun.net.www.MessageHeader): void
                    public writeRequests(arg0: sun.net.www.MessageHeader, arg1: sun.net.www.http.PosterOutputStream): void
                    public writeRequests(arg0: sun.net.www.MessageHeader, arg1: sun.net.www.http.PosterOutputStream, arg2: boolean): void
                    public parseHTTP(arg0: sun.net.www.MessageHeader, arg1: sun.net.ProgressSource, arg2: sun.net.www.protocol.http.HttpURLConnection): boolean
                    public getInputStream(): java.io.InputStream
                    public getOutputStream(): java.io.OutputStream
                    public toString(): string
                    public isKeepingAlive(): boolean
                    public setCacheRequest(arg0: java.net.CacheRequest): void
                    protected finalize(): void
                    public setDoNotRetry(arg0: boolean): void
                    public setIgnoreContinue(arg0: boolean): void
                    public closeServer(): void
                    public getProxyHostUsed(): string
                    public getProxyPortUsed(): int
                    public static class: java.lang.Class<any>
                }
                interface Hurryable {
                    hurry(): boolean
                }
                interface Hurryable$$Lambda {
                    (): boolean
                }
                class KeepAliveCache extends java.util.HashMap<sun.net.www.http.KeepAliveKey, sun.net.www.http.ClientVector> implements java.lang.Runnable {
                    public constructor()
                    public put(arg0: java.net.URL, arg1: java.lang.Object, arg2: sun.net.www.http.HttpClient): void
                    public remove(arg0: sun.net.www.http.HttpClient, arg1: java.lang.Object): void
                    public get(arg0: java.net.URL, arg1: java.lang.Object): sun.net.www.http.HttpClient
                    public run(): void
                    public static class: java.lang.Class<any>
                }
                class KeepAliveCache$$Lambda extends java.util.HashMap<sun.net.www.http.KeepAliveKey, sun.net.www.http.ClientVector> implements java.lang.Runnable {
                    public constructor()
                }
                class KeepAliveCleanerEntry {
                    public constructor(arg0: sun.net.www.http.KeepAliveStream | sun.net.www.http.KeepAliveStream$$Lambda, arg1: sun.net.www.http.HttpClient)
                    protected getKeepAliveStream(): sun.net.www.http.KeepAliveStream
                    protected getHttpClient(): sun.net.www.http.HttpClient
                    protected setQueuedForCleanup(): void
                    protected getQueuedForCleanup(): boolean
                    public static class: java.lang.Class<any>
                }
                class KeepAliveStream extends sun.net.www.MeteredStream implements sun.net.www.http.Hurryable {
                    protected queuedForCleanup: boolean
                    public constructor(arg0: java.io.InputStream, arg1: sun.net.ProgressSource, arg2: long, arg3: sun.net.www.http.HttpClient)
                    public close(): void
                    public markSupported(): boolean
                    public mark(arg0: int): void
                    public reset(): void
                    public hurry(): boolean
                    protected remainingToRead(): long
                    protected setClosed(): void
                    public static class: java.lang.Class<any>
                }
                class KeepAliveStream$$Lambda extends sun.net.www.MeteredStream implements sun.net.www.http.Hurryable {
                    protected queuedForCleanup: boolean
                }
                class KeepAliveStreamCleaner extends java.util.LinkedList<sun.net.www.http.KeepAliveCleanerEntry> implements java.lang.Runnable {
                    protected static MAX_DATA_REMAINING: int
                    protected static MAX_CAPACITY: int
                    protected static TIMEOUT: int
                    public offer(arg0: sun.net.www.http.KeepAliveCleanerEntry): boolean
                    public run(): void
                    public offer(arg0: java.lang.Object): boolean
                    public static class: java.lang.Class<any>
                }
                class KeepAliveStreamCleaner$$Lambda extends java.util.LinkedList<sun.net.www.http.KeepAliveCleanerEntry> implements java.lang.Runnable {
                    protected static MAX_DATA_REMAINING: int
                }
                class PosterOutputStream extends java.io.ByteArrayOutputStream {
                    public constructor()
                    public write(arg0: int): void
                    public write(arg0: byte[], arg1: int, arg2: int): void
                    public reset(): void
                    public close(): void
                    public static class: java.lang.Class<any>
                }
            }
            namespace protocol {
                namespace file {
                    class FileURLConnection extends sun.net.www.URLConnection {
                        protected constructor(arg0: java.net.URL, arg1: java.io.File)
                        public connect(): void
                        public getHeaderField(arg0: java.lang.String | string): string
                        public getHeaderField(arg0: int): string
                        public getContentLength(): int
                        public getContentLengthLong(): long
                        public getHeaderFieldKey(arg0: int): string
                        public getProperties(): sun.net.www.MessageHeader
                        public getLastModified(): long
                        public getInputStream(): java.io.InputStream
                        public getPermission(): java.security.Permission
                        public static class: java.lang.Class<any>
                    }
                }
                namespace ftp {
                    class FtpURLConnection extends sun.net.www.URLConnection {
                        public constructor(arg0: java.net.URL)
                        public connect(): void
                        public getInputStream(): java.io.InputStream
                        public getOutputStream(): java.io.OutputStream
                        public getPermission(): java.security.Permission
                        public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public getRequestProperty(arg0: java.lang.String | string): string
                        public setConnectTimeout(arg0: int): void
                        public getConnectTimeout(): int
                        public setReadTimeout(arg0: int): void
                        public getReadTimeout(): int
                        public static class: java.lang.Class<any>
                    }
                    class Handler extends java.net.URLStreamHandler {
                        public constructor()
                        protected getDefaultPort(): int
                        protected equals(arg0: java.net.URL, arg1: java.net.URL): boolean
                        protected openConnection(arg0: java.net.URL): java.net.URLConnection
                        protected openConnection(arg0: java.net.URL, arg1: java.net.Proxy): java.net.URLConnection
                        public static class: java.lang.Class<any>
                    }
                }
                namespace http {
                    namespace ntlm {
                        abstract class NTLMAuthenticationCallback {
                            public constructor()
                            public static setNTLMAuthenticationCallback(arg0: sun.net.www.protocol.http.ntlm.NTLMAuthenticationCallback): void
                            public static getNTLMAuthenticationCallback(): sun.net.www.protocol.http.ntlm.NTLMAuthenticationCallback
                            public isTrustedSite(arg0: java.net.URL): boolean
                            public static class: java.lang.Class<any>
                        }
                    }
                    interface AuthCache {
                        put(arg0: java.lang.String | string, arg1: sun.net.www.protocol.http.AuthCacheValue): void
                        get(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.net.www.protocol.http.AuthCacheValue
                        remove(arg0: java.lang.String | string, arg1: sun.net.www.protocol.http.AuthCacheValue): void
                    }
                    class AuthCacheImpl implements sun.net.www.protocol.http.AuthCache {
                        public constructor()
                        public setMap(arg0: java.util.HashMap<java.lang.String, java.util.LinkedList<sun.net.www.protocol.http.AuthCacheValue>>): void
                        public put(arg0: java.lang.String | string, arg1: sun.net.www.protocol.http.AuthCacheValue): void
                        public get(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.net.www.protocol.http.AuthCacheValue
                        public remove(arg0: java.lang.String | string, arg1: sun.net.www.protocol.http.AuthCacheValue): void
                        public static class: java.lang.Class<any>
                    }
                    abstract class AuthCacheValue implements java.io.Serializable {
                        protected static cache: sun.net.www.protocol.http.AuthCache
                        public static setAuthCache(arg0: sun.net.www.protocol.http.AuthCache): void
                        public static class: java.lang.Class<any>
                    }
                    class AuthScheme extends java.lang.Enum<sun.net.www.protocol.http.AuthScheme> {
                        public static BASIC: sun.net.www.protocol.http.AuthScheme
                        public static DIGEST: sun.net.www.protocol.http.AuthScheme
                        public static NTLM: sun.net.www.protocol.http.AuthScheme
                        public static NEGOTIATE: sun.net.www.protocol.http.AuthScheme
                        public static KERBEROS: sun.net.www.protocol.http.AuthScheme
                        public static UNKNOWN: sun.net.www.protocol.http.AuthScheme
                        public static values(): sun.net.www.protocol.http.AuthScheme[]
                        public static valueOf(arg0: java.lang.String | string): sun.net.www.protocol.http.AuthScheme
                        public static class: java.lang.Class<any>
                    }
                    class AuthenticationHeader {
                        public toString(): string
                        public constructor(arg0: java.lang.String | string, arg1: sun.net.www.MessageHeader, arg2: sun.net.www.protocol.http.HttpCallerInfo, arg3: boolean)
                        public constructor(arg0: java.lang.String | string, arg1: sun.net.www.MessageHeader, arg2: sun.net.www.protocol.http.HttpCallerInfo, arg3: boolean, arg4: java.util.Set<java.lang.String>)
                        public getHttpCallerInfo(): sun.net.www.protocol.http.HttpCallerInfo
                        public headerParser(): sun.net.www.HeaderParser
                        public scheme(): string
                        public raw(): string
                        public isPresent(): boolean
                        public static class: java.lang.Class<any>
                    }
                    abstract class AuthenticationInfo extends sun.net.www.protocol.http.AuthCacheValue implements java.lang.Cloneable {
                        public static SERVER_AUTHENTICATION: char
                        public static PROXY_AUTHENTICATION: char
                        protected pw: java.net.PasswordAuthentication
                        public credentials(): java.net.PasswordAuthentication
                        public getAuthType(): sun.net.www.protocol.http.AuthCacheValue$Type
                        public getHost(): string
                        public getPort(): int
                        public getRealm(): string
                        public getPath(): string
                        public getProtocolScheme(): string
                        protected useAuthCache(): boolean
                        public constructor(arg0: char, arg1: sun.net.www.protocol.http.AuthScheme, arg2: java.lang.String | string, arg3: int, arg4: java.lang.String | string)
                        public clone(): java.lang.Object
                        public constructor(arg0: char, arg1: sun.net.www.protocol.http.AuthScheme, arg2: java.net.URL, arg3: java.lang.String | string)
                        public supportsPreemptiveAuthorization(): boolean
                        public getHeaderName(): string
                        public getHeaderValue(arg0: java.net.URL, arg1: java.lang.String | string): string
                        public setHeaders(arg0: sun.net.www.protocol.http.HttpURLConnection, arg1: sun.net.www.HeaderParser, arg2: java.lang.String | string): boolean
                        public isAuthorizationStale(arg0: java.lang.String | string): boolean
                        public static class: java.lang.Class<any>
                    }
                    class BasicAuthentication extends sun.net.www.protocol.http.AuthenticationInfo {
                        public constructor(arg0: boolean, arg1: java.lang.String | string, arg2: int, arg3: java.lang.String | string, arg4: java.net.PasswordAuthentication)
                        public constructor(arg0: boolean, arg1: java.lang.String | string, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string)
                        public constructor(arg0: boolean, arg1: java.net.URL, arg2: java.lang.String | string, arg3: java.net.PasswordAuthentication)
                        public constructor(arg0: boolean, arg1: java.net.URL, arg2: java.lang.String | string, arg3: java.lang.String | string)
                        public supportsPreemptiveAuthorization(): boolean
                        public setHeaders(arg0: sun.net.www.protocol.http.HttpURLConnection, arg1: sun.net.www.HeaderParser, arg2: java.lang.String | string): boolean
                        public getHeaderValue(arg0: java.net.URL, arg1: java.lang.String | string): string
                        public isAuthorizationStale(arg0: java.lang.String | string): boolean
                        public static class: java.lang.Class<any>
                    }
                    class DigestAuthentication extends sun.net.www.protocol.http.AuthenticationInfo {
                        public constructor(arg0: boolean, arg1: java.net.URL, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.net.PasswordAuthentication, arg5: sun.net.www.protocol.http.DigestAuthentication$Parameters)
                        public constructor(arg0: boolean, arg1: java.lang.String | string, arg2: int, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.net.PasswordAuthentication, arg6: sun.net.www.protocol.http.DigestAuthentication$Parameters)
                        public supportsPreemptiveAuthorization(): boolean
                        public getHeaderValue(arg0: java.net.URL, arg1: java.lang.String | string): string
                        public isAuthorizationStale(arg0: java.lang.String | string): boolean
                        public setHeaders(arg0: sun.net.www.protocol.http.HttpURLConnection, arg1: sun.net.www.HeaderParser, arg2: java.lang.String | string): boolean
                        public checkResponse(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.net.URL): void
                        public checkResponse(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                        public static class: java.lang.Class<any>
                    }
                    class Handler extends java.net.URLStreamHandler {
                        protected proxy: string
                        protected proxyPort: int
                        protected getDefaultPort(): int
                        public constructor()
                        public constructor(arg0: java.lang.String | string, arg1: int)
                        protected openConnection(arg0: java.net.URL): java.net.URLConnection
                        protected openConnection(arg0: java.net.URL, arg1: java.net.Proxy): java.net.URLConnection
                        public static class: java.lang.Class<any>
                    }
                    interface HttpAuthenticator {
                        schemeSupported(arg0: java.lang.String | string): boolean
                        authString(arg0: java.net.URL, arg1: java.lang.String | string, arg2: java.lang.String | string): string
                    }
                    class HttpCallerInfo {
                        public url: java.net.URL
                        public host: string
                        public protocol: string
                        public prompt: string
                        public scheme: string
                        public port: int
                        public addr: java.net.InetAddress
                        public authType: java.net.Authenticator$RequestorType
                        public constructor(arg0: sun.net.www.protocol.http.HttpCallerInfo, arg1: java.lang.String | string)
                        public constructor(arg0: java.net.URL)
                        public constructor(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int)
                        public static class: java.lang.Class<any>
                    }
                    class HttpURLConnection extends java.net.HttpURLConnection {
                        public static userAgent: string
                        protected http: sun.net.www.http.HttpClient
                        protected handler: sun.net.www.protocol.http.Handler
                        protected instProxy: java.net.Proxy
                        protected cachedResponse: java.net.CacheResponse
                        protected ps: java.io.PrintStream
                        protected pi: sun.net.ProgressSource
                        public static getHttpLogger(): sun.util.logging.PlatformLogger
                        public authObj(): java.lang.Object
                        public authObj(arg0: java.lang.Object): void
                        public setRequestMethod(arg0: java.lang.String | string): void
                        protected setNewClient(arg0: java.net.URL): void
                        protected setNewClient(arg0: java.net.URL, arg1: boolean): void
                        protected setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int): void
                        protected setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): void
                        protected proxiedConnect(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): void
                        protected constructor(arg0: java.net.URL, arg1: sun.net.www.protocol.http.Handler)
                        public constructor(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int)
                        public constructor(arg0: java.net.URL, arg1: java.net.Proxy)
                        protected constructor(arg0: java.net.URL, arg1: java.net.Proxy, arg2: sun.net.www.protocol.http.Handler)
                        public static setDefaultAuthenticator(arg0: sun.net.www.protocol.http.HttpAuthenticator): void
                        public static openConnectionCheckRedirects(arg0: java.net.URLConnection): java.io.InputStream
                        public connect(): void
                        protected plainConnect(): void
                        protected plainConnect0(): void
                        protected getNewHttpClient(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int): sun.net.www.http.HttpClient
                        protected getNewHttpClient(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int, arg3: boolean): sun.net.www.http.HttpClient
                        public getOutputStream(): java.io.OutputStream
                        public streaming(): boolean
                        public getInputStream(): java.io.InputStream
                        public getErrorStream(): java.io.InputStream
                        public setTunnelState(arg0: sun.net.www.protocol.http.HttpURLConnection$TunnelState): void
                        public doTunneling(): void
                        public disconnect(): void
                        public usingProxy(): boolean
                        public getHeaderField(arg0: java.lang.String | string): string
                        public getHeaderFields(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                        public getHeaderField(arg0: int): string
                        public getHeaderFieldKey(arg0: int): string
                        public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public addRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public setAuthenticationProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public getRequestProperty(arg0: java.lang.String | string): string
                        public getRequestProperties(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                        public setConnectTimeout(arg0: int): void
                        public getConnectTimeout(): int
                        public setReadTimeout(arg0: int): void
                        public getReadTimeout(): int
                        public getCookieHandler(): java.net.CookieHandler
                        public static class: java.lang.Class<any>
                    }
                    class NTLMAuthenticationProxy {
                        public static isTrustedSite(arg0: java.net.URL): boolean
                        public static class: java.lang.Class<any>
                    }
                    class NegotiateAuthentication extends sun.net.www.protocol.http.AuthenticationInfo {
                        public constructor(arg0: sun.net.www.protocol.http.HttpCallerInfo)
                        public supportsPreemptiveAuthorization(): boolean
                        public static isSupported(arg0: sun.net.www.protocol.http.HttpCallerInfo): boolean
                        protected useAuthCache(): boolean
                        public getHeaderValue(arg0: java.net.URL, arg1: java.lang.String | string): string
                        public isAuthorizationStale(arg0: java.lang.String | string): boolean
                        public setHeaders(arg0: sun.net.www.protocol.http.HttpURLConnection, arg1: sun.net.www.HeaderParser, arg2: java.lang.String | string): boolean
                        public static class: java.lang.Class<any>
                    }
                    abstract class Negotiator {
                        public constructor()
                        public firstToken(): byte[]
                        public nextToken(arg0: byte[]): byte[]
                        public static class: java.lang.Class<any>
                    }
                }
                namespace https {
                    abstract class AbstractDelegateHttpsURLConnection extends sun.net.www.protocol.http.HttpURLConnection {
                        protected constructor(arg0: java.net.URL, arg1: sun.net.www.protocol.http.Handler)
                        protected constructor(arg0: java.net.URL, arg1: java.net.Proxy, arg2: sun.net.www.protocol.http.Handler)
                        protected getSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                        protected getHostnameVerifier(): javax.net.ssl.HostnameVerifier
                        public setNewClient(arg0: java.net.URL): void
                        public setNewClient(arg0: java.net.URL, arg1: boolean): void
                        public setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int): void
                        public setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): void
                        protected proxiedConnect(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): void
                        public isConnected(): boolean
                        public setConnected(arg0: boolean): void
                        public connect(): void
                        protected getNewHttpClient(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int): sun.net.www.http.HttpClient
                        protected getNewHttpClient(arg0: java.net.URL, arg1: java.net.Proxy, arg2: int, arg3: boolean): sun.net.www.http.HttpClient
                        public getCipherSuite(): string
                        public getLocalCertificates(): java.security.cert.Certificate[]
                        public getServerCertificates(): java.security.cert.Certificate[]
                        public getServerCertificateChain(): javax.security.cert.X509Certificate[]
                        public static class: java.lang.Class<any>
                    }
                    class DelegateHttpsURLConnection extends sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection {
                        public httpsURLConnection: javax.net.ssl.HttpsURLConnection
                        protected getSSLSocketFactory(): javax.net.ssl.SSLSocketFactory
                        protected getHostnameVerifier(): javax.net.ssl.HostnameVerifier
                        protected dispose(): void
                        public static class: java.lang.Class<any>
                    }
                    class Handler extends sun.net.www.protocol.http.Handler {
                        protected proxy: string
                        protected proxyPort: int
                        protected getDefaultPort(): int
                        public constructor()
                        public constructor(arg0: java.lang.String | string, arg1: int)
                        protected openConnection(arg0: java.net.URL): java.net.URLConnection
                        protected openConnection(arg0: java.net.URL, arg1: java.net.Proxy): java.net.URLConnection
                        public static class: java.lang.Class<any>
                    }
                    class HttpsClient extends sun.net.www.http.HttpClient implements javax.net.ssl.HandshakeCompletedListener {
                        protected getDefaultPort(): int
                        protected createSocket(): java.net.Socket
                        public needsTunneling(): boolean
                        public afterConnect(): void
                        protected putInKeepAliveCache(): void
                        public closeIdleConnection(): void
                        public getLocalCertificates(): java.security.cert.Certificate[]
                        public handshakeCompleted(arg0: javax.net.ssl.HandshakeCompletedEvent): void
                        public getProxyHostUsed(): string
                        public getProxyPortUsed(): int
                        public static class: java.lang.Class<any>
                    }
                    class HttpsURLConnectionImpl extends javax.net.ssl.HttpsURLConnection {
                        protected delegate: sun.net.www.protocol.https.DelegateHttpsURLConnection
                        protected constructor(arg0: java.net.URL)
                        protected setNewClient(arg0: java.net.URL): void
                        protected setNewClient(arg0: java.net.URL, arg1: boolean): void
                        protected setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int): void
                        protected setProxiedClient(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: boolean): void
                        public connect(): void
                        protected isConnected(): boolean
                        protected setConnected(arg0: boolean): void
                        public getCipherSuite(): string
                        public getLocalCertificates(): java.security.cert.Certificate[]
                        public getServerCertificates(): java.security.cert.Certificate[]
                        public getServerCertificateChain(): javax.security.cert.X509Certificate[]
                        public getPeerPrincipal(): java.security.Principal
                        public getLocalPrincipal(): java.security.Principal
                        public getOutputStream(): java.io.OutputStream
                        public getInputStream(): java.io.InputStream
                        public getErrorStream(): java.io.InputStream
                        public disconnect(): void
                        public usingProxy(): boolean
                        public getHeaderFields(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                        public getHeaderField(arg0: java.lang.String | string): string
                        public getHeaderField(arg0: int): string
                        public getHeaderFieldKey(arg0: int): string
                        public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public addRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public getResponseCode(): int
                        public getRequestProperty(arg0: java.lang.String | string): string
                        public getRequestProperties(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                        public setInstanceFollowRedirects(arg0: boolean): void
                        public getInstanceFollowRedirects(): boolean
                        public setRequestMethod(arg0: java.lang.String | string): void
                        public getRequestMethod(): string
                        public getResponseMessage(): string
                        public getHeaderFieldDate(arg0: java.lang.String | string, arg1: long): long
                        public getPermission(): java.security.Permission
                        public getURL(): java.net.URL
                        public getContentLength(): int
                        public getContentLengthLong(): long
                        public getContentType(): string
                        public getContentEncoding(): string
                        public getExpiration(): long
                        public getDate(): long
                        public getLastModified(): long
                        public getHeaderFieldInt(arg0: java.lang.String | string, arg1: int): int
                        public getHeaderFieldLong(arg0: java.lang.String | string, arg1: long): long
                        public getContent(): java.lang.Object
                        public getContent(arg0: java.lang.Class[]): java.lang.Object
                        public toString(): string
                        public setDoInput(arg0: boolean): void
                        public getDoInput(): boolean
                        public setDoOutput(arg0: boolean): void
                        public getDoOutput(): boolean
                        public setAllowUserInteraction(arg0: boolean): void
                        public getAllowUserInteraction(): boolean
                        public setUseCaches(arg0: boolean): void
                        public getUseCaches(): boolean
                        public setIfModifiedSince(arg0: long): void
                        public getIfModifiedSince(): long
                        public getDefaultUseCaches(): boolean
                        public setDefaultUseCaches(arg0: boolean): void
                        protected finalize(): void
                        public equals(arg0: java.lang.Object): boolean
                        public hashCode(): int
                        public setConnectTimeout(arg0: int): void
                        public getConnectTimeout(): int
                        public setReadTimeout(arg0: int): void
                        public getReadTimeout(): int
                        public setFixedLengthStreamingMode(arg0: int): void
                        public setFixedLengthStreamingMode(arg0: long): void
                        public setChunkedStreamingMode(arg0: int): void
                        public static class: java.lang.Class<any>
                    }
                }
                namespace jar {
                    class Handler extends java.net.URLStreamHandler {
                        public constructor()
                        protected openConnection(arg0: java.net.URL): java.net.URLConnection
                        protected sameFile(arg0: java.net.URL, arg1: java.net.URL): boolean
                        protected hashCode(arg0: java.net.URL): int
                        protected parseURL(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: int): void
                        public static class: java.lang.Class<any>
                    }
                    class JarURLConnection extends java.net.JarURLConnection {
                        public constructor(arg0: java.net.URL, arg1: sun.net.www.protocol.jar.Handler)
                        public getJarFile(): java.util.jar.JarFile
                        public getJarEntry(): java.util.jar.JarEntry
                        public getPermission(): java.security.Permission
                        public connect(): void
                        public getInputStream(): java.io.InputStream
                        public getContentLength(): int
                        public getContentLengthLong(): long
                        public getContent(): java.lang.Object
                        public getContentType(): string
                        public getHeaderField(arg0: java.lang.String | string): string
                        public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public getRequestProperty(arg0: java.lang.String | string): string
                        public addRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                        public getRequestProperties(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                        public setAllowUserInteraction(arg0: boolean): void
                        public getAllowUserInteraction(): boolean
                        public setUseCaches(arg0: boolean): void
                        public getUseCaches(): boolean
                        public setIfModifiedSince(arg0: long): void
                        public setDefaultUseCaches(arg0: boolean): void
                        public getDefaultUseCaches(): boolean
                        public static class: java.lang.Class<any>
                    }
                    class URLJarFile extends java.util.jar.JarFile {
                        public constructor(arg0: java.io.File)
                        public constructor(arg0: java.io.File, arg1: sun.net.www.protocol.jar.URLJarFile$URLJarFileCloseController)
                        protected finalize(): void
                        public getEntry(arg0: java.lang.String | string): java.util.zip.ZipEntry
                        public getManifest(): java.util.jar.Manifest
                        public close(): void
                        public static setCallBack(arg0: sun.net.www.protocol.jar.URLJarFileCallBack | sun.net.www.protocol.jar.URLJarFileCallBack$$Lambda): void
                        public static class: java.lang.Class<any>
                    }
                    interface URLJarFileCallBack {
                        retrieve(arg0: java.net.URL): java.util.jar.JarFile
                    }
                    interface URLJarFileCallBack$$Lambda {
                        (arg0: java.net.URL): java.util.jar.JarFile
                    }
                }
                namespace mailto {
                    class Handler extends java.net.URLStreamHandler {
                        public constructor()
                        public openConnection(arg0: java.net.URL): java.net.URLConnection
                        public parseURL(arg0: java.net.URL, arg1: java.lang.String | string, arg2: int, arg3: int): void
                        public static class: java.lang.Class<any>
                    }
                    class MailToURLConnection extends sun.net.www.URLConnection {
                        public connect(): void
                        public getOutputStream(): java.io.OutputStream
                        public getPermission(): java.security.Permission
                        public setConnectTimeout(arg0: int): void
                        public getConnectTimeout(): int
                        public setReadTimeout(arg0: int): void
                        public getReadTimeout(): int
                        public static class: java.lang.Class<any>
                    }
                }
            }
            class ApplicationLaunchException extends java.lang.Exception {
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class HeaderParser {
                public constructor(arg0: java.lang.String | string)
                public subsequence(arg0: int, arg1: int): sun.net.www.HeaderParser
                public findKey(arg0: int): string
                public findValue(arg0: int): string
                public findValue(arg0: java.lang.String | string): string
                public findValue(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                public keys(): java.util.Iterator<java.lang.String>
                public values(): java.util.Iterator<java.lang.String>
                public toString(): string
                public findInt(arg0: java.lang.String | string, arg1: int): int
                public static class: java.lang.Class<any>
            }
            class MessageHeader {
                public constructor()
                public constructor(arg0: java.io.InputStream)
                public getHeaderNamesInList(): string
                public reset(): void
                public findValue(arg0: java.lang.String | string): string
                public getKey(arg0: java.lang.String | string): int
                public getKey(arg0: int): string
                public getValue(arg0: int): string
                public findNextValue(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                public filterNTLMResponses(arg0: java.lang.String | string): boolean
                public multiValueIterator(arg0: java.lang.String | string): java.util.Iterator<java.lang.String>
                public getHeaders(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                public getHeaders(arg0: java.lang.String[]): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                public filterAndAddHeaders(arg0: java.lang.String[], arg1: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                public print(arg0: java.io.PrintStream): void
                public add(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public prepend(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public set(arg0: int, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                public remove(arg0: java.lang.String | string): void
                public set(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public setIfNotSet(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public static canonicalID(arg0: java.lang.String | string): string
                public parseHeader(arg0: java.io.InputStream): void
                public mergeHeader(arg0: java.io.InputStream): void
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class MeteredStream extends java.io.FilterInputStream {
                protected closed: boolean
                protected expected: long
                protected count: long
                protected markedCount: long
                protected markLimit: int
                protected pi: sun.net.ProgressSource
                public constructor(arg0: java.io.InputStream, arg1: sun.net.ProgressSource, arg2: long)
                public read(): int
                public read(arg0: byte[], arg1: int, arg2: int): int
                public skip(arg0: long): long
                public close(): void
                public available(): int
                public mark(arg0: int): void
                public reset(): void
                public markSupported(): boolean
                protected finalize(): void
                public static class: java.lang.Class<any>
            }
            class MimeEntry implements java.lang.Cloneable {
                public static UNKNOWN: int
                public static LOAD_INTO_BROWSER: int
                public static SAVE_TO_FILE: int
                public static LAUNCH_APPLICATION: int
                public constructor(arg0: java.lang.String | string)
                public getType(): string
                public setType(arg0: java.lang.String | string): void
                public getAction(): int
                public setAction(arg0: int, arg1: java.lang.String | string): void
                public setAction(arg0: int): void
                public getLaunchString(): string
                public setCommand(arg0: java.lang.String | string): void
                public getDescription(): string
                public setDescription(arg0: java.lang.String | string): void
                public getImageFileName(): string
                public setImageFileName(arg0: java.lang.String | string): void
                public getTempFileTemplate(): string
                public getExtensions(): java.lang.String[]
                public getExtensionsAsList(): string
                public setExtensions(arg0: java.lang.String | string): void
                public launch(arg0: java.net.URLConnection, arg1: java.io.InputStream, arg2: sun.net.www.MimeTable | sun.net.www.MimeTable$$Lambda): java.lang.Object
                public matches(arg0: java.lang.String | string): boolean
                public clone(): java.lang.Object
                public toProperty(): string
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class MimeLauncher extends java.lang.Thread {
                protected getTempFileName(arg0: java.net.URL, arg1: java.lang.String | string): string
                public run(): void
                public static class: java.lang.Class<any>
            }
            class MimeTable implements java.net.FileNameMap {
                protected static mailcapLocations: java.lang.String[]
                public static getDefaultTable(): sun.net.www.MimeTable
                public static loadTable(): java.net.FileNameMap
                public getSize(): int
                public getContentTypeFor(arg0: java.lang.String | string): string
                public add(arg0: sun.net.www.MimeEntry): void
                public remove(arg0: java.lang.String | string): sun.net.www.MimeEntry
                public remove(arg0: sun.net.www.MimeEntry): sun.net.www.MimeEntry
                public find(arg0: java.lang.String | string): sun.net.www.MimeEntry
                public findByFileName(arg0: java.lang.String | string): sun.net.www.MimeEntry
                public findByExt(arg0: java.lang.String | string): sun.net.www.MimeEntry
                public findByDescription(arg0: java.lang.String | string): sun.net.www.MimeEntry
                public elements(): java.util.Enumeration<sun.net.www.MimeEntry>
                public load(): void
                public save(arg0: java.lang.String | string): boolean
                public getAsProperties(): java.util.Properties
                protected saveAsProperties(arg0: java.io.File): boolean
                public static class: java.lang.Class<any>
            }
            class MimeTable$$Lambda implements java.net.FileNameMap {
                protected static mailcapLocations: java.lang.String[]
            }
            class ParseUtil {
                public constructor()
                public static encodePath(arg0: java.lang.String | string): string
                public static encodePath(arg0: java.lang.String | string, arg1: boolean): string
                public static decode(arg0: java.lang.String | string): string
                public canonizeString(arg0: java.lang.String | string): string
                public static fileToEncodedURL(arg0: java.io.File): java.net.URL
                public static toURI(arg0: java.net.URL): java.net.URI
                public static class: java.lang.Class<any>
            }
            abstract class URLConnection extends java.net.URLConnection {
                protected properties: sun.net.www.MessageHeader
                public constructor(arg0: java.net.URL)
                public getProperties(): sun.net.www.MessageHeader
                public setProperties(arg0: sun.net.www.MessageHeader): void
                public setRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public addRequestProperty(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public getRequestProperty(arg0: java.lang.String | string): string
                public getRequestProperties(): java.util.Map<java.lang.String, java.util.List<java.lang.String>>
                public getHeaderField(arg0: java.lang.String | string): string
                public getHeaderFieldKey(arg0: int): string
                public getHeaderField(arg0: int): string
                public getContentType(): string
                public setContentType(arg0: java.lang.String | string): void
                public getContentLength(): int
                protected setContentLength(arg0: int): void
                public canCache(): boolean
                public close(): void
                public static setProxiedHost(arg0: java.lang.String | string): void
                public static isProxiedHost(arg0: java.lang.String | string): boolean
                public static class: java.lang.Class<any>
            }
        }
        class ApplicationProxy extends java.net.Proxy {
            public static create(arg0: java.net.Proxy): sun.net.ApplicationProxy
            public static class: java.lang.Class<any>
        }
        class ConnectionResetException extends java.net.SocketException {
            public constructor(arg0: java.lang.String | string)
            public constructor()
            public static class: java.lang.Class<any>
        }
        class InetAddressCachePolicy {
            public static FOREVER: int
            public static NEVER: int
            public static DEFAULT_POSITIVE: int
            public constructor()
            public static get(): int
            public static getNegative(): int
            public static setIfNotSet(arg0: int): void
            public static setNegativeIfNotSet(arg0: int): void
            public static class: java.lang.Class<any>
        }
        class NetProperties {
            public static get(arg0: java.lang.String | string): string
            public static getInteger(arg0: java.lang.String | string, arg1: int): java.lang.Integer
            public static getBoolean(arg0: java.lang.String | string): boolean
            public static class: java.lang.Class<any>
        }
        class NetworkClient {
            public static DEFAULT_READ_TIMEOUT: int
            public static DEFAULT_CONNECT_TIMEOUT: int
            protected proxy: java.net.Proxy
            protected serverSocket: java.net.Socket
            public serverOutput: java.io.PrintStream
            public serverInput: java.io.InputStream
            protected static defaultSoTimeout: int
            protected static defaultConnectTimeout: int
            protected readTimeout: int
            protected connectTimeout: int
            protected static encoding: string
            public openServer(arg0: java.lang.String | string, arg1: int): void
            protected doConnect(arg0: java.lang.String | string, arg1: int): java.net.Socket
            protected createSocket(): java.net.Socket
            protected getLocalAddress(): java.net.InetAddress
            public closeServer(): void
            public serverIsOpen(): boolean
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor()
            public setConnectTimeout(arg0: int): void
            public getConnectTimeout(): int
            public setReadTimeout(arg0: int): void
            public getReadTimeout(): int
            public static class: java.lang.Class<any>
        }
        class ProgressEvent extends java.util.EventObject {
            public constructor(arg0: sun.net.ProgressSource, arg1: java.net.URL, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: sun.net.ProgressSource$State, arg5: long, arg6: long)
            public getURL(): java.net.URL
            public getMethod(): string
            public getContentType(): string
            public getProgress(): long
            public getExpected(): long
            public getState(): sun.net.ProgressSource$State
            public toString(): string
            public static class: java.lang.Class<any>
        }
        interface ProgressListener extends java.util.EventListener {
            progressStart(arg0: sun.net.ProgressEvent): void
            progressUpdate(arg0: sun.net.ProgressEvent): void
            progressFinish(arg0: sun.net.ProgressEvent): void
        }
        interface ProgressMeteringPolicy {
            shouldMeterInput(arg0: java.net.URL, arg1: java.lang.String | string): boolean
            getProgressUpdateThreshold(): int
        }
        class ProgressMonitor {
            public constructor()
            public static getDefault(): sun.net.ProgressMonitor
            public static setDefault(arg0: sun.net.ProgressMonitor): void
            public static setMeteringPolicy(arg0: sun.net.ProgressMeteringPolicy): void
            public getProgressSources(): java.util.ArrayList<sun.net.ProgressSource>
            public getProgressUpdateThreshold(): int
            public shouldMeterInput(arg0: java.net.URL, arg1: java.lang.String | string): boolean
            public registerSource(arg0: sun.net.ProgressSource): void
            public unregisterSource(arg0: sun.net.ProgressSource): void
            public updateProgress(arg0: sun.net.ProgressSource): void
            public addProgressListener(arg0: sun.net.ProgressListener): void
            public removeProgressListener(arg0: sun.net.ProgressListener): void
            public static class: java.lang.Class<any>
        }
        class ProgressSource {
            public constructor(arg0: java.net.URL, arg1: java.lang.String | string)
            public constructor(arg0: java.net.URL, arg1: java.lang.String | string, arg2: long)
            public connected(): boolean
            public close(): void
            public getURL(): java.net.URL
            public getMethod(): string
            public getContentType(): string
            public setContentType(arg0: java.lang.String | string): void
            public getProgress(): long
            public getExpected(): long
            public getState(): sun.net.ProgressSource$State
            public beginTracking(): void
            public finishTracking(): void
            public updateProgress(arg0: long, arg1: long): void
            public clone(): java.lang.Object
            public toString(): string
            public static class: java.lang.Class<any>
        }
        class ResourceManager {
            public constructor()
            public static beforeUdpCreate(): void
            public static afterUdpClose(): void
            public static class: java.lang.Class<any>
        }
        class SocksProxy extends java.net.Proxy {
            public static create(arg0: java.net.SocketAddress, arg1: int): sun.net.SocksProxy
            public protocolVersion(): int
            public static class: java.lang.Class<any>
        }
        class TelnetInputStream extends java.io.FilterInputStream {
            public binaryMode: boolean
            public constructor(arg0: java.io.InputStream, arg1: boolean)
            public setStickyCRLF(arg0: boolean): void
            public read(): int
            public read(arg0: byte[]): int
            public read(arg0: byte[], arg1: int, arg2: int): int
            public static class: java.lang.Class<any>
        }
        class TelnetOutputStream extends java.io.BufferedOutputStream {
            public binaryMode: boolean
            public constructor(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean)
            public setStickyCRLF(arg0: boolean): void
            public write(arg0: int): void
            public write(arg0: byte[], arg1: int, arg2: int): void
            public static class: java.lang.Class<any>
        }
        class TelnetProtocolException extends java.io.IOException {
            public constructor(arg0: java.lang.String | string)
            public static class: java.lang.Class<any>
        }
        class TransferProtocolClient extends sun.net.NetworkClient {
            protected serverResponse: java.util.Vector<java.lang.String>
            protected lastReplyCode: int
            public readServerResponse(): int
            public sendServer(arg0: java.lang.String | string): void
            public getResponseString(): string
            public getResponseStrings(): java.util.Vector<java.lang.String>
            public constructor(arg0: java.lang.String | string, arg1: int)
            public constructor()
            public static class: java.lang.Class<any>
        }
    }
    namespace nio {
        namespace ch {
            class AllocatedNativeObject extends sun.nio.ch.NativeObject {
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousChannelGroupImpl extends java.nio.channels.AsynchronousChannelGroup implements java.util.concurrent.Executor {
                protected startThreads(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
                public isShutdown(): boolean
                public isTerminated(): boolean
                public shutdown(): void
                public shutdownNow(): void
                public awaitTermination(arg0: long, arg1: java.util.concurrent.TimeUnit): boolean
                public execute(arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousChannelGroupImpl$$Lambda extends java.nio.channels.AsynchronousChannelGroup implements java.util.concurrent.Executor {
                protected (arg0: java.lang.Runnable | java.lang.Runnable$$Lambda): void
            }
            abstract class AsynchronousFileChannelImpl extends java.nio.channels.AsynchronousFileChannel {
                protected closeLock: java.util.concurrent.locks.ReadWriteLock
                protected closed: boolean
                protected fdObj: java.io.FileDescriptor
                protected reading: boolean
                protected writing: boolean
                protected executor: java.util.concurrent.ExecutorService
                protected constructor(arg0: java.io.FileDescriptor, arg1: boolean, arg2: boolean, arg3: java.util.concurrent.ExecutorService)
                public isOpen(): boolean
                protected begin(): void
                protected end(): void
                protected end(arg0: boolean): void
                public lock(arg0: long, arg1: long, arg2: boolean): java.util.concurrent.Future<java.nio.channels.FileLock>
                public lock<A>(arg0: long, arg1: long, arg2: boolean, arg3: A, arg4: java.nio.channels.CompletionHandler<java.nio.channels.FileLock, A>): void
                protected addToFileLockTable(arg0: long, arg1: long, arg2: boolean): sun.nio.ch.FileLockImpl
                protected removeFromFileLockTable(arg0: sun.nio.ch.FileLockImpl): void
                protected implRelease(arg0: sun.nio.ch.FileLockImpl): void
                public read(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<java.lang.Integer>
                public read<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public write(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<java.lang.Integer>
                public write<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousServerSocketChannelImpl extends java.nio.channels.AsynchronousServerSocketChannel implements sun.nio.ch.Cancellable , sun.nio.ch.Groupable {
                protected fd: java.io.FileDescriptor
                protected localAddress: java.net.InetSocketAddress
                public isOpen(): boolean
                public close(): void
                public accept(): java.util.concurrent.Future<java.nio.channels.AsynchronousSocketChannel>
                public accept<A>(arg0: A, arg1: java.nio.channels.CompletionHandler<java.nio.channels.AsynchronousSocketChannel, A>): void
                public onCancel(arg0: sun.nio.ch.PendingFuture<any, any>): void
                public bind(arg0: java.net.SocketAddress, arg1: int): java.nio.channels.AsynchronousServerSocketChannel
                public getLocalAddress(): java.net.SocketAddress
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.AsynchronousServerSocketChannel
                public getOption<T>(arg0: java.net.SocketOption<T>): T
                public supportedOptions(): java.util.Set<java.net.SocketOption<any>>
                public toString(): string
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousServerSocketChannelImpl$$Lambda extends java.nio.channels.AsynchronousServerSocketChannel implements sun.nio.ch.Cancellable , sun.nio.ch.Groupable {
                protected fd: java.io.FileDescriptor
            }
            abstract class AsynchronousSocketChannelImpl extends java.nio.channels.AsynchronousSocketChannel implements sun.nio.ch.Cancellable , sun.nio.ch.Groupable {
                protected fd: java.io.FileDescriptor
                protected stateLock: java.lang.Object
                protected localAddress: java.net.InetSocketAddress
                protected remoteAddress: java.net.InetSocketAddress
                protected state: int
                public isOpen(): boolean
                public close(): void
                public connect(arg0: java.net.SocketAddress): java.util.concurrent.Future<java.lang.Void>
                public connect<A>(arg0: java.net.SocketAddress, arg1: A, arg2: java.nio.channels.CompletionHandler<java.lang.Void, A>): void
                public read(arg0: java.nio.ByteBuffer): java.util.concurrent.Future<java.lang.Integer>
                public read<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: java.util.concurrent.TimeUnit, arg3: A, arg4: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public read<A>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int, arg3: long, arg4: java.util.concurrent.TimeUnit, arg5: A, arg6: java.nio.channels.CompletionHandler<java.lang.Long, A>): void
                public write(arg0: java.nio.ByteBuffer): java.util.concurrent.Future<java.lang.Integer>
                public write<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: java.util.concurrent.TimeUnit, arg3: A, arg4: java.nio.channels.CompletionHandler<java.lang.Integer, A>): void
                public write<A>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int, arg3: long, arg4: java.util.concurrent.TimeUnit, arg5: A, arg6: java.nio.channels.CompletionHandler<java.lang.Long, A>): void
                public bind(arg0: java.net.SocketAddress): java.nio.channels.AsynchronousSocketChannel
                public getLocalAddress(): java.net.SocketAddress
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.AsynchronousSocketChannel
                public getOption<T>(arg0: java.net.SocketOption<T>): T
                public supportedOptions(): java.util.Set<java.net.SocketOption<any>>
                public getRemoteAddress(): java.net.SocketAddress
                public shutdownInput(): java.nio.channels.AsynchronousSocketChannel
                public shutdownOutput(): java.nio.channels.AsynchronousSocketChannel
                public toString(): string
                public setOption(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            abstract class AsynchronousSocketChannelImpl$$Lambda extends java.nio.channels.AsynchronousSocketChannel implements sun.nio.ch.Cancellable , sun.nio.ch.Groupable {
                protected fd: java.io.FileDescriptor
            }
            interface Cancellable {
                onCancel(arg0: sun.nio.ch.PendingFuture<any, any>): void
            }
            interface Cancellable$$Lambda {
                (arg0: sun.nio.ch.PendingFuture<any, any>): void
            }
            class ChannelInputStream extends java.io.InputStream {
                protected ch: java.nio.channels.ReadableByteChannel
                public static read(arg0: java.nio.channels.ReadableByteChannel, arg1: java.nio.ByteBuffer, arg2: boolean): int
                public constructor(arg0: java.nio.channels.ReadableByteChannel)
                public read(): int
                public read(arg0: byte[], arg1: int, arg2: int): int
                protected read(arg0: java.nio.ByteBuffer): int
                public available(): int
                public close(): void
                public static class: java.lang.Class<any>
            }
            class CompletedFuture<V> implements java.util.concurrent.Future<V> {
                public get(): V
                public get(arg0: long, arg1: java.util.concurrent.TimeUnit): V
                public isCancelled(): boolean
                public isDone(): boolean
                public cancel(arg0: boolean): boolean
                public static class: java.lang.Class<any>
            }
            class DatagramChannelImpl extends java.nio.channels.DatagramChannel implements sun.nio.ch.SelChImpl {
                public constructor(arg0: java.nio.channels.spi.SelectorProvider)
                public constructor(arg0: java.nio.channels.spi.SelectorProvider, arg1: java.net.ProtocolFamily | java.net.ProtocolFamily$$Lambda)
                public constructor(arg0: java.nio.channels.spi.SelectorProvider, arg1: java.io.FileDescriptor)
                public socket(): java.net.DatagramSocket
                public getLocalAddress(): java.net.SocketAddress
                public getRemoteAddress(): java.net.SocketAddress
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.DatagramChannel
                public getOption<T>(arg0: java.net.SocketOption<T>): T
                public supportedOptions<T>(): java.util.Set<java.net.SocketOption<any>>
                public receive<T>(arg0: java.nio.ByteBuffer): java.net.SocketAddress
                public send<T>(arg0: java.nio.ByteBuffer, arg1: java.net.SocketAddress): int
                public read<T>(arg0: java.nio.ByteBuffer): int
                public read<T>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public write<T>(arg0: java.nio.ByteBuffer): int
                public write<T>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                protected implConfigureBlocking<T>(arg0: boolean): void
                public localAddress<T>(): java.net.SocketAddress
                public remoteAddress<T>(): java.net.SocketAddress
                public bind<T>(arg0: java.net.SocketAddress): java.nio.channels.DatagramChannel
                public isConnected<T>(): boolean
                public connect<T>(arg0: java.net.SocketAddress): java.nio.channels.DatagramChannel
                public disconnect<T>(): java.nio.channels.DatagramChannel
                public join<T>(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface): java.nio.channels.MembershipKey
                public join<T>(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface, arg2: java.net.InetAddress): java.nio.channels.MembershipKey
                protected implCloseSelectableChannel<T>(): void
                public kill<T>(): void
                protected finalize<T>(): void
                public translateReadyOps<T>(arg0: int, arg1: int, arg2: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndUpdateReadyOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndSetReadyOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndSetInterestOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): void
                public getFD<T>(): java.io.FileDescriptor
                public getFDVal<T>(): int
                public setOption<T>(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind<T>(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            class DatagramSocketAdaptor extends java.net.DatagramSocket {
                public static create(arg0: sun.nio.ch.DatagramChannelImpl): java.net.DatagramSocket
                public bind(arg0: java.net.SocketAddress): void
                public connect(arg0: java.net.InetAddress, arg1: int): void
                public connect(arg0: java.net.SocketAddress): void
                public disconnect(): void
                public isBound(): boolean
                public isConnected(): boolean
                public getInetAddress(): java.net.InetAddress
                public getPort(): int
                public send(arg0: java.net.DatagramPacket): void
                public receive(arg0: java.net.DatagramPacket): void
                public getLocalAddress(): java.net.InetAddress
                public getLocalPort(): int
                public setSoTimeout(arg0: int): void
                public getSoTimeout(): int
                public setSendBufferSize(arg0: int): void
                public getSendBufferSize(): int
                public setReceiveBufferSize(arg0: int): void
                public getReceiveBufferSize(): int
                public setReuseAddress(arg0: boolean): void
                public getReuseAddress(): boolean
                public setBroadcast(arg0: boolean): void
                public getBroadcast(): boolean
                public setTrafficClass(arg0: int): void
                public getTrafficClass(): int
                public close(): void
                public isClosed(): boolean
                public getChannel(): java.nio.channels.DatagramChannel
                public static class: java.lang.Class<any>
            }
            interface DirectBuffer {
                address(): long
                attachment(): java.lang.Object
                cleaner(): sun.misc.Cleaner
            }
            class ExtendedSocketOption {
                public static class: java.lang.Class<any>
            }
            class FileChannelImpl extends java.nio.channels.FileChannel {
                public static open(arg0: java.io.FileDescriptor, arg1: java.lang.String | string, arg2: boolean, arg3: boolean, arg4: java.lang.Object): java.nio.channels.FileChannel
                public static open(arg0: java.io.FileDescriptor, arg1: java.lang.String | string, arg2: boolean, arg3: boolean, arg4: boolean, arg5: java.lang.Object): java.nio.channels.FileChannel
                protected implCloseChannel(): void
                public read(arg0: java.nio.ByteBuffer): int
                public read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public write(arg0: java.nio.ByteBuffer): int
                public write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public position(): long
                public position(arg0: long): java.nio.channels.FileChannel
                public size(): long
                public truncate(arg0: long): java.nio.channels.FileChannel
                public force(arg0: boolean): void
                public transferTo(arg0: long, arg1: long, arg2: java.nio.channels.WritableByteChannel): long
                public transferFrom(arg0: java.nio.channels.ReadableByteChannel, arg1: long, arg2: long): long
                public read(arg0: java.nio.ByteBuffer, arg1: long): int
                public write(arg0: java.nio.ByteBuffer, arg1: long): int
                public map(arg0: java.nio.channels.FileChannel$MapMode, arg1: long, arg2: long): java.nio.MappedByteBuffer
                public static getMappedBufferPool(): sun.misc.JavaNioAccess$BufferPool
                public lock(arg0: long, arg1: long, arg2: boolean): java.nio.channels.FileLock
                public tryLock(arg0: long, arg1: long, arg2: boolean): java.nio.channels.FileLock
                public truncate(arg0: long): java.nio.channels.SeekableByteChannel
                public position(arg0: long): java.nio.channels.SeekableByteChannel
                public static class: java.lang.Class<any>
            }
            abstract class FileDispatcher extends sun.nio.ch.NativeDispatcher {
                public static NO_LOCK: int
                public static LOCKED: int
                public static RET_EX_LOCK: int
                public static INTERRUPTED: int
                public static class: java.lang.Class<any>
            }
            class FileLockImpl extends java.nio.channels.FileLock {
                public isValid(): boolean
                public release(): void
                public static class: java.lang.Class<any>
            }
            abstract class FileLockTable {
                protected constructor()
                public static newSharedFileLockTable(arg0: java.nio.channels.Channel, arg1: java.io.FileDescriptor): sun.nio.ch.FileLockTable
                public add(arg0: java.nio.channels.FileLock | java.nio.channels.FileLock$$Lambda): void
                public remove(arg0: java.nio.channels.FileLock | java.nio.channels.FileLock$$Lambda): void
                public removeAll(): java.util.List<java.nio.channels.FileLock>
                public replace(arg0: java.nio.channels.FileLock | java.nio.channels.FileLock$$Lambda, arg1: java.nio.channels.FileLock | java.nio.channels.FileLock$$Lambda): void
                public static class: java.lang.Class<any>
            }
            interface Groupable {
                group(): sun.nio.ch.AsynchronousChannelGroupImpl
            }
            interface Groupable$$Lambda {
                (): sun.nio.ch.AsynchronousChannelGroupImpl
            }
            class IOStatus {
                public static EOF: int
                public static UNAVAILABLE: int
                public static INTERRUPTED: int
                public static UNSUPPORTED: int
                public static THROWN: int
                public static UNSUPPORTED_CASE: int
                public static normalize(arg0: int): int
                public static check(arg0: int): boolean
                public static normalize(arg0: long): long
                public static check(arg0: long): boolean
                public static checkAll(arg0: long): boolean
                public static class: java.lang.Class<any>
            }
            class IOUtil {
                public static newFD(arg0: int): java.io.FileDescriptor
                public static configureBlocking(arg0: java.io.FileDescriptor, arg1: boolean): void
                public static fdVal(arg0: java.io.FileDescriptor): int
                public static load(): void
                public static class: java.lang.Class<any>
            }
            class IOVecWrapper {
                public static class: java.lang.Class<any>
            }
            interface Interruptible {
                interrupt(arg0: java.lang.Thread | java.lang.Thread$$Lambda): void
            }
            interface Interruptible$$Lambda {
                (arg0: java.lang.Thread | java.lang.Thread$$Lambda): void
            }
            class Invoker {
                public static class: java.lang.Class<any>
            }
            class MembershipKeyImpl extends java.nio.channels.MembershipKey {
                public isValid(): boolean
                public drop(): void
                public channel(): java.nio.channels.MulticastChannel
                public group(): java.net.InetAddress
                public networkInterface(): java.net.NetworkInterface
                public sourceAddress(): java.net.InetAddress
                public block(arg0: java.net.InetAddress): java.nio.channels.MembershipKey
                public unblock(arg0: java.net.InetAddress): java.nio.channels.MembershipKey
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class MembershipRegistry {
                public static class: java.lang.Class<any>
            }
            abstract class NativeDispatcher {
                public static class: java.lang.Class<any>
            }
            class NativeObject {
                protected static unsafe: sun.misc.Unsafe
                protected allocationAddress: long
                protected constructor(arg0: int, arg1: boolean)
                public static class: java.lang.Class<any>
            }
            class NativeThreadSet {
                public static class: java.lang.Class<any>
            }
            class Net {
                public static SHUT_RD: int
                public static SHUT_WR: int
                public static SHUT_RDWR: int
                public static POLLIN: short
                public static POLLOUT: short
                public static POLLERR: short
                public static POLLHUP: short
                public static POLLNVAL: short
                public static POLLCONN: short
                public static checkAddress(arg0: java.net.SocketAddress): java.net.InetSocketAddress
                public static isFastTcpLoopbackRequested(): boolean
                public static bind(arg0: java.io.FileDescriptor, arg1: java.net.InetAddress, arg2: int): void
                public static localAddress(arg0: java.io.FileDescriptor): java.net.InetSocketAddress
                public static class: java.lang.Class<any>
            }
            class OptionKey {
                public static class: java.lang.Class<any>
            }
            class PendingFuture<V, A> implements java.util.concurrent.Future<V> {
                public get(): V
                public get(arg0: long, arg1: java.util.concurrent.TimeUnit): V
                public isCancelled(): boolean
                public isDone(): boolean
                public cancel(arg0: boolean): boolean
                public static class: java.lang.Class<any>
            }
            class Reflect {
                public static class: java.lang.Class<any>
            }
            class Secrets {
                public static newSocketChannel(arg0: java.io.FileDescriptor): java.nio.channels.SocketChannel
                public static newServerSocketChannel(arg0: java.io.FileDescriptor): java.nio.channels.ServerSocketChannel
                public static class: java.lang.Class<any>
            }
            interface SelChImpl extends java.nio.channels.Channel {
                getFD(): java.io.FileDescriptor
                getFDVal(): int
                translateAndUpdateReadyOps(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                translateAndSetReadyOps(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                translateAndSetInterestOps(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): void
                validOps(): int
                kill(): void
            }
            class SelectionKeyImpl extends java.nio.channels.spi.AbstractSelectionKey {
                public selector: sun.nio.ch.SelectorImpl
                public channel(): java.nio.channels.SelectableChannel
                public selector(): java.nio.channels.Selector
                public interestOps(): int
                public interestOps(arg0: int): java.nio.channels.SelectionKey
                public readyOps(): int
                public nioReadyOps(arg0: int): void
                public nioReadyOps(): int
                public nioInterestOps(arg0: int): java.nio.channels.SelectionKey
                public nioInterestOps(): int
                public static class: java.lang.Class<any>
            }
            abstract class SelectorImpl extends java.nio.channels.spi.AbstractSelector {
                protected selectedKeys: java.util.Set<java.nio.channels.SelectionKey>
                protected keys: java.util.HashSet<java.nio.channels.SelectionKey>
                protected constructor(arg0: java.nio.channels.spi.SelectorProvider)
                public keys(): java.util.Set<java.nio.channels.SelectionKey>
                public selectedKeys(): java.util.Set<java.nio.channels.SelectionKey>
                protected doSelect(arg0: long): int
                public select(arg0: long): int
                public select(): int
                public selectNow(): int
                public implCloseSelector(): void
                protected implClose(): void
                public putEventOps(arg0: sun.nio.ch.SelectionKeyImpl, arg1: int): void
                protected register(arg0: java.nio.channels.spi.AbstractSelectableChannel, arg1: int, arg2: java.lang.Object): java.nio.channels.SelectionKey
                protected implRegister(arg0: sun.nio.ch.SelectionKeyImpl): void
                protected implDereg(arg0: sun.nio.ch.SelectionKeyImpl): void
                public wakeup(): java.nio.channels.Selector
                public static class: java.lang.Class<any>
            }
            abstract class SelectorProviderImpl extends java.nio.channels.spi.SelectorProvider {
                public constructor()
                public openDatagramChannel(): java.nio.channels.DatagramChannel
                public openDatagramChannel(arg0: java.net.ProtocolFamily | java.net.ProtocolFamily$$Lambda): java.nio.channels.DatagramChannel
                public openPipe(): java.nio.channels.Pipe
                public openSelector(): java.nio.channels.spi.AbstractSelector
                public openServerSocketChannel(): java.nio.channels.ServerSocketChannel
                public openSocketChannel(): java.nio.channels.SocketChannel
                public static class: java.lang.Class<any>
            }
            class ServerSocketAdaptor extends java.net.ServerSocket {
                public static create(arg0: sun.nio.ch.ServerSocketChannelImpl): java.net.ServerSocket
                public bind(arg0: java.net.SocketAddress): void
                public bind(arg0: java.net.SocketAddress, arg1: int): void
                public getInetAddress(): java.net.InetAddress
                public getLocalPort(): int
                public accept(): java.net.Socket
                public close(): void
                public getChannel(): java.nio.channels.ServerSocketChannel
                public isBound(): boolean
                public isClosed(): boolean
                public setSoTimeout(arg0: int): void
                public getSoTimeout(): int
                public setReuseAddress(arg0: boolean): void
                public getReuseAddress(): boolean
                public toString(): string
                public setReceiveBufferSize(arg0: int): void
                public getReceiveBufferSize(): int
                public static class: java.lang.Class<any>
            }
            class ServerSocketChannelImpl extends java.nio.channels.ServerSocketChannel implements sun.nio.ch.SelChImpl {
                public socket(): java.net.ServerSocket
                public getLocalAddress(): java.net.SocketAddress
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.ServerSocketChannel
                public getOption<T>(arg0: java.net.SocketOption<T>): T
                public supportedOptions<T>(): java.util.Set<java.net.SocketOption<any>>
                public isBound<T>(): boolean
                public localAddress<T>(): java.net.InetSocketAddress
                public bind<T>(arg0: java.net.SocketAddress, arg1: int): java.nio.channels.ServerSocketChannel
                public accept<T>(): java.nio.channels.SocketChannel
                protected implConfigureBlocking<T>(arg0: boolean): void
                protected implCloseSelectableChannel<T>(): void
                public kill<T>(): void
                public translateReadyOps<T>(arg0: int, arg1: int, arg2: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndUpdateReadyOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndSetReadyOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndSetInterestOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): void
                public getFD<T>(): java.io.FileDescriptor
                public getFDVal<T>(): int
                public toString<T>(): string
                public setOption<T>(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            class SimpleAsynchronousFileChannelImpl extends sun.nio.ch.AsynchronousFileChannelImpl {
                public static open(arg0: java.io.FileDescriptor, arg1: boolean, arg2: boolean, arg3: sun.nio.ch.ThreadPool): java.nio.channels.AsynchronousFileChannel
                public close(): void
                public size(): long
                public truncate(arg0: long): java.nio.channels.AsynchronousFileChannel
                public force(arg0: boolean): void
                public tryLock(arg0: long, arg1: long, arg2: boolean): java.nio.channels.FileLock
                protected implRelease(arg0: sun.nio.ch.FileLockImpl): void
                public static class: java.lang.Class<any>
            }
            class SocketAdaptor extends java.net.Socket {
                public static create(arg0: sun.nio.ch.SocketChannelImpl): java.net.Socket
                public getChannel(): java.nio.channels.SocketChannel
                public connect(arg0: java.net.SocketAddress): void
                public connect(arg0: java.net.SocketAddress, arg1: int): void
                public bind(arg0: java.net.SocketAddress): void
                public getInetAddress(): java.net.InetAddress
                public getLocalAddress(): java.net.InetAddress
                public getPort(): int
                public getLocalPort(): int
                public getInputStream(): java.io.InputStream
                public getOutputStream(): java.io.OutputStream
                public setTcpNoDelay(arg0: boolean): void
                public getTcpNoDelay(): boolean
                public setSoLinger(arg0: boolean, arg1: int): void
                public getSoLinger(): int
                public sendUrgentData(arg0: int): void
                public setOOBInline(arg0: boolean): void
                public getOOBInline(): boolean
                public setSoTimeout(arg0: int): void
                public getSoTimeout(): int
                public setSendBufferSize(arg0: int): void
                public getSendBufferSize(): int
                public setReceiveBufferSize(arg0: int): void
                public getReceiveBufferSize(): int
                public setKeepAlive(arg0: boolean): void
                public getKeepAlive(): boolean
                public setTrafficClass(arg0: int): void
                public getTrafficClass(): int
                public setReuseAddress(arg0: boolean): void
                public getReuseAddress(): boolean
                public close(): void
                public shutdownInput(): void
                public shutdownOutput(): void
                public toString(): string
                public isConnected(): boolean
                public isBound(): boolean
                public isClosed(): boolean
                public isInputShutdown(): boolean
                public isOutputShutdown(): boolean
                public static class: java.lang.Class<any>
            }
            class SocketChannelImpl extends java.nio.channels.SocketChannel implements sun.nio.ch.SelChImpl {
                public socket(): java.net.Socket
                public getLocalAddress(): java.net.SocketAddress
                public getRemoteAddress(): java.net.SocketAddress
                public setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): java.nio.channels.SocketChannel
                public getOption<T>(arg0: java.net.SocketOption<T>): T
                public supportedOptions<T>(): java.util.Set<java.net.SocketOption<any>>
                public read<T>(arg0: java.nio.ByteBuffer): int
                public read<T>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                public write<T>(arg0: java.nio.ByteBuffer): int
                public write<T>(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): long
                protected implConfigureBlocking<T>(arg0: boolean): void
                public localAddress<T>(): java.net.InetSocketAddress
                public remoteAddress<T>(): java.net.SocketAddress
                public bind<T>(arg0: java.net.SocketAddress): java.nio.channels.SocketChannel
                public isConnected<T>(): boolean
                public isConnectionPending<T>(): boolean
                public connect<T>(arg0: java.net.SocketAddress): boolean
                public finishConnect<T>(): boolean
                public shutdownInput<T>(): java.nio.channels.SocketChannel
                public shutdownOutput<T>(): java.nio.channels.SocketChannel
                public isInputOpen<T>(): boolean
                public isOutputOpen<T>(): boolean
                protected implCloseSelectableChannel<T>(): void
                public kill<T>(): void
                public translateReadyOps<T>(arg0: int, arg1: int, arg2: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndUpdateReadyOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndSetReadyOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): boolean
                public translateAndSetInterestOps<T>(arg0: int, arg1: sun.nio.ch.SelectionKeyImpl): void
                public getFD<T>(): java.io.FileDescriptor
                public getFDVal<T>(): int
                public toString<T>(): string
                public setOption<T>(arg0: java.net.SocketOption, arg1: java.lang.Object): java.nio.channels.NetworkChannel
                public bind<T>(arg0: java.net.SocketAddress): java.nio.channels.NetworkChannel
                public static class: java.lang.Class<any>
            }
            class ThreadPool {
                public static wrap(arg0: java.util.concurrent.ExecutorService, arg1: int): sun.nio.ch.ThreadPool
                public static class: java.lang.Class<any>
            }
            class Util {
                public constructor()
                public static getTemporaryDirectBuffer(arg0: int): java.nio.ByteBuffer
                public static releaseTemporaryDirectBuffer(arg0: java.nio.ByteBuffer): void
                public static class: java.lang.Class<any>
            }
        }
        namespace cs {
            interface ArrayDecoder {
                decode(arg0: byte[], arg1: int, arg2: int, arg3: char[]): int
            }
            interface ArrayDecoder$$Lambda {
                (arg0: byte[], arg1: int, arg2: int, arg3: char[]): int
            }
            interface ArrayEncoder {
                encode(arg0: char[], arg1: int, arg2: int, arg3: byte[]): int
            }
            interface ArrayEncoder$$Lambda {
                (arg0: char[], arg1: int, arg2: int, arg3: byte[]): int
            }
            class CESU_8 extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class CharsetMapping {
                public static UNMAPPABLE_DECODING: char
                public static UNMAPPABLE_ENCODING: int
                public constructor()
                public decodeSingle(arg0: int): char
                public decodeDouble(arg0: int, arg1: int): char
                public decodeSurrogate(arg0: int, arg1: char[]): char[]
                public decodeComposite(arg0: sun.nio.cs.CharsetMapping$Entry, arg1: char[]): char[]
                public encodeChar(arg0: char): int
                public encodeSurrogate(arg0: char, arg1: char): int
                public isCompositeBase(arg0: sun.nio.cs.CharsetMapping$Entry): boolean
                public encodeComposite(arg0: sun.nio.cs.CharsetMapping$Entry): int
                public static get(arg0: java.io.InputStream): sun.nio.cs.CharsetMapping
                public static class: java.lang.Class<any>
            }
            interface HistoricallyNamedCharset {
                historicalName(): string
            }
            interface HistoricallyNamedCharset$$Lambda {
                (): string
            }
            class ISO_8859_1 extends java.nio.charset.Charset implements sun.nio.cs.HistoricallyNamedCharset {
                public constructor()
                public historicalName(): string
                public contains(arg0: java.nio.charset.Charset): boolean
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class ISO_8859_1$$Lambda extends java.nio.charset.Charset implements sun.nio.cs.HistoricallyNamedCharset {
                public constructor()
            }
            class SingleByte {
                public constructor()
                public static initC2B(arg0: char[], arg1: char[], arg2: char[], arg3: char[]): void
                public static class: java.lang.Class<any>
            }
            class StreamDecoder extends java.io.Reader {
                public static forInputStreamReader(arg0: java.io.InputStream, arg1: java.lang.Object, arg2: java.lang.String | string): sun.nio.cs.StreamDecoder
                public static forInputStreamReader(arg0: java.io.InputStream, arg1: java.lang.Object, arg2: java.nio.charset.Charset): sun.nio.cs.StreamDecoder
                public static forInputStreamReader(arg0: java.io.InputStream, arg1: java.lang.Object, arg2: java.nio.charset.CharsetDecoder): sun.nio.cs.StreamDecoder
                public static forDecoder(arg0: java.nio.channels.ReadableByteChannel, arg1: java.nio.charset.CharsetDecoder, arg2: int): sun.nio.cs.StreamDecoder
                public getEncoding(): string
                public read(): int
                public read(arg0: char[], arg1: int, arg2: int): int
                public ready(): boolean
                public close(): void
                public static class: java.lang.Class<any>
            }
            class StreamEncoder extends java.io.Writer {
                public static forOutputStreamWriter(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.Object, arg2: java.lang.String | string): sun.nio.cs.StreamEncoder
                public static forOutputStreamWriter(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.Object, arg2: java.nio.charset.Charset): sun.nio.cs.StreamEncoder
                public static forOutputStreamWriter(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: java.lang.Object, arg2: java.nio.charset.CharsetEncoder): sun.nio.cs.StreamEncoder
                public static forEncoder(arg0: java.nio.channels.WritableByteChannel, arg1: java.nio.charset.CharsetEncoder, arg2: int): sun.nio.cs.StreamEncoder
                public getEncoding(): string
                public flushBuffer(): void
                public write(arg0: int): void
                public write(arg0: char[], arg1: int, arg2: int): void
                public write(arg0: java.lang.String | string, arg1: int, arg2: int): void
                public flush(): void
                public close(): void
                public static class: java.lang.Class<any>
            }
            class Surrogate {
                public static MIN_HIGH: char
                public static MAX_HIGH: char
                public static MIN_LOW: char
                public static MAX_LOW: char
                public static MIN: char
                public static MAX: char
                public static UCS4_MIN: int
                public static UCS4_MAX: int
                public static isHigh(arg0: int): boolean
                public static isLow(arg0: int): boolean
                public static is(arg0: int): boolean
                public static neededFor(arg0: int): boolean
                public static high(arg0: int): char
                public static low(arg0: int): char
                public static toUCS4(arg0: char, arg1: char): int
                public static class: java.lang.Class<any>
            }
            class ThreadLocalCoders {
                public constructor()
                public static decoderFor(arg0: java.lang.Object): java.nio.charset.CharsetDecoder
                public static encoderFor(arg0: java.lang.Object): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class US_ASCII extends java.nio.charset.Charset implements sun.nio.cs.HistoricallyNamedCharset {
                public constructor()
                public historicalName(): string
                public contains(arg0: java.nio.charset.Charset): boolean
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class US_ASCII$$Lambda extends java.nio.charset.Charset implements sun.nio.cs.HistoricallyNamedCharset {
                public constructor()
            }
            class UTF_16 extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class UTF_16BE extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class UTF_16LE extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class UTF_16LE_BOM extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            class UTF_32 extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public contains(arg0: java.nio.charset.Charset): boolean
                public static class: java.lang.Class<any>
            }
            class UTF_32BE extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public contains(arg0: java.nio.charset.Charset): boolean
                public static class: java.lang.Class<any>
            }
            class UTF_32BE_BOM extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public contains(arg0: java.nio.charset.Charset): boolean
                public static class: java.lang.Class<any>
            }
            class UTF_32Coder {
                protected static BOM_BIG: int
                protected static BOM_LITTLE: int
                protected static NONE: int
                protected static BIG: int
                protected static LITTLE: int
                public static class: java.lang.Class<any>
            }
            class UTF_32LE extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public contains(arg0: java.nio.charset.Charset): boolean
                public static class: java.lang.Class<any>
            }
            class UTF_32LE_BOM extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public contains(arg0: java.nio.charset.Charset): boolean
                public static class: java.lang.Class<any>
            }
            class UTF_8 extends sun.nio.cs.Unicode {
                public constructor()
                public historicalName(): string
                public newDecoder(): java.nio.charset.CharsetDecoder
                public newEncoder(): java.nio.charset.CharsetEncoder
                public static class: java.lang.Class<any>
            }
            abstract class Unicode extends java.nio.charset.Charset implements sun.nio.cs.HistoricallyNamedCharset {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String[])
                public contains(arg0: java.nio.charset.Charset): boolean
                public static class: java.lang.Class<any>
            }
            abstract class Unicode$$Lambda extends java.nio.charset.Charset implements sun.nio.cs.HistoricallyNamedCharset {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String[])
            }
            abstract class UnicodeDecoder extends java.nio.charset.CharsetDecoder {
                protected static BYTE_ORDER_MARK: char
                protected static REVERSED_MARK: char
                protected static NONE: int
                protected static BIG: int
                protected static LITTLE: int
                public constructor(arg0: java.nio.charset.Charset, arg1: int)
                public constructor(arg0: java.nio.charset.Charset, arg1: int, arg2: int)
                protected decodeLoop(arg0: java.nio.ByteBuffer, arg1: java.nio.CharBuffer): java.nio.charset.CoderResult
                protected implReset(): void
                public static class: java.lang.Class<any>
            }
            abstract class UnicodeEncoder extends java.nio.charset.CharsetEncoder {
                protected static BYTE_ORDER_MARK: char
                protected static REVERSED_MARK: char
                protected static BIG: int
                protected static LITTLE: int
                protected constructor(arg0: java.nio.charset.Charset, arg1: int, arg2: boolean)
                protected encodeLoop(arg0: java.nio.CharBuffer, arg1: java.nio.ByteBuffer): java.nio.charset.CoderResult
                protected implReset(): void
                public canEncode(arg0: char): boolean
                public static class: java.lang.Class<any>
            }
        }
        namespace fs {
            abstract class AbstractAclFileAttributeView implements java.nio.file.attribute.AclFileAttributeView , sun.nio.fs.DynamicFileAttributeView {
                public name(): string
                public setAttribute(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public readAttributes(arg0: java.lang.String[]): java.util.Map<java.lang.String, java.lang.Object>
                public static class: java.lang.Class<any>
            }
            abstract class AbstractBasicFileAttributeView implements java.nio.file.attribute.BasicFileAttributeView , sun.nio.fs.DynamicFileAttributeView {
                protected constructor()
                public name(): string
                public setAttribute(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public readAttributes(arg0: java.lang.String[]): java.util.Map<java.lang.String, java.lang.Object>
                public static class: java.lang.Class<any>
            }
            abstract class AbstractFileSystemProvider extends java.nio.file.spi.FileSystemProvider {
                protected constructor()
                public setAttribute(arg0: java.nio.file.Path, arg1: java.lang.String | string, arg2: java.lang.Object, ...arg3: java.nio.file.LinkOption[]): void
                public readAttributes(arg0: java.nio.file.Path, arg1: java.lang.String | string, ...arg2: java.nio.file.LinkOption[]): java.util.Map<java.lang.String, java.lang.Object>
                public delete(arg0: java.nio.file.Path): void
                public deleteIfExists(arg0: java.nio.file.Path): boolean
                public static class: java.lang.Class<any>
            }
            abstract class AbstractFileTypeDetector extends java.nio.file.spi.FileTypeDetector {
                protected constructor()
                public probeContentType(arg0: java.nio.file.Path): string
                protected implProbeContentType(arg0: java.nio.file.Path): string
                public static class: java.lang.Class<any>
            }
            abstract class AbstractPoller implements java.lang.Runnable {
                protected constructor()
                public start(): void
                public static class: java.lang.Class<any>
            }
            abstract class AbstractPoller$$Lambda implements java.lang.Runnable {
                protected constructor()
            }
            abstract class AbstractUserDefinedFileAttributeView implements java.nio.file.attribute.UserDefinedFileAttributeView , sun.nio.fs.DynamicFileAttributeView {
                protected constructor()
                protected checkAccess(arg0: java.lang.String | string, arg1: boolean, arg2: boolean): void
                public name(): string
                public setAttribute(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public readAttributes(arg0: java.lang.String[]): java.util.Map<java.lang.String, java.lang.Object>
                public static class: java.lang.Class<any>
            }
            abstract class AbstractWatchKey implements java.nio.file.WatchKey {
                protected constructor(arg0: java.nio.file.Path, arg1: sun.nio.fs.AbstractWatchService)
                public watchable(): java.nio.file.Path
                public pollEvents(): java.util.List<java.nio.file.WatchEvent<any>>
                public reset(): boolean
                public watchable(): java.nio.file.Watchable
                public static class: java.lang.Class<any>
            }
            abstract class AbstractWatchService implements java.nio.file.WatchService {
                protected constructor()
                public poll(): java.nio.file.WatchKey
                public poll(arg0: long, arg1: java.util.concurrent.TimeUnit): java.nio.file.WatchKey
                public take(): java.nio.file.WatchKey
                public close(): void
                public static class: java.lang.Class<any>
            }
            interface BasicFileAttributesHolder {
                get(): java.nio.file.attribute.BasicFileAttributes
                invalidate(): void
            }
            abstract class Cancellable implements java.lang.Runnable {
                protected constructor()
                protected addressToPollForCancel(): long
                protected cancelValue(): int
                public run(): void
                public static class: java.lang.Class<any>
            }
            abstract class Cancellable$$Lambda implements java.lang.Runnable {
                protected constructor()
            }
            interface DynamicFileAttributeView {
                setAttribute(arg0: java.lang.String | string, arg1: java.lang.Object): void
                readAttributes(arg0: java.lang.String[]): java.util.Map<java.lang.String, java.lang.Object>
            }
            class FileOwnerAttributeViewImpl implements java.nio.file.attribute.FileOwnerAttributeView , sun.nio.fs.DynamicFileAttributeView {
                public name(): string
                public setAttribute(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public readAttributes(arg0: java.lang.String[]): java.util.Map<java.lang.String, java.lang.Object>
                public getOwner(): java.nio.file.attribute.UserPrincipal
                public setOwner(arg0: java.nio.file.attribute.UserPrincipal): void
                public static class: java.lang.Class<any>
            }
            class Globs {
                public static class: java.lang.Class<any>
            }
            class NativeBuffer {
                public static class: java.lang.Class<any>
            }
            class NativeBuffers {
                public static class: java.lang.Class<any>
            }
            class Reflect {
                public static class: java.lang.Class<any>
            }
            class Util {
                public static class: java.lang.Class<any>
            }
        }
        interface ByteBuffered {
            getByteBuffer(): java.nio.ByteBuffer
        }
        interface ByteBuffered$$Lambda {
            (): java.nio.ByteBuffer
        }
    }
    namespace reflect {
        namespace annotation {
            class AnnotatedTypeFactory {
                public constructor()
                public static buildAnnotatedType(arg0: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda, arg1: sun.reflect.annotation.TypeAnnotation$LocationInfo, arg2: sun.reflect.annotation.TypeAnnotation[], arg3: sun.reflect.annotation.TypeAnnotation[], arg4: java.lang.reflect.AnnotatedElement): java.lang.reflect.AnnotatedType
                public static class: java.lang.Class<any>
            }
            class AnnotationInvocationHandler implements java.lang.reflect.InvocationHandler , java.io.Serializable {
                public invoke(arg0: java.lang.Object, arg1: java.lang.reflect.Method, arg2: java.lang.Object[]): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class AnnotationParser {
                public constructor()
                public static parseAnnotations(arg0: byte[], arg1: sun.reflect.ConstantPool, arg2: java.lang.Class<any>): java.util.Map<java.lang.Class<java.lang.annotation.Annotation>, java.lang.annotation.Annotation>
                public static parseParameterAnnotations(arg0: byte[], arg1: sun.reflect.ConstantPool, arg2: java.lang.Class<any>): java.lang.annotation.Annotation[][]
                public static annotationForMap(arg0: java.lang.Class<java.lang.annotation.Annotation>, arg1: java.util.Map<java.lang.String, java.lang.Object>): java.lang.annotation.Annotation
                public static parseMemberValue(arg0: java.lang.Class<any>, arg1: java.nio.ByteBuffer, arg2: sun.reflect.ConstantPool, arg3: java.lang.Class<any>): java.lang.Object
                public static toArray(arg0: java.util.Map<java.lang.Class<java.lang.annotation.Annotation>, java.lang.annotation.Annotation>): java.lang.annotation.Annotation[]
                public static class: java.lang.Class<any>
            }
            class AnnotationSupport {
                public constructor()
                public static getDirectlyAndIndirectlyPresent<A extends java.lang.annotation.Annotation>(arg0: java.util.Map<java.lang.Class<java.lang.annotation.Annotation>, java.lang.annotation.Annotation>, arg1: java.lang.Class<A>): A[]
                public static getAssociatedAnnotations<A extends java.lang.annotation.Annotation>(arg0: java.util.Map<java.lang.Class<java.lang.annotation.Annotation>, java.lang.annotation.Annotation>, arg1: java.lang.Class<any>, arg2: java.lang.Class<A>): A[]
                public static class: java.lang.Class<any>
            }
            class AnnotationType {
                public static getInstance(arg0: java.lang.Class<java.lang.annotation.Annotation>): sun.reflect.annotation.AnnotationType
                public static invocationHandlerReturnType(arg0: java.lang.Class<any>): java.lang.Class<any>
                public memberTypes(): java.util.Map<java.lang.String, java.lang.Class<any>>
                public members(): java.util.Map<java.lang.String, java.lang.reflect.Method>
                public memberDefaults(): java.util.Map<java.lang.String, java.lang.Object>
                public retention(): java.lang.annotation.RetentionPolicy
                public isInherited(): boolean
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class AnnotationTypeMismatchExceptionProxy extends sun.reflect.annotation.ExceptionProxy {
                protected generateException(): java.lang.RuntimeException
                public static class: java.lang.Class<any>
            }
            class EnumConstantNotPresentExceptionProxy extends sun.reflect.annotation.ExceptionProxy {
                public constructor(arg0: java.lang.Class<java.lang.Enum<any>>, arg1: java.lang.String | string)
                protected generateException(): java.lang.RuntimeException
                public static class: java.lang.Class<any>
            }
            abstract class ExceptionProxy implements java.io.Serializable {
                public constructor()
                protected generateException(): java.lang.RuntimeException
                public static class: java.lang.Class<any>
            }
            class TypeAnnotation {
                public constructor(arg0: sun.reflect.annotation.TypeAnnotation$TypeAnnotationTargetInfo, arg1: sun.reflect.annotation.TypeAnnotation$LocationInfo, arg2: java.lang.annotation.Annotation, arg3: java.lang.reflect.AnnotatedElement)
                public getTargetInfo(): sun.reflect.annotation.TypeAnnotation$TypeAnnotationTargetInfo
                public getAnnotation(): java.lang.annotation.Annotation
                public getBaseDeclaration(): java.lang.reflect.AnnotatedElement
                public getLocationInfo(): sun.reflect.annotation.TypeAnnotation$LocationInfo
                public static filter(arg0: sun.reflect.annotation.TypeAnnotation[], arg1: sun.reflect.annotation.TypeAnnotation$TypeAnnotationTarget): java.util.List<sun.reflect.annotation.TypeAnnotation>
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class TypeAnnotationParser {
                public constructor()
                public static buildAnnotatedType(arg0: byte[], arg1: sun.reflect.ConstantPool, arg2: java.lang.reflect.AnnotatedElement, arg3: java.lang.Class<any>, arg4: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda, arg5: sun.reflect.annotation.TypeAnnotation$TypeAnnotationTarget): java.lang.reflect.AnnotatedType
                public static buildAnnotatedTypes(arg0: byte[], arg1: sun.reflect.ConstantPool, arg2: java.lang.reflect.AnnotatedElement, arg3: java.lang.Class<any>, arg4: java.lang.reflect.Type[], arg5: sun.reflect.annotation.TypeAnnotation$TypeAnnotationTarget): java.lang.reflect.AnnotatedType[]
                public static buildAnnotatedSuperclass(arg0: byte[], arg1: sun.reflect.ConstantPool, arg2: java.lang.Class<any>): java.lang.reflect.AnnotatedType
                public static buildAnnotatedInterfaces(arg0: byte[], arg1: sun.reflect.ConstantPool, arg2: java.lang.Class<any>): java.lang.reflect.AnnotatedType[]
                public static parseTypeVariableAnnotations<D extends java.lang.reflect.GenericDeclaration>(arg0: D, arg1: int): java.lang.annotation.Annotation[]
                public static parseAnnotatedBounds<D extends java.lang.reflect.GenericDeclaration>(arg0: java.lang.reflect.Type[], arg1: D, arg2: int): java.lang.reflect.AnnotatedType[]
                public static class: java.lang.Class<any>
            }
            class TypeNotPresentExceptionProxy extends sun.reflect.annotation.ExceptionProxy {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                protected generateException(): java.lang.RuntimeException
                public static class: java.lang.Class<any>
            }
        }
        namespace generics {
            namespace factory {
                class CoreReflectionFactory implements sun.reflect.generics.factory.GenericsFactory {
                    public static make(arg0: java.lang.reflect.GenericDeclaration, arg1: sun.reflect.generics.scope.Scope | sun.reflect.generics.scope.Scope$$Lambda): sun.reflect.generics.factory.CoreReflectionFactory
                    public makeTypeVariable(arg0: java.lang.String | string, arg1: sun.reflect.generics.tree.FieldTypeSignature[]): java.lang.reflect.TypeVariable<any>
                    public makeWildcard(arg0: sun.reflect.generics.tree.FieldTypeSignature[], arg1: sun.reflect.generics.tree.FieldTypeSignature[]): java.lang.reflect.WildcardType
                    public makeParameterizedType(arg0: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda, arg1: java.lang.reflect.Type[], arg2: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda): java.lang.reflect.ParameterizedType
                    public findTypeVariable(arg0: java.lang.String | string): java.lang.reflect.TypeVariable<any>
                    public makeNamedType(arg0: java.lang.String | string): java.lang.reflect.Type
                    public makeArrayType(arg0: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda): java.lang.reflect.Type
                    public makeByte(): java.lang.reflect.Type
                    public makeBool(): java.lang.reflect.Type
                    public makeShort(): java.lang.reflect.Type
                    public makeChar(): java.lang.reflect.Type
                    public makeInt(): java.lang.reflect.Type
                    public makeLong(): java.lang.reflect.Type
                    public makeFloat(): java.lang.reflect.Type
                    public makeDouble(): java.lang.reflect.Type
                    public makeVoid(): java.lang.reflect.Type
                    public static class: java.lang.Class<any>
                }
                interface GenericsFactory {
                    makeTypeVariable(arg0: java.lang.String | string, arg1: sun.reflect.generics.tree.FieldTypeSignature[]): java.lang.reflect.TypeVariable<any>
                    makeParameterizedType(arg0: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda, arg1: java.lang.reflect.Type[], arg2: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda): java.lang.reflect.ParameterizedType
                    findTypeVariable(arg0: java.lang.String | string): java.lang.reflect.TypeVariable<any>
                    makeWildcard(arg0: sun.reflect.generics.tree.FieldTypeSignature[], arg1: sun.reflect.generics.tree.FieldTypeSignature[]): java.lang.reflect.WildcardType
                    makeNamedType(arg0: java.lang.String | string): java.lang.reflect.Type
                    makeArrayType(arg0: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda): java.lang.reflect.Type
                    makeByte(): java.lang.reflect.Type
                    makeBool(): java.lang.reflect.Type
                    makeShort(): java.lang.reflect.Type
                    makeChar(): java.lang.reflect.Type
                    makeInt(): java.lang.reflect.Type
                    makeLong(): java.lang.reflect.Type
                    makeFloat(): java.lang.reflect.Type
                    makeDouble(): java.lang.reflect.Type
                    makeVoid(): java.lang.reflect.Type
                }
            }
            namespace parser {
                class SignatureParser {
                    public static make(): sun.reflect.generics.parser.SignatureParser
                    public parseClassSig(arg0: java.lang.String | string): sun.reflect.generics.tree.ClassSignature
                    public parseMethodSig(arg0: java.lang.String | string): sun.reflect.generics.tree.MethodTypeSignature
                    public parseTypeSig(arg0: java.lang.String | string): sun.reflect.generics.tree.TypeSignature
                    public static class: java.lang.Class<any>
                }
            }
            namespace reflectiveObjects {
                class GenericArrayTypeImpl implements java.lang.reflect.GenericArrayType {
                    public static make(arg0: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda): sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl
                    public getGenericComponentType(): java.lang.reflect.Type
                    public toString(): string
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public static class: java.lang.Class<any>
                }
                abstract class LazyReflectiveObjectGenerator {
                    protected constructor(arg0: sun.reflect.generics.factory.GenericsFactory)
                    protected getReifier(): sun.reflect.generics.visitor.Reifier
                    public static class: java.lang.Class<any>
                }
                class NotImplementedException extends java.lang.RuntimeException {
                    public constructor()
                    public static class: java.lang.Class<any>
                }
                class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType {
                    public static make(arg0: java.lang.Class<any>, arg1: java.lang.reflect.Type[], arg2: java.lang.reflect.Type | java.lang.reflect.Type$$Lambda): sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl
                    public getActualTypeArguments(): java.lang.reflect.Type[]
                    public getRawType(): java.lang.Class<any>
                    public getOwnerType(): java.lang.reflect.Type
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public toString(): string
                    public getRawType(): java.lang.reflect.Type
                    public static class: java.lang.Class<any>
                }
                class TypeVariableImpl<D extends java.lang.reflect.GenericDeclaration> extends sun.reflect.generics.reflectiveObjects.LazyReflectiveObjectGenerator implements java.lang.reflect.TypeVariable<D> {
                    public static make<T extends java.lang.reflect.GenericDeclaration>(arg0: T, arg1: java.lang.String | string, arg2: sun.reflect.generics.tree.FieldTypeSignature[], arg3: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.reflectiveObjects.TypeVariableImpl<T>
                    public getBounds(): java.lang.reflect.Type[]
                    public getGenericDeclaration(): D
                    public getName(): string
                    public toString(): string
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public getAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                    public getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T
                    public getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                    public getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: java.lang.Class<T>): T[]
                    public getAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                    public getDeclaredAnnotations<T extends java.lang.annotation.Annotation>(): java.lang.annotation.Annotation[]
                    public getAnnotatedBounds<T extends java.lang.annotation.Annotation>(): java.lang.reflect.AnnotatedType[]
                    public static class: java.lang.Class<any>
                }
                class WildcardTypeImpl extends sun.reflect.generics.reflectiveObjects.LazyReflectiveObjectGenerator implements java.lang.reflect.WildcardType {
                    public static make(arg0: sun.reflect.generics.tree.FieldTypeSignature[], arg1: sun.reflect.generics.tree.FieldTypeSignature[], arg2: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.reflectiveObjects.WildcardTypeImpl
                    public getUpperBounds(): java.lang.reflect.Type[]
                    public getLowerBounds(): java.lang.reflect.Type[]
                    public toString(): string
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public static class: java.lang.Class<any>
                }
            }
            namespace repository {
                abstract class AbstractRepository<T extends sun.reflect.generics.tree.Tree> {
                    protected getTree(): T
                    protected getReifier(): sun.reflect.generics.visitor.Reifier
                    protected constructor(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory)
                    protected parse(arg0: java.lang.String | string): T
                    public static class: java.lang.Class<any>
                }
                class ClassRepository extends sun.reflect.generics.repository.GenericDeclRepository<sun.reflect.generics.tree.ClassSignature> {
                    public static NONE: sun.reflect.generics.repository.ClassRepository
                    protected parse(arg0: java.lang.String | string): sun.reflect.generics.tree.ClassSignature
                    public static make(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.repository.ClassRepository
                    public getSuperclass(): java.lang.reflect.Type
                    public getSuperInterfaces(): java.lang.reflect.Type[]
                    protected parse(arg0: java.lang.String | string): sun.reflect.generics.tree.Tree
                    public static class: java.lang.Class<any>
                }
                class ConstructorRepository extends sun.reflect.generics.repository.GenericDeclRepository<sun.reflect.generics.tree.MethodTypeSignature> {
                    protected constructor(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory)
                    protected parse(arg0: java.lang.String | string): sun.reflect.generics.tree.MethodTypeSignature
                    public static make(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.repository.ConstructorRepository
                    public getParameterTypes(): java.lang.reflect.Type[]
                    public getExceptionTypes(): java.lang.reflect.Type[]
                    protected parse(arg0: java.lang.String | string): sun.reflect.generics.tree.Tree
                    public static class: java.lang.Class<any>
                }
                class FieldRepository extends sun.reflect.generics.repository.AbstractRepository<sun.reflect.generics.tree.TypeSignature> {
                    protected constructor(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory)
                    protected parse(arg0: java.lang.String | string): sun.reflect.generics.tree.TypeSignature
                    public static make(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.repository.FieldRepository
                    public getGenericType(): java.lang.reflect.Type
                    protected parse(arg0: java.lang.String | string): sun.reflect.generics.tree.Tree
                    public static class: java.lang.Class<any>
                }
                abstract class GenericDeclRepository<S extends sun.reflect.generics.tree.Signature> extends sun.reflect.generics.repository.AbstractRepository<S> {
                    protected constructor(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory)
                    public getTypeParameters(): java.lang.reflect.TypeVariable<any>[]
                    public static class: java.lang.Class<any>
                }
                class MethodRepository extends sun.reflect.generics.repository.ConstructorRepository {
                    public static make(arg0: java.lang.String | string, arg1: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.repository.MethodRepository
                    public getReturnType(): java.lang.reflect.Type
                    public static class: java.lang.Class<any>
                }
            }
            namespace scope {
                abstract class AbstractScope<D extends java.lang.reflect.GenericDeclaration> implements sun.reflect.generics.scope.Scope {
                    protected constructor(arg0: D)
                    protected getRecvr(): D
                    protected computeEnclosingScope(): sun.reflect.generics.scope.Scope
                    protected getEnclosingScope(): sun.reflect.generics.scope.Scope
                    public lookup(arg0: java.lang.String | string): java.lang.reflect.TypeVariable<any>
                    public static class: java.lang.Class<any>
                }
                abstract class AbstractScope$$Lambda<D extends java.lang.reflect.GenericDeclaration> implements sun.reflect.generics.scope.Scope {
                    protected constructor(arg0: D)
                }
                class ClassScope extends sun.reflect.generics.scope.AbstractScope<java.lang.Class<any>> implements sun.reflect.generics.scope.Scope {
                    protected computeEnclosingScope(): sun.reflect.generics.scope.Scope
                    public static make(arg0: java.lang.Class<any>): sun.reflect.generics.scope.ClassScope
                    public static class: java.lang.Class<any>
                }
                class ClassScope$$Lambda extends sun.reflect.generics.scope.AbstractScope<java.lang.Class<any>> implements sun.reflect.generics.scope.Scope {
                    protected (): sun.reflect.generics.scope.Scope
                }
                class ConstructorScope extends sun.reflect.generics.scope.AbstractScope<java.lang.reflect.Constructor<any>> {
                    protected computeEnclosingScope(): sun.reflect.generics.scope.Scope
                    public static make(arg0: java.lang.reflect.Constructor<any>): sun.reflect.generics.scope.ConstructorScope
                    public static class: java.lang.Class<any>
                }
                class DummyScope implements sun.reflect.generics.scope.Scope {
                    public static make(): sun.reflect.generics.scope.DummyScope
                    public lookup(arg0: java.lang.String | string): java.lang.reflect.TypeVariable<any>
                    public static class: java.lang.Class<any>
                }
                class DummyScope$$Lambda implements sun.reflect.generics.scope.Scope {
                    public static (): sun.reflect.generics.scope.DummyScope
                }
                class MethodScope extends sun.reflect.generics.scope.AbstractScope<java.lang.reflect.Method> {
                    protected computeEnclosingScope(): sun.reflect.generics.scope.Scope
                    public static make(arg0: java.lang.reflect.Method): sun.reflect.generics.scope.MethodScope
                    public static class: java.lang.Class<any>
                }
                interface Scope {
                    lookup(arg0: java.lang.String | string): java.lang.reflect.TypeVariable<any>
                }
                interface Scope$$Lambda {
                    (arg0: java.lang.String | string): java.lang.reflect.TypeVariable<any>
                }
            }
            namespace tree {
                class ArrayTypeSignature implements sun.reflect.generics.tree.FieldTypeSignature {
                    public static make(arg0: sun.reflect.generics.tree.TypeSignature): sun.reflect.generics.tree.ArrayTypeSignature
                    public getComponentType(): sun.reflect.generics.tree.TypeSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                interface BaseType extends sun.reflect.generics.tree.TypeSignature {
                }
                class BooleanSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.BooleanSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class BottomSignature implements sun.reflect.generics.tree.FieldTypeSignature {
                    public static make(): sun.reflect.generics.tree.BottomSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class ByteSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.ByteSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class CharSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.CharSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class ClassSignature implements sun.reflect.generics.tree.Signature {
                    public static make(arg0: sun.reflect.generics.tree.FormalTypeParameter[], arg1: sun.reflect.generics.tree.ClassTypeSignature, arg2: sun.reflect.generics.tree.ClassTypeSignature[]): sun.reflect.generics.tree.ClassSignature
                    public getFormalTypeParameters(): sun.reflect.generics.tree.FormalTypeParameter[]
                    public getSuperclass(): sun.reflect.generics.tree.ClassTypeSignature
                    public getSuperInterfaces(): sun.reflect.generics.tree.ClassTypeSignature[]
                    public accept(arg0: sun.reflect.generics.visitor.Visitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class ClassTypeSignature implements sun.reflect.generics.tree.FieldTypeSignature {
                    public static make(arg0: java.util.List<sun.reflect.generics.tree.SimpleClassTypeSignature>): sun.reflect.generics.tree.ClassTypeSignature
                    public getPath(): java.util.List<sun.reflect.generics.tree.SimpleClassTypeSignature>
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class DoubleSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.DoubleSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                interface FieldTypeSignature extends sun.reflect.generics.tree.BaseType , sun.reflect.generics.tree.TypeSignature , sun.reflect.generics.tree.TypeArgument {
                }
                class FloatSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.FloatSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class FormalTypeParameter implements sun.reflect.generics.tree.TypeTree {
                    public static make(arg0: java.lang.String | string, arg1: sun.reflect.generics.tree.FieldTypeSignature[]): sun.reflect.generics.tree.FormalTypeParameter
                    public getBounds(): sun.reflect.generics.tree.FieldTypeSignature[]
                    public getName(): string
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class IntSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.IntSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class LongSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.LongSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class MethodTypeSignature implements sun.reflect.generics.tree.Signature {
                    public static make(arg0: sun.reflect.generics.tree.FormalTypeParameter[], arg1: sun.reflect.generics.tree.TypeSignature[], arg2: sun.reflect.generics.tree.ReturnType, arg3: sun.reflect.generics.tree.FieldTypeSignature[]): sun.reflect.generics.tree.MethodTypeSignature
                    public getFormalTypeParameters(): sun.reflect.generics.tree.FormalTypeParameter[]
                    public getParameterTypes(): sun.reflect.generics.tree.TypeSignature[]
                    public getReturnType(): sun.reflect.generics.tree.ReturnType
                    public getExceptionTypes(): sun.reflect.generics.tree.FieldTypeSignature[]
                    public accept(arg0: sun.reflect.generics.visitor.Visitor<any>): void
                    public static class: java.lang.Class<any>
                }
                interface ReturnType extends sun.reflect.generics.tree.TypeTree {
                }
                class ShortSignature implements sun.reflect.generics.tree.BaseType {
                    public static make(): sun.reflect.generics.tree.ShortSignature
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                interface Signature extends sun.reflect.generics.tree.Tree {
                    getFormalTypeParameters(): sun.reflect.generics.tree.FormalTypeParameter[]
                }
                class SimpleClassTypeSignature implements sun.reflect.generics.tree.FieldTypeSignature {
                    public static make(arg0: java.lang.String | string, arg1: boolean, arg2: sun.reflect.generics.tree.TypeArgument[]): sun.reflect.generics.tree.SimpleClassTypeSignature
                    public getDollar(): boolean
                    public getName(): string
                    public getTypeArguments(): sun.reflect.generics.tree.TypeArgument[]
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                interface Tree {
                }
                interface TypeArgument extends sun.reflect.generics.tree.TypeTree {
                }
                interface TypeSignature extends sun.reflect.generics.tree.ReturnType {
                }
                interface TypeTree extends sun.reflect.generics.tree.Tree {
                    accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                }
                class TypeVariableSignature implements sun.reflect.generics.tree.FieldTypeSignature {
                    public static make(arg0: java.lang.String | string): sun.reflect.generics.tree.TypeVariableSignature
                    public getIdentifier(): string
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class VoidDescriptor implements sun.reflect.generics.tree.ReturnType {
                    public static make(): sun.reflect.generics.tree.VoidDescriptor
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
                class Wildcard implements sun.reflect.generics.tree.TypeArgument {
                    public static make(arg0: sun.reflect.generics.tree.FieldTypeSignature[], arg1: sun.reflect.generics.tree.FieldTypeSignature[]): sun.reflect.generics.tree.Wildcard
                    public getUpperBounds(): sun.reflect.generics.tree.FieldTypeSignature[]
                    public getLowerBounds(): sun.reflect.generics.tree.FieldTypeSignature[]
                    public accept(arg0: sun.reflect.generics.visitor.TypeTreeVisitor<any>): void
                    public static class: java.lang.Class<any>
                }
            }
            namespace visitor {
                class Reifier implements sun.reflect.generics.visitor.TypeTreeVisitor<java.lang.reflect.Type> {
                    public static make(arg0: sun.reflect.generics.factory.GenericsFactory): sun.reflect.generics.visitor.Reifier
                    public getResult(): java.lang.reflect.Type
                    public visitFormalTypeParameter(arg0: sun.reflect.generics.tree.FormalTypeParameter): void
                    public visitClassTypeSignature(arg0: sun.reflect.generics.tree.ClassTypeSignature): void
                    public visitArrayTypeSignature(arg0: sun.reflect.generics.tree.ArrayTypeSignature): void
                    public visitTypeVariableSignature(arg0: sun.reflect.generics.tree.TypeVariableSignature): void
                    public visitWildcard(arg0: sun.reflect.generics.tree.Wildcard): void
                    public visitSimpleClassTypeSignature(arg0: sun.reflect.generics.tree.SimpleClassTypeSignature): void
                    public visitBottomSignature(arg0: sun.reflect.generics.tree.BottomSignature): void
                    public visitByteSignature(arg0: sun.reflect.generics.tree.ByteSignature): void
                    public visitBooleanSignature(arg0: sun.reflect.generics.tree.BooleanSignature): void
                    public visitShortSignature(arg0: sun.reflect.generics.tree.ShortSignature): void
                    public visitCharSignature(arg0: sun.reflect.generics.tree.CharSignature): void
                    public visitIntSignature(arg0: sun.reflect.generics.tree.IntSignature): void
                    public visitLongSignature(arg0: sun.reflect.generics.tree.LongSignature): void
                    public visitFloatSignature(arg0: sun.reflect.generics.tree.FloatSignature): void
                    public visitDoubleSignature(arg0: sun.reflect.generics.tree.DoubleSignature): void
                    public visitVoidDescriptor(arg0: sun.reflect.generics.tree.VoidDescriptor): void
                    public getResult(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                interface TypeTreeVisitor<T> {
                    getResult(): T
                    visitFormalTypeParameter(arg0: sun.reflect.generics.tree.FormalTypeParameter): void
                    visitClassTypeSignature(arg0: sun.reflect.generics.tree.ClassTypeSignature): void
                    visitArrayTypeSignature(arg0: sun.reflect.generics.tree.ArrayTypeSignature): void
                    visitTypeVariableSignature(arg0: sun.reflect.generics.tree.TypeVariableSignature): void
                    visitWildcard(arg0: sun.reflect.generics.tree.Wildcard): void
                    visitSimpleClassTypeSignature(arg0: sun.reflect.generics.tree.SimpleClassTypeSignature): void
                    visitBottomSignature(arg0: sun.reflect.generics.tree.BottomSignature): void
                    visitByteSignature(arg0: sun.reflect.generics.tree.ByteSignature): void
                    visitBooleanSignature(arg0: sun.reflect.generics.tree.BooleanSignature): void
                    visitShortSignature(arg0: sun.reflect.generics.tree.ShortSignature): void
                    visitCharSignature(arg0: sun.reflect.generics.tree.CharSignature): void
                    visitIntSignature(arg0: sun.reflect.generics.tree.IntSignature): void
                    visitLongSignature(arg0: sun.reflect.generics.tree.LongSignature): void
                    visitFloatSignature(arg0: sun.reflect.generics.tree.FloatSignature): void
                    visitDoubleSignature(arg0: sun.reflect.generics.tree.DoubleSignature): void
                    visitVoidDescriptor(arg0: sun.reflect.generics.tree.VoidDescriptor): void
                }
                interface Visitor<T> extends sun.reflect.generics.visitor.TypeTreeVisitor<T> {
                    visitClassSignature(arg0: sun.reflect.generics.tree.ClassSignature): void
                    visitMethodTypeSignature(arg0: sun.reflect.generics.tree.MethodTypeSignature): void
                }
            }
        }
        namespace misc {
            class ConstructorUtil {
                public static getConstructor(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>[]): java.lang.reflect.Constructor<any>
                public static getConstructors(arg0: java.lang.Class<any>): java.lang.reflect.Constructor<any>[]
                public static class: java.lang.Class<any>
            }
            class FieldUtil {
                public static getField(arg0: java.lang.Class<any>, arg1: java.lang.String | string): java.lang.reflect.Field
                public static getFields(arg0: java.lang.Class<any>): java.lang.reflect.Field[]
                public static getDeclaredFields(arg0: java.lang.Class<any>): java.lang.reflect.Field[]
                public static class: java.lang.Class<any>
            }
            class MethodUtil extends java.security.SecureClassLoader {
                public static getMethod(arg0: java.lang.Class<any>, arg1: java.lang.String | string, arg2: java.lang.Class<any>[]): java.lang.reflect.Method
                public static getMethods(arg0: java.lang.Class<any>): java.lang.reflect.Method[]
                public static getPublicMethods(arg0: java.lang.Class<any>): java.lang.reflect.Method[]
                public static invoke(arg0: java.lang.reflect.Method, arg1: java.lang.Object, arg2: java.lang.Object[]): java.lang.Object
                protected loadClass(arg0: java.lang.String | string, arg1: boolean): java.lang.Class<any>
                protected findClass(arg0: java.lang.String | string): java.lang.Class<any>
                protected getPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
                public static class: java.lang.Class<any>
            }
            class ReflectUtil {
                public static PROXY_PACKAGE: string
                public static forName(arg0: java.lang.String | string): java.lang.Class<any>
                public static newInstance(arg0: java.lang.Class<any>): java.lang.Object
                public static ensureMemberAccess(arg0: java.lang.Class<any>, arg1: java.lang.Class<any>, arg2: java.lang.Object, arg3: int): void
                public static conservativeCheckMemberAccess(arg0: java.lang.reflect.Member): void
                public static checkPackageAccess(arg0: java.lang.Class<any>): void
                public static checkPackageAccess(arg0: java.lang.String | string): void
                public static isPackageAccessible(arg0: java.lang.Class<any>): boolean
                public static needsPackageAccessCheck(arg0: java.lang.ClassLoader, arg1: java.lang.ClassLoader): boolean
                public static checkProxyPackageAccess(arg0: java.lang.Class<any>): void
                public static checkProxyPackageAccess(arg0: java.lang.ClassLoader, ...arg1: java.lang.Class<any>[]): void
                public static isNonPublicProxyClass(arg0: java.lang.Class<any>): boolean
                public static checkProxyMethod(arg0: java.lang.Object, arg1: java.lang.reflect.Method): void
                public static isVMAnonymousClass(arg0: java.lang.Class<any>): boolean
                public static class: java.lang.Class<any>
            }
        }
    }
    namespace security {
        namespace action {
            class GetBooleanAction implements java.security.PrivilegedAction<java.lang.Boolean> {
                public constructor(arg0: java.lang.String | string)
                public run(): boolean
                public run(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class GetIntegerAction implements java.security.PrivilegedAction<java.lang.Integer> {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: int)
                public run(): java.lang.Integer
                public run(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class GetLongAction implements java.security.PrivilegedAction<java.lang.Long> {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: long)
                public run(): java.lang.Long
                public run(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class GetPropertyAction implements java.security.PrivilegedAction<java.lang.String> {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public run(): string
                public static privilegedGetProperty(arg0: java.lang.String | string): string
                public run(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class OpenFileInputStreamAction implements java.security.PrivilegedExceptionAction<java.io.FileInputStream> {
                public constructor(arg0: java.io.File)
                public constructor(arg0: java.lang.String | string)
                public run(): java.io.FileInputStream
                public run(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class PutAllAction implements java.security.PrivilegedAction<java.lang.Void> {
                public constructor(arg0: java.security.Provider, arg1: java.util.Map<any, any>)
                public run(): java.lang.Void
                public run(): java.lang.Object
                public static class: java.lang.Class<any>
            }
        }
        namespace internal {
            namespace interfaces {
                interface TlsMasterSecret extends javax.crypto.SecretKey {
                    serialVersionUID: long
                    getMajorVersion(): int
                    getMinorVersion(): int
                }
            }
            namespace spec {
                class TlsKeyMaterialParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                    public constructor(arg0: javax.crypto.SecretKey, arg1: int, arg2: int, arg3: byte[], arg4: byte[], arg5: java.lang.String | string, arg6: int, arg7: int, arg8: int, arg9: int, arg10: java.lang.String | string, arg11: int, arg12: int)
                    public getMasterSecret(): javax.crypto.SecretKey
                    public getMajorVersion(): int
                    public getMinorVersion(): int
                    public getClientRandom(): byte[]
                    public getServerRandom(): byte[]
                    public getCipherAlgorithm(): string
                    public getCipherKeyLength(): int
                    public getExpandedCipherKeyLength(): int
                    public getIvLength(): int
                    public getMacKeyLength(): int
                    public getPRFHashAlg(): string
                    public getPRFHashLength(): int
                    public getPRFBlockSize(): int
                    public static class: java.lang.Class<any>
                }
                class TlsKeyMaterialSpec implements java.security.spec.KeySpec , javax.crypto.SecretKey {
                    public constructor(arg0: javax.crypto.SecretKey, arg1: javax.crypto.SecretKey)
                    public constructor(arg0: javax.crypto.SecretKey, arg1: javax.crypto.SecretKey, arg2: javax.crypto.SecretKey, arg3: javax.crypto.SecretKey)
                    public constructor(arg0: javax.crypto.SecretKey, arg1: javax.crypto.SecretKey, arg2: javax.crypto.SecretKey, arg3: javax.crypto.spec.IvParameterSpec, arg4: javax.crypto.SecretKey, arg5: javax.crypto.spec.IvParameterSpec)
                    public getAlgorithm(): string
                    public getFormat(): string
                    public getEncoded(): byte[]
                    public getClientMacKey(): javax.crypto.SecretKey
                    public getServerMacKey(): javax.crypto.SecretKey
                    public getClientCipherKey(): javax.crypto.SecretKey
                    public getClientIv(): javax.crypto.spec.IvParameterSpec
                    public getServerCipherKey(): javax.crypto.SecretKey
                    public getServerIv(): javax.crypto.spec.IvParameterSpec
                    public static class: java.lang.Class<any>
                }
                class TlsMasterSecretParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                    public constructor(arg0: javax.crypto.SecretKey, arg1: int, arg2: int, arg3: byte[], arg4: byte[], arg5: java.lang.String | string, arg6: int, arg7: int)
                    public constructor(arg0: javax.crypto.SecretKey, arg1: int, arg2: int, arg3: byte[], arg4: java.lang.String | string, arg5: int, arg6: int)
                    public getPremasterSecret(): javax.crypto.SecretKey
                    public getMajorVersion(): int
                    public getMinorVersion(): int
                    public getClientRandom(): byte[]
                    public getServerRandom(): byte[]
                    public getExtendedMasterSecretSessionHash(): byte[]
                    public getPRFHashAlg(): string
                    public getPRFHashLength(): int
                    public getPRFBlockSize(): int
                    public static class: java.lang.Class<any>
                }
                class TlsPrfParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                    public constructor(arg0: javax.crypto.SecretKey, arg1: java.lang.String | string, arg2: byte[], arg3: int, arg4: java.lang.String | string, arg5: int, arg6: int)
                    public getSecret(): javax.crypto.SecretKey
                    public getLabel(): string
                    public getSeed(): byte[]
                    public getOutputLength(): int
                    public getPRFHashAlg(): string
                    public getPRFHashLength(): int
                    public getPRFBlockSize(): int
                    public static class: java.lang.Class<any>
                }
                class TlsRsaPremasterSecretParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                    public constructor(arg0: int, arg1: int)
                    public constructor(arg0: int, arg1: int, arg2: byte[])
                    public getClientVersion(): int
                    public getServerVersion(): int
                    public getMajorVersion(): int
                    public getMinorVersion(): int
                    public getEncodedSecret(): byte[]
                    public static class: java.lang.Class<any>
                }
            }
        }
        namespace jca {
            class GetInstance {
                public static getService(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.Provider$Service
                public static getService(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string): java.security.Provider$Service
                public static getService(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.security.Provider): java.security.Provider$Service
                public static getServices(arg0: java.lang.String | string, arg1: java.lang.String | string): java.util.List<java.security.Provider$Service>
                public static getServices(arg0: java.lang.String | string, arg1: java.util.List<java.lang.String>): java.util.List<java.security.Provider$Service>
                public static getServices(arg0: java.util.List<sun.security.jca.ServiceId>): java.util.List<java.security.Provider$Service>
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: java.lang.String | string): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: java.lang.String | string, arg3: java.lang.Object): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: java.lang.String | string, arg3: java.lang.String | string): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: java.lang.String | string, arg3: java.lang.Object, arg4: java.lang.String | string): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: java.lang.String | string, arg3: java.security.Provider): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.Class<any>, arg2: java.lang.String | string, arg3: java.lang.Object, arg4: java.security.Provider): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.security.Provider$Service, arg1: java.lang.Class<any>): sun.security.jca.GetInstance$Instance
                public static getInstance(arg0: java.security.Provider$Service, arg1: java.lang.Class<any>, arg2: java.lang.Object): sun.security.jca.GetInstance$Instance
                public static checkSuperClass(arg0: java.security.Provider$Service, arg1: java.lang.Class<any>, arg2: java.lang.Class<any>): void
                public static class: java.lang.Class<any>
            }
            class JCAUtil {
                public static getTempArraySize(arg0: int): int
                public static getSecureRandom(): java.security.SecureRandom
                public static class: java.lang.Class<any>
            }
            class ProviderConfig {
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class ProviderList {
                public static add(arg0: sun.security.jca.ProviderList, arg1: java.security.Provider): sun.security.jca.ProviderList
                public static insertAt(arg0: sun.security.jca.ProviderList, arg1: java.security.Provider, arg2: int): sun.security.jca.ProviderList
                public static remove(arg0: sun.security.jca.ProviderList, arg1: java.lang.String | string): sun.security.jca.ProviderList
                public static newList(...arg0: java.security.Provider[]): sun.security.jca.ProviderList
                public size(): int
                public providers(): java.util.List<java.security.Provider>
                public getProvider(arg0: java.lang.String | string): java.security.Provider
                public getIndex(arg0: java.lang.String | string): int
                public toArray(): java.security.Provider[]
                public toString(): string
                public getService(arg0: java.lang.String | string, arg1: java.lang.String | string): java.security.Provider$Service
                public getServices(arg0: java.lang.String | string, arg1: java.lang.String | string): java.util.List<java.security.Provider$Service>
                public getServices(arg0: java.lang.String | string, arg1: java.util.List<java.lang.String>): java.util.List<java.security.Provider$Service>
                public getServices(arg0: java.util.List<sun.security.jca.ServiceId>): java.util.List<java.security.Provider$Service>
                public static class: java.lang.Class<any>
            }
            class Providers {
                public static getSunProvider(): java.security.Provider
                public static startJarVerification(): java.lang.Object
                public static stopJarVerification(arg0: java.lang.Object): void
                public static getProviderList(): sun.security.jca.ProviderList
                public static setProviderList(arg0: sun.security.jca.ProviderList): void
                public static getFullProviderList(): sun.security.jca.ProviderList
                public static getThreadProviderList(): sun.security.jca.ProviderList
                public static beginThreadProviderList(arg0: sun.security.jca.ProviderList): sun.security.jca.ProviderList
                public static endThreadProviderList(arg0: sun.security.jca.ProviderList): void
                public static class: java.lang.Class<any>
            }
            class ServiceId {
                public type: string
                public algorithm: string
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
        }
        namespace pkcs {
            class ContentInfo {
                public static PKCS7_OID: sun.security.util.ObjectIdentifier
                public static DATA_OID: sun.security.util.ObjectIdentifier
                public static SIGNED_DATA_OID: sun.security.util.ObjectIdentifier
                public static ENVELOPED_DATA_OID: sun.security.util.ObjectIdentifier
                public static SIGNED_AND_ENVELOPED_DATA_OID: sun.security.util.ObjectIdentifier
                public static DIGESTED_DATA_OID: sun.security.util.ObjectIdentifier
                public static ENCRYPTED_DATA_OID: sun.security.util.ObjectIdentifier
                public static OLD_SIGNED_DATA_OID: sun.security.util.ObjectIdentifier
                public static OLD_DATA_OID: sun.security.util.ObjectIdentifier
                public static NETSCAPE_CERT_SEQUENCE_OID: sun.security.util.ObjectIdentifier
                public static TIMESTAMP_TOKEN_INFO_OID: sun.security.util.ObjectIdentifier
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: sun.security.util.DerValue)
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerInputStream, arg1: boolean)
                public getContent(): sun.security.util.DerValue
                public getContentType(): sun.security.util.ObjectIdentifier
                public getData(): byte[]
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getContentBytes(): byte[]
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class EncryptedPrivateKeyInfo {
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg1: byte[])
                public getAlgorithm(): sun.security.x509.AlgorithmId
                public getEncryptedData(): byte[]
                public getEncoded(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class PKCS7 {
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.x509.AlgorithmId[], arg1: sun.security.pkcs.ContentInfo, arg2: java.security.cert.X509Certificate[], arg3: java.security.cert.X509CRL[], arg4: sun.security.pkcs.SignerInfo[])
                public constructor(arg0: sun.security.x509.AlgorithmId[], arg1: sun.security.pkcs.ContentInfo, arg2: java.security.cert.X509Certificate[], arg3: sun.security.pkcs.SignerInfo[])
                public encodeSignedData(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public encodeSignedData(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public verify(arg0: sun.security.pkcs.SignerInfo | sun.security.pkcs.SignerInfo$$Lambda, arg1: byte[]): sun.security.pkcs.SignerInfo
                public verify(arg0: byte[]): sun.security.pkcs.SignerInfo[]
                public verify(): sun.security.pkcs.SignerInfo[]
                public getVersion(): java.math.BigInteger
                public getDigestAlgorithmIds(): sun.security.x509.AlgorithmId[]
                public getContentInfo(): sun.security.pkcs.ContentInfo
                public getCertificates(): java.security.cert.X509Certificate[]
                public getCRLs(): java.security.cert.X509CRL[]
                public getSignerInfos(): sun.security.pkcs.SignerInfo[]
                public getCertificate(arg0: java.math.BigInteger, arg1: sun.security.x509.X500Name): java.security.cert.X509Certificate
                public toString(): string
                public isOldStyle(): boolean
                public static generateSignedData(arg0: byte[], arg1: java.security.cert.X509Certificate[], arg2: byte[], arg3: java.lang.String | string, arg4: java.net.URI, arg5: java.lang.String | string, arg6: java.lang.String | string): byte[]
                public static class: java.lang.Class<any>
            }
            class PKCS8Key implements java.security.PrivateKey {
                protected algid: sun.security.x509.AlgorithmId
                protected key: byte[]
                protected encodedKey: byte[]
                public static version: java.math.BigInteger
                public constructor()
                public static parse(arg0: sun.security.util.DerValue): sun.security.pkcs.PKCS8Key
                public static parseKey(arg0: sun.security.util.DerValue): java.security.PrivateKey
                protected parseKeyBits(): void
                public getAlgorithm(): string
                public getAlgorithmId(): sun.security.x509.AlgorithmId
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getEncoded(): byte[]
                public getFormat(): string
                public encode(): byte[]
                public decode(arg0: java.io.InputStream): void
                public decode(arg0: byte[]): void
                protected writeReplace(): java.lang.Object
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class PKCS9Attribute implements sun.security.util.DerEncoder {
                public static EMAIL_ADDRESS_OID: sun.security.util.ObjectIdentifier
                public static UNSTRUCTURED_NAME_OID: sun.security.util.ObjectIdentifier
                public static CONTENT_TYPE_OID: sun.security.util.ObjectIdentifier
                public static MESSAGE_DIGEST_OID: sun.security.util.ObjectIdentifier
                public static SIGNING_TIME_OID: sun.security.util.ObjectIdentifier
                public static COUNTERSIGNATURE_OID: sun.security.util.ObjectIdentifier
                public static CHALLENGE_PASSWORD_OID: sun.security.util.ObjectIdentifier
                public static UNSTRUCTURED_ADDRESS_OID: sun.security.util.ObjectIdentifier
                public static EXTENDED_CERTIFICATE_ATTRIBUTES_OID: sun.security.util.ObjectIdentifier
                public static ISSUER_SERIALNUMBER_OID: sun.security.util.ObjectIdentifier
                public static EXTENSION_REQUEST_OID: sun.security.util.ObjectIdentifier
                public static SMIME_CAPABILITY_OID: sun.security.util.ObjectIdentifier
                public static SIGNING_CERTIFICATE_OID: sun.security.util.ObjectIdentifier
                public static SIGNATURE_TIMESTAMP_TOKEN_OID: sun.security.util.ObjectIdentifier
                public static EMAIL_ADDRESS_STR: string
                public static UNSTRUCTURED_NAME_STR: string
                public static CONTENT_TYPE_STR: string
                public static MESSAGE_DIGEST_STR: string
                public static SIGNING_TIME_STR: string
                public static COUNTERSIGNATURE_STR: string
                public static CHALLENGE_PASSWORD_STR: string
                public static UNSTRUCTURED_ADDRESS_STR: string
                public static EXTENDED_CERTIFICATE_ATTRIBUTES_STR: string
                public static ISSUER_SERIALNUMBER_STR: string
                public static EXTENSION_REQUEST_STR: string
                public static SMIME_CAPABILITY_STR: string
                public static SIGNING_CERTIFICATE_STR: string
                public static SIGNATURE_TIMESTAMP_TOKEN_STR: string
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: java.lang.Object)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Object)
                public constructor(arg0: sun.security.util.DerValue)
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public isKnown(): boolean
                public getValue(): java.lang.Object
                public isSingleValued(): boolean
                public getOID(): sun.security.util.ObjectIdentifier
                public getName(): string
                public static getOID(arg0: java.lang.String | string): sun.security.util.ObjectIdentifier
                public static getName(arg0: sun.security.util.ObjectIdentifier): string
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKCS9Attribute$$Lambda implements sun.security.util.DerEncoder {
                public static EMAIL_ADDRESS_OID: sun.security.util.ObjectIdentifier
            }
            class PKCS9Attributes {
                public constructor(arg0: sun.security.util.ObjectIdentifier[], arg1: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerInputStream, arg1: boolean)
                public constructor(arg0: sun.security.pkcs.PKCS9Attribute[])
                public encode(arg0: byte, arg1: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getDerEncoding(): byte[]
                public getAttribute(arg0: sun.security.util.ObjectIdentifier): sun.security.pkcs.PKCS9Attribute
                public getAttribute(arg0: java.lang.String | string): sun.security.pkcs.PKCS9Attribute
                public getAttributes(): sun.security.pkcs.PKCS9Attribute[]
                public getAttributeValue(arg0: sun.security.util.ObjectIdentifier): java.lang.Object
                public getAttributeValue(arg0: java.lang.String | string): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class ParsingException extends java.io.IOException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            class SignerInfo implements sun.security.util.DerEncoder {
                public constructor(arg0: sun.security.x509.X500Name, arg1: java.math.BigInteger, arg2: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg3: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg4: byte[])
                public constructor(arg0: sun.security.x509.X500Name, arg1: java.math.BigInteger, arg2: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg3: sun.security.pkcs.PKCS9Attributes, arg4: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg5: byte[], arg6: sun.security.pkcs.PKCS9Attributes)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerInputStream, arg1: boolean)
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getCertificate(arg0: sun.security.pkcs.PKCS7): java.security.cert.X509Certificate
                public getCertificateChain(arg0: sun.security.pkcs.PKCS7): java.util.ArrayList<java.security.cert.X509Certificate>
                public getVersion(): java.math.BigInteger
                public getIssuerName(): sun.security.x509.X500Name
                public getCertificateSerialNumber(): java.math.BigInteger
                public getDigestAlgorithmId(): sun.security.x509.AlgorithmId
                public getAuthenticatedAttributes(): sun.security.pkcs.PKCS9Attributes
                public getDigestEncryptionAlgorithmId(): sun.security.x509.AlgorithmId
                public getEncryptedDigest(): byte[]
                public getUnauthenticatedAttributes(): sun.security.pkcs.PKCS9Attributes
                public getTsToken(): sun.security.pkcs.PKCS7
                public getTimestamp(): java.security.Timestamp
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SignerInfo$$Lambda implements sun.security.util.DerEncoder {
                public constructor(arg0: sun.security.x509.X500Name, arg1: java.math.BigInteger, arg2: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg3: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda, arg4: byte[])
            }
            class SigningCertificateInfo {
                public constructor(arg0: byte[])
                public toString(): string
                public parse(arg0: byte[]): void
                public static class: java.lang.Class<any>
            }
        }
        namespace pkcs10 {
            class PKCS10 {
                public constructor(arg0: java.security.PublicKey)
                public constructor(arg0: java.security.PublicKey, arg1: sun.security.pkcs10.PKCS10Attributes | sun.security.pkcs10.PKCS10Attributes$$Lambda)
                public constructor(arg0: byte[])
                public encodeAndSign(arg0: sun.security.x509.X500Name, arg1: java.security.Signature): void
                public getSubjectName(): sun.security.x509.X500Name
                public getSubjectPublicKeyInfo(): java.security.PublicKey
                public getSigAlg(): string
                public getAttributes(): sun.security.pkcs10.PKCS10Attributes
                public getEncoded(): byte[]
                public print(arg0: java.io.PrintStream): void
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class PKCS10Attribute implements sun.security.util.DerEncoder {
                protected attributeId: sun.security.util.ObjectIdentifier
                protected attributeValue: java.lang.Object
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: java.lang.Object)
                public constructor(arg0: sun.security.pkcs.PKCS9Attribute | sun.security.pkcs.PKCS9Attribute$$Lambda)
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getAttributeId(): sun.security.util.ObjectIdentifier
                public getAttributeValue(): java.lang.Object
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKCS10Attribute$$Lambda implements sun.security.util.DerEncoder {
                protected attributeId: sun.security.util.ObjectIdentifier
            }
            class PKCS10Attributes implements sun.security.util.DerEncoder {
                public constructor()
                public constructor(arg0: sun.security.pkcs10.PKCS10Attribute[])
                public constructor(arg0: sun.security.util.DerInputStream)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public setAttribute(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public getAttribute(arg0: java.lang.String | string): java.lang.Object
                public deleteAttribute(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<sun.security.pkcs10.PKCS10Attribute>
                public getAttributes(): java.util.Collection<sun.security.pkcs10.PKCS10Attribute>
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class PKCS10Attributes$$Lambda implements sun.security.util.DerEncoder {
                public constructor()
            }
        }
        namespace pkcs12 {
            class MacData {
                public getEncoded(): byte[]
                public static class: java.lang.Class<any>
            }
            class PKCS12KeyStore extends java.security.KeyStoreSpi {
                public static VERSION_3: int
                public constructor()
                public engineGetKey(arg0: java.lang.String | string, arg1: char[]): java.security.Key
                public engineGetCertificateChain(arg0: java.lang.String | string): java.security.cert.Certificate[]
                public engineGetCertificate(arg0: java.lang.String | string): java.security.cert.Certificate
                public engineGetCreationDate(arg0: java.lang.String | string): java.util.Date
                public engineSetKeyEntry(arg0: java.lang.String | string, arg1: java.security.Key, arg2: char[], arg3: java.security.cert.Certificate[]): void
                public engineSetKeyEntry(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.cert.Certificate[]): void
                public engineSetCertificateEntry(arg0: java.lang.String | string, arg1: java.security.cert.Certificate): void
                public engineDeleteEntry(arg0: java.lang.String | string): void
                public engineAliases(): java.util.Enumeration<java.lang.String>
                public engineContainsAlias(arg0: java.lang.String | string): boolean
                public engineSize(): int
                public engineIsKeyEntry(arg0: java.lang.String | string): boolean
                public engineIsCertificateEntry(arg0: java.lang.String | string): boolean
                public engineEntryInstanceOf(arg0: java.lang.String | string, arg1: java.lang.Class<java.security.KeyStore$Entry>): boolean
                public engineGetCertificateAlias(arg0: java.security.cert.Certificate): string
                public engineStore(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: char[]): void
                public engineGetEntry(arg0: java.lang.String | string, arg1: java.security.KeyStore$ProtectionParameter): java.security.KeyStore$Entry
                public engineSetEntry(arg0: java.lang.String | string, arg1: java.security.KeyStore$Entry, arg2: java.security.KeyStore$ProtectionParameter): void
                public engineLoad(arg0: java.io.InputStream, arg1: char[]): void
                public static class: java.lang.Class<any>
            }
        }
        namespace provider {
            namespace certpath {
                namespace ssl {
                    class SSLServerCertStore extends java.security.cert.CertStoreSpi {
                        public engineGetCertificates(arg0: java.security.cert.CertSelector): java.util.Collection<java.security.cert.X509Certificate>
                        public engineGetCRLs(arg0: java.security.cert.CRLSelector): java.util.Collection<java.security.cert.X509CRL>
                        public static class: java.lang.Class<any>
                    }
                }
                class AdaptableX509CertSelector extends java.security.cert.X509CertSelector {
                    public setSubjectKeyIdentifier(arg0: byte[]): void
                    public setSerialNumber(arg0: java.math.BigInteger): void
                    public match(arg0: java.security.cert.Certificate): boolean
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                class AdjacencyList {
                    public constructor(arg0: java.util.List<java.util.List<sun.security.provider.certpath.Vertex>>)
                    public iterator(): java.util.Iterator<sun.security.provider.certpath.BuildStep>
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class AlgorithmChecker extends java.security.cert.PKIXCertPathChecker {
                    public constructor(arg0: java.security.cert.TrustAnchor, arg1: java.lang.String | string)
                    public constructor(arg0: java.security.AlgorithmConstraints, arg1: java.security.Timestamp, arg2: java.lang.String | string)
                    public constructor(arg0: java.security.cert.TrustAnchor, arg1: java.security.AlgorithmConstraints, arg2: java.util.Date, arg3: java.security.Timestamp, arg4: java.lang.String | string)
                    public constructor(arg0: java.security.cert.TrustAnchor, arg1: java.util.Date, arg2: java.lang.String | string)
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public static class: java.lang.Class<any>
                }
                class BasicChecker extends java.security.cert.PKIXCertPathChecker {
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public static class: java.lang.Class<any>
                }
                class BuildStep {
                    public static POSSIBLE: int
                    public static BACK: int
                    public static FOLLOW: int
                    public static FAIL: int
                    public static SUCCEED: int
                    public constructor(arg0: sun.security.provider.certpath.Vertex, arg1: int)
                    public getVertex(): sun.security.provider.certpath.Vertex
                    public getCertificate(): java.security.cert.X509Certificate
                    public getIssuerName(): string
                    public getIssuerName(arg0: java.lang.String | string): string
                    public getSubjectName(): string
                    public getSubjectName(arg0: java.lang.String | string): string
                    public getThrowable(): java.lang.Throwable
                    public getResult(): int
                    public resultToString(arg0: int): string
                    public toString(): string
                    public verboseToString(): string
                    public fullToString(): string
                    public static class: java.lang.Class<any>
                }
                abstract class Builder {
                    public static class: java.lang.Class<any>
                }
                class CertId {
                    public constructor(arg0: java.security.cert.X509Certificate, arg1: sun.security.x509.SerialNumber)
                    public constructor(arg0: javax.security.auth.x500.X500Principal, arg1: java.security.PublicKey, arg2: sun.security.x509.SerialNumber)
                    public constructor(arg0: sun.security.util.DerInputStream)
                    public getHashAlgorithm(): sun.security.x509.AlgorithmId
                    public getIssuerNameHash(): byte[]
                    public getIssuerKeyHash(): byte[]
                    public getSerialNumber(): java.math.BigInteger
                    public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                    public hashCode(): int
                    public equals(arg0: java.lang.Object): boolean
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                abstract class CertPathHelper {
                    protected static instance: sun.security.provider.certpath.CertPathHelper
                    protected constructor()
                    protected implSetPathToNames(arg0: java.security.cert.X509CertSelector, arg1: java.util.Set<sun.security.x509.GeneralNameInterface>): void
                    protected implSetDateAndTime(arg0: java.security.cert.X509CRLSelector, arg1: java.util.Date, arg2: long): void
                    public static setDateAndTime(arg0: java.security.cert.X509CRLSelector, arg1: java.util.Date, arg2: long): void
                    public static class: java.lang.Class<any>
                }
                class CollectionCertStore extends java.security.cert.CertStoreSpi {
                    public constructor(arg0: java.security.cert.CertStoreParameters)
                    public engineGetCertificates(arg0: java.security.cert.CertSelector): java.util.Collection<java.security.cert.Certificate>
                    public engineGetCRLs(arg0: java.security.cert.CRLSelector): java.util.Collection<java.security.cert.CRL>
                    public static class: java.lang.Class<any>
                }
                class ConstraintsChecker extends java.security.cert.PKIXCertPathChecker {
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public static class: java.lang.Class<any>
                }
                class DistributionPointFetcher {
                    public static getCRLs(arg0: java.security.cert.X509CRLSelector, arg1: boolean, arg2: java.security.PublicKey, arg3: java.lang.String | string, arg4: java.util.List<java.security.cert.CertStore>, arg5: boolean[], arg6: java.util.Set<java.security.cert.TrustAnchor>, arg7: java.util.Date, arg8: java.lang.String | string): java.util.Collection<java.security.cert.X509CRL>
                    public static getCRLs(arg0: java.security.cert.X509CRLSelector, arg1: boolean, arg2: java.security.PublicKey, arg3: java.lang.String | string, arg4: java.util.List<java.security.cert.CertStore>, arg5: boolean[], arg6: java.util.Set<java.security.cert.TrustAnchor>, arg7: java.util.Date): java.util.Collection<java.security.cert.X509CRL>
                    public static getCRLs(arg0: java.security.cert.X509CRLSelector, arg1: boolean, arg2: java.security.PublicKey, arg3: java.security.cert.X509Certificate, arg4: java.lang.String | string, arg5: java.util.List<java.security.cert.CertStore>, arg6: boolean[], arg7: java.util.Set<java.security.cert.TrustAnchor>, arg8: java.util.Date, arg9: java.lang.String | string): java.util.Collection<java.security.cert.X509CRL>
                    public static class: java.lang.Class<any>
                }
                class ForwardBuilder extends sun.security.provider.certpath.Builder {
                    public static class: java.lang.Class<any>
                }
                class ForwardState implements sun.security.provider.certpath.State {
                    public isInitial(): boolean
                    public keyParamsNeeded(): boolean
                    public toString(): string
                    public initState(arg0: java.util.List<java.security.cert.PKIXCertPathChecker>): void
                    public updateState(arg0: java.security.cert.X509Certificate): void
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                class IndexedCollectionCertStore extends java.security.cert.CertStoreSpi {
                    public constructor(arg0: java.security.cert.CertStoreParameters)
                    public engineGetCertificates(arg0: java.security.cert.CertSelector): java.util.Collection<java.security.cert.Certificate>
                    public engineGetCRLs(arg0: java.security.cert.CRLSelector): java.util.Collection<java.security.cert.CRL>
                    public static class: java.lang.Class<any>
                }
                class KeyChecker extends java.security.cert.PKIXCertPathChecker {
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public static class: java.lang.Class<any>
                }
                class OCSP {
                    public static check(arg0: java.security.cert.X509Certificate, arg1: java.security.cert.X509Certificate, arg2: java.net.URI, arg3: java.security.cert.X509Certificate, arg4: java.util.Date): sun.security.provider.certpath.OCSP$RevocationStatus
                    public static check(arg0: java.security.cert.X509Certificate, arg1: java.security.cert.X509Certificate, arg2: java.net.URI, arg3: java.security.cert.X509Certificate, arg4: java.util.Date, arg5: java.util.List<java.security.cert.Extension>, arg6: java.lang.String | string): sun.security.provider.certpath.OCSP$RevocationStatus
                    public static check(arg0: java.security.cert.X509Certificate, arg1: java.net.URI, arg2: java.security.cert.TrustAnchor, arg3: java.security.cert.X509Certificate, arg4: java.security.cert.X509Certificate, arg5: java.util.Date, arg6: java.util.List<java.security.cert.Extension>, arg7: java.lang.String | string): sun.security.provider.certpath.OCSP$RevocationStatus
                    public static getOCSPBytes(arg0: java.util.List<sun.security.provider.certpath.CertId>, arg1: java.net.URI, arg2: java.util.List<java.security.cert.Extension>): byte[]
                    public static getResponderURI(arg0: java.security.cert.X509Certificate): java.net.URI
                    public static class: java.lang.Class<any>
                }
                class OCSPRequest {
                    public static class: java.lang.Class<any>
                }
                class OCSPResponse {
                    public constructor(arg0: byte[])
                    public getResponseStatus(): sun.security.provider.certpath.OCSPResponse$ResponseStatus
                    public getSingleResponse(arg0: sun.security.provider.certpath.CertId): sun.security.provider.certpath.OCSPResponse$SingleResponse
                    public getCertIds(): java.util.Set<sun.security.provider.certpath.CertId>
                    public getResponderId(): sun.security.provider.certpath.ResponderId
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class PKIX {
                    public static class: java.lang.Class<any>
                }
                class PKIXCertPathValidator extends java.security.cert.CertPathValidatorSpi {
                    public constructor()
                    public engineGetRevocationChecker(): java.security.cert.CertPathChecker
                    public engineValidate(arg0: java.security.cert.CertPath, arg1: java.security.cert.CertPathParameters): java.security.cert.CertPathValidatorResult
                    public static class: java.lang.Class<any>
                }
                class PKIXExtendedParameters extends java.security.cert.PKIXBuilderParameters {
                    public constructor(arg0: java.security.cert.PKIXBuilderParameters, arg1: java.security.Timestamp, arg2: java.lang.String | string)
                    public getTimestamp(): java.security.Timestamp
                    public setTimestamp(arg0: java.security.Timestamp): void
                    public getVariant(): string
                    public setDate(arg0: java.util.Date): void
                    public addCertPathChecker(arg0: java.security.cert.PKIXCertPathChecker): void
                    public setMaxPathLength(arg0: int): void
                    public getMaxPathLength(): int
                    public toString(): string
                    public getTrustAnchors(): java.util.Set<java.security.cert.TrustAnchor>
                    public setTrustAnchors(arg0: java.util.Set<java.security.cert.TrustAnchor>): void
                    public getInitialPolicies(): java.util.Set<java.lang.String>
                    public setInitialPolicies(arg0: java.util.Set<java.lang.String>): void
                    public setCertStores(arg0: java.util.List<java.security.cert.CertStore>): void
                    public addCertStore(arg0: java.security.cert.CertStore): void
                    public getCertStores(): java.util.List<java.security.cert.CertStore>
                    public setRevocationEnabled(arg0: boolean): void
                    public isRevocationEnabled(): boolean
                    public setExplicitPolicyRequired(arg0: boolean): void
                    public isExplicitPolicyRequired(): boolean
                    public setPolicyMappingInhibited(arg0: boolean): void
                    public isPolicyMappingInhibited(): boolean
                    public setAnyPolicyInhibited(arg0: boolean): void
                    public isAnyPolicyInhibited(): boolean
                    public setPolicyQualifiersRejected(arg0: boolean): void
                    public getPolicyQualifiersRejected(): boolean
                    public getDate(): java.util.Date
                    public setCertPathCheckers(arg0: java.util.List<java.security.cert.PKIXCertPathChecker>): void
                    public getCertPathCheckers(): java.util.List<java.security.cert.PKIXCertPathChecker>
                    public getSigProvider(): string
                    public setSigProvider(arg0: java.lang.String | string): void
                    public getTargetCertConstraints(): java.security.cert.CertSelector
                    public setTargetCertConstraints(arg0: java.security.cert.CertSelector): void
                    public static class: java.lang.Class<any>
                }
                class PKIXMasterCertPathValidator {
                    public static class: java.lang.Class<any>
                }
                class PolicyChecker extends java.security.cert.PKIXCertPathChecker {
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public static class: java.lang.Class<any>
                }
                class PolicyNodeImpl implements java.security.cert.PolicyNode {
                    public getParent(): java.security.cert.PolicyNode
                    public getChildren(): java.util.Iterator<sun.security.provider.certpath.PolicyNodeImpl>
                    public getDepth(): int
                    public getValidPolicy(): string
                    public getPolicyQualifiers(): java.util.Set<java.security.cert.PolicyQualifierInfo>
                    public getExpectedPolicies(): java.util.Set<java.lang.String>
                    public isCritical(): boolean
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class ResponderId {
                    public constructor(arg0: javax.security.auth.x500.X500Principal)
                    public constructor(arg0: java.security.PublicKey)
                    public constructor(arg0: byte[])
                    public getEncoded(): byte[]
                    public getType(): sun.security.provider.certpath.ResponderId$Type
                    public length(): int
                    public getResponderName(): javax.security.auth.x500.X500Principal
                    public getKeyIdentifier(): sun.security.x509.KeyIdentifier
                    public equals(arg0: java.lang.Object): boolean
                    public hashCode(): int
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
                class RevocationChecker extends java.security.cert.PKIXRevocationChecker {
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public getSoftFailExceptions(): java.util.List<java.security.cert.CertPathValidatorException>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public clone(): sun.security.provider.certpath.RevocationChecker
                    public clone(): java.security.cert.PKIXRevocationChecker
                    public clone(): java.lang.Object
                    public static class: java.lang.Class<any>
                }
                interface State extends java.lang.Cloneable {
                    updateState(arg0: java.security.cert.X509Certificate): void
                    clone(): java.lang.Object
                    isInitial(): boolean
                    keyParamsNeeded(): boolean
                }
                class SunCertPathBuilder extends java.security.cert.CertPathBuilderSpi {
                    public constructor()
                    public engineGetRevocationChecker(): java.security.cert.CertPathChecker
                    public engineBuild(arg0: java.security.cert.CertPathParameters): java.security.cert.CertPathBuilderResult
                    public static class: java.lang.Class<any>
                }
                class SunCertPathBuilderException extends java.security.cert.CertPathBuilderException {
                    public constructor()
                    public constructor(arg0: java.lang.String | string)
                    public constructor(arg0: java.lang.Throwable)
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                    public getAdjacencyList(): sun.security.provider.certpath.AdjacencyList
                    public static class: java.lang.Class<any>
                }
                class SunCertPathBuilderResult extends java.security.cert.PKIXCertPathBuilderResult {
                    public getAdjacencyList(): sun.security.provider.certpath.AdjacencyList
                    public static class: java.lang.Class<any>
                }
                class URICertStore extends java.security.cert.CertStoreSpi {
                    public engineGetCertificates(arg0: java.security.cert.CertSelector): java.util.Collection<java.security.cert.X509Certificate>
                    public engineGetCRLs(arg0: java.security.cert.CRLSelector): java.util.Collection<java.security.cert.X509CRL>
                    public static class: java.lang.Class<any>
                }
                class UntrustedChecker extends java.security.cert.PKIXCertPathChecker {
                    public constructor()
                    public init(arg0: boolean): void
                    public isForwardCheckingSupported(): boolean
                    public getSupportedExtensions(): java.util.Set<java.lang.String>
                    public check(arg0: java.security.cert.Certificate, arg1: java.util.Collection<java.lang.String>): void
                    public static class: java.lang.Class<any>
                }
                class Vertex {
                    public getCertificate(): java.security.cert.X509Certificate
                    public getIndex(): int
                    public getThrowable(): java.lang.Throwable
                    public toString(): string
                    public certToString(): string
                    public throwableToString(): string
                    public moreToString(): string
                    public indexToString(): string
                    public static class: java.lang.Class<any>
                }
                class X509CertPath extends java.security.cert.CertPath {
                    public constructor(arg0: java.util.List<java.security.cert.Certificate>)
                    public constructor(arg0: java.io.InputStream)
                    public constructor(arg0: java.io.InputStream, arg1: java.lang.String | string)
                    public getEncoded(): byte[]
                    public getEncoded(arg0: java.lang.String | string): byte[]
                    public static getEncodingsStatic(): java.util.Iterator<java.lang.String>
                    public getEncodings(): java.util.Iterator<java.lang.String>
                    public getCertificates(): java.util.List<java.security.cert.X509Certificate>
                    public static class: java.lang.Class<any>
                }
                class X509CertificatePair {
                    public constructor()
                    public constructor(arg0: java.security.cert.X509Certificate, arg1: java.security.cert.X509Certificate)
                    public static clearCache(): void
                    public static generateCertificatePair(arg0: byte[]): sun.security.provider.certpath.X509CertificatePair
                    public setForward(arg0: java.security.cert.X509Certificate): void
                    public setReverse(arg0: java.security.cert.X509Certificate): void
                    public getForward(): java.security.cert.X509Certificate
                    public getReverse(): java.security.cert.X509Certificate
                    public getEncoded(): byte[]
                    public toString(): string
                    public static class: java.lang.Class<any>
                }
            }
            class ByteArrayAccess {
                public static class: java.lang.Class<any>
            }
            class ConfigFile extends javax.security.auth.login.Configuration {
                public constructor()
                public getAppConfigurationEntry(arg0: java.lang.String | string): javax.security.auth.login.AppConfigurationEntry[]
                public refresh(): void
                public static class: java.lang.Class<any>
            }
            abstract class DSA extends java.security.SignatureSpi {
                protected engineInitSign(arg0: java.security.PrivateKey): void
                protected engineInitVerify(arg0: java.security.PublicKey): void
                protected engineUpdate(arg0: byte): void
                protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
                protected engineUpdate(arg0: java.nio.ByteBuffer): void
                protected engineSign(): byte[]
                protected engineVerify(arg0: byte[]): boolean
                protected engineVerify(arg0: byte[], arg1: int, arg2: int): boolean
                protected engineSetParameter(arg0: java.lang.String | string, arg1: java.lang.Object): void
                protected engineGetParameter(arg0: java.lang.String | string): java.lang.Object
                protected generateK(arg0: java.math.BigInteger): java.math.BigInteger
                protected getSigningRandom(): java.security.SecureRandom
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class DSAKeyFactory extends java.security.KeyFactorySpi {
                public constructor()
                protected engineGeneratePublic(arg0: java.security.spec.KeySpec): java.security.PublicKey
                protected engineGeneratePrivate(arg0: java.security.spec.KeySpec): java.security.PrivateKey
                protected engineGetKeySpec<T extends java.security.spec.KeySpec>(arg0: java.security.Key, arg1: java.lang.Class<T>): T
                protected engineTranslateKey<T extends java.security.spec.KeySpec>(arg0: java.security.Key): java.security.Key
                public static class: java.lang.Class<any>
            }
            class DSAKeyPairGenerator extends java.security.KeyPairGenerator {
                public initialize(arg0: int, arg1: java.security.SecureRandom): void
                public initialize(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                public generateKeyPair(): java.security.KeyPair
                public static class: java.lang.Class<any>
            }
            class DSAParameterGenerator extends java.security.AlgorithmParameterGeneratorSpi {
                public constructor()
                protected engineInit(arg0: int, arg1: java.security.SecureRandom): void
                protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                protected engineGenerateParameters(): java.security.AlgorithmParameters
                public static class: java.lang.Class<any>
            }
            class DSAParameters extends java.security.AlgorithmParametersSpi {
                protected p: java.math.BigInteger
                protected q: java.math.BigInteger
                protected g: java.math.BigInteger
                public constructor()
                protected engineInit(arg0: java.security.spec.AlgorithmParameterSpec): void
                protected engineInit(arg0: byte[]): void
                protected engineInit(arg0: byte[], arg1: java.lang.String | string): void
                protected engineGetParameterSpec<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.Class<T>): T
                protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(): byte[]
                protected engineGetEncoded<T extends java.security.spec.AlgorithmParameterSpec>(arg0: java.lang.String | string): byte[]
                protected engineToString<T extends java.security.spec.AlgorithmParameterSpec>(): string
                public static class: java.lang.Class<any>
            }
            class DSAPrivateKey extends sun.security.pkcs.PKCS8Key implements java.security.interfaces.DSAPrivateKey , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger)
                public constructor(arg0: byte[])
                public getParams(): java.security.interfaces.DSAParams
                public getX(): java.math.BigInteger
                protected parseKeyBits(): void
            }
            class DSAPublicKey extends sun.security.x509.X509Key implements java.security.interfaces.DSAPublicKey , java.io.Serializable {
                public constructor()
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger)
                public constructor(arg0: byte[])
                public getParams(): java.security.interfaces.DSAParams
                public getY(): java.math.BigInteger
                public toString(): string
                protected parseKeyBits(): void
            }
            class DSAPublicKeyImpl extends sun.security.provider.DSAPublicKey {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger, arg3: java.math.BigInteger)
                public constructor(arg0: byte[])
                protected writeReplace(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class DigestBase extends java.security.MessageDigestSpi implements java.lang.Cloneable {
                protected engineGetDigestLength(): int
                protected engineUpdate(arg0: byte): void
                protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
                protected engineReset(): void
                protected engineDigest(): byte[]
                protected engineDigest(arg0: byte[], arg1: int, arg2: int): int
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class DomainKeyStore extends java.security.KeyStoreSpi {
                public engineGetKey(arg0: java.lang.String | string, arg1: char[]): java.security.Key
                public engineGetCertificateChain(arg0: java.lang.String | string): java.security.cert.Certificate[]
                public engineGetCertificate(arg0: java.lang.String | string): java.security.cert.Certificate
                public engineGetCreationDate(arg0: java.lang.String | string): java.util.Date
                public engineSetKeyEntry(arg0: java.lang.String | string, arg1: java.security.Key, arg2: char[], arg3: java.security.cert.Certificate[]): void
                public engineSetKeyEntry(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.cert.Certificate[]): void
                public engineSetCertificateEntry(arg0: java.lang.String | string, arg1: java.security.cert.Certificate): void
                public engineDeleteEntry(arg0: java.lang.String | string): void
                public engineAliases(): java.util.Enumeration<java.lang.String>
                public engineContainsAlias(arg0: java.lang.String | string): boolean
                public engineSize(): int
                public engineIsKeyEntry(arg0: java.lang.String | string): boolean
                public engineIsCertificateEntry(arg0: java.lang.String | string): boolean
                public engineGetCertificateAlias(arg0: java.security.cert.Certificate): string
                public engineStore(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: char[]): void
                public engineStore(arg0: java.security.KeyStore$LoadStoreParameter): void
                public engineLoad(arg0: java.io.InputStream, arg1: char[]): void
                public engineLoad(arg0: java.security.KeyStore$LoadStoreParameter): void
                public static class: java.lang.Class<any>
            }
            abstract class JavaKeyStore extends java.security.KeyStoreSpi {
                public engineGetKey(arg0: java.lang.String | string, arg1: char[]): java.security.Key
                public engineGetCertificateChain(arg0: java.lang.String | string): java.security.cert.Certificate[]
                public engineGetCertificate(arg0: java.lang.String | string): java.security.cert.Certificate
                public engineGetCreationDate(arg0: java.lang.String | string): java.util.Date
                public engineSetKeyEntry(arg0: java.lang.String | string, arg1: java.security.Key, arg2: char[], arg3: java.security.cert.Certificate[]): void
                public engineSetKeyEntry(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.cert.Certificate[]): void
                public engineSetCertificateEntry(arg0: java.lang.String | string, arg1: java.security.cert.Certificate): void
                public engineDeleteEntry(arg0: java.lang.String | string): void
                public engineAliases(): java.util.Enumeration<java.lang.String>
                public engineContainsAlias(arg0: java.lang.String | string): boolean
                public engineSize(): int
                public engineIsKeyEntry(arg0: java.lang.String | string): boolean
                public engineIsCertificateEntry(arg0: java.lang.String | string): boolean
                public engineGetCertificateAlias(arg0: java.security.cert.Certificate): string
                public engineStore(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: char[]): void
                public engineLoad(arg0: java.io.InputStream, arg1: char[]): void
                public static class: java.lang.Class<any>
            }
            class KeyProtector {
                public constructor(arg0: char[])
                protected finalize(): void
                public protect(arg0: java.security.Key): byte[]
                public recover(arg0: sun.security.pkcs.EncryptedPrivateKeyInfo): java.security.Key
                public static class: java.lang.Class<any>
            }
            class MD2 extends sun.security.provider.DigestBase {
                public constructor()
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class MD4 extends sun.security.provider.DigestBase {
                public static getInstance(): java.security.MessageDigest
                public constructor()
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class MD5 extends sun.security.provider.DigestBase {
                public constructor()
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class ParameterCache {
                public static getCachedDSAParameterSpec(arg0: int, arg1: int): java.security.spec.DSAParameterSpec
                public static getCachedDHParameterSpec(arg0: int): javax.crypto.spec.DHParameterSpec
                public static getDSAParameterSpec(arg0: int, arg1: java.security.SecureRandom): java.security.spec.DSAParameterSpec
                public static getDSAParameterSpec(arg0: int, arg1: int, arg2: java.security.SecureRandom): java.security.spec.DSAParameterSpec
                public static getDHParameterSpec(arg0: int, arg1: java.security.SecureRandom): javax.crypto.spec.DHParameterSpec
                public static getNewDSAParameterSpec(arg0: int, arg1: int, arg2: java.security.SecureRandom): java.security.spec.DSAParameterSpec
                public static class: java.lang.Class<any>
            }
            class PolicyFile extends java.security.Policy {
                public constructor()
                public constructor(arg0: java.net.URL)
                public refresh(): void
                public implies(arg0: java.security.ProtectionDomain, arg1: java.security.Permission): boolean
                public getPermissions(arg0: java.security.ProtectionDomain): java.security.PermissionCollection
                public getPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
                protected getSignerCertificates(arg0: java.security.CodeSource): java.security.cert.Certificate[]
                public static class: java.lang.Class<any>
            }
            class PolicyParser {
                public constructor()
                public constructor(arg0: boolean)
                public read(arg0: java.io.Reader): void
                public add(arg0: sun.security.provider.PolicyParser$GrantEntry): void
                public replace(arg0: sun.security.provider.PolicyParser$GrantEntry, arg1: sun.security.provider.PolicyParser$GrantEntry): void
                public remove(arg0: sun.security.provider.PolicyParser$GrantEntry): boolean
                public getKeyStoreUrl(): string
                public setKeyStoreUrl(arg0: java.lang.String | string): void
                public getKeyStoreType(): string
                public setKeyStoreType(arg0: java.lang.String | string): void
                public getKeyStoreProvider(): string
                public setKeyStoreProvider(arg0: java.lang.String | string): void
                public getStorePassURL(): string
                public setStorePassURL(arg0: java.lang.String | string): void
                public grantElements(): java.util.Enumeration<sun.security.provider.PolicyParser$GrantEntry>
                public getDomainEntries(): java.util.Collection<sun.security.provider.PolicyParser$DomainEntry>
                public write(arg0: java.io.Writer | java.io.Writer$$Lambda): void
                public static main(arg0: java.lang.String[]): void
                public static class: java.lang.Class<any>
            }
            class PolicySpiFile extends java.security.PolicySpi {
                public constructor(arg0: java.security.Policy$Parameters)
                protected engineGetPermissions(arg0: java.security.CodeSource): java.security.PermissionCollection
                protected engineGetPermissions(arg0: java.security.ProtectionDomain): java.security.PermissionCollection
                protected engineImplies(arg0: java.security.ProtectionDomain, arg1: java.security.Permission): boolean
                protected engineRefresh(): void
                public static class: java.lang.Class<any>
            }
            class SHA extends sun.security.provider.DigestBase {
                public constructor()
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class SHA2 extends sun.security.provider.DigestBase {
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            abstract class SHA5 extends sun.security.provider.DigestBase {
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class SecureRandom extends java.security.SecureRandomSpi implements java.io.Serializable {
                public constructor()
                public engineGenerateSeed(arg0: int): byte[]
                public engineSetSeed(arg0: byte[]): void
                public engineNextBytes(arg0: byte[]): void
                public static class: java.lang.Class<any>
            }
            abstract class SeedGenerator {
                public static generateSeed(arg0: byte[]): void
                public static class: java.lang.Class<any>
            }
            class SubjectCodeSource extends java.security.CodeSource implements java.io.Serializable {
                public implies(arg0: java.security.CodeSource): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class Sun extends java.security.Provider {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class SunEntries {
                public static class: java.lang.Class<any>
            }
            class VerificationProvider extends java.security.Provider {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class X509Factory extends java.security.cert.CertificateFactorySpi {
                public static BEGIN_CERT: string
                public static END_CERT: string
                public constructor()
                public engineGenerateCertificate(arg0: java.io.InputStream): java.security.cert.Certificate
                public static intern(arg0: java.security.cert.X509Certificate): sun.security.x509.X509CertImpl
                public static intern(arg0: java.security.cert.X509CRL): sun.security.x509.X509CRLImpl
                public engineGenerateCertPath(arg0: java.io.InputStream): java.security.cert.CertPath
                public engineGenerateCertPath(arg0: java.io.InputStream, arg1: java.lang.String | string): java.security.cert.CertPath
                public engineGenerateCertPath(arg0: java.util.List<java.security.cert.Certificate>): java.security.cert.CertPath
                public engineGetCertPathEncodings(): java.util.Iterator<java.lang.String>
                public engineGenerateCertificates(arg0: java.io.InputStream): java.util.Collection<java.security.cert.Certificate>
                public engineGenerateCRL(arg0: java.io.InputStream): java.security.cert.CRL
                public engineGenerateCRLs(arg0: java.io.InputStream): java.util.Collection<java.security.cert.CRL>
                public static class: java.lang.Class<any>
            }
        }
        namespace rsa {
            class RSACore {
                public static getByteLength(arg0: java.math.BigInteger): int
                public static getByteLength(arg0: java.security.interfaces.RSAKey | java.security.interfaces.RSAKey$$Lambda): int
                public static convert(arg0: byte[], arg1: int, arg2: int): byte[]
                public static rsa(arg0: byte[], arg1: java.security.interfaces.RSAPublicKey): byte[]
                public static rsa(arg0: byte[], arg1: java.security.interfaces.RSAPrivateKey): byte[]
                public static rsa(arg0: byte[], arg1: java.security.interfaces.RSAPrivateKey, arg2: boolean): byte[]
                public static class: java.lang.Class<any>
            }
            class RSAKeyFactory extends java.security.KeyFactorySpi {
                public static MIN_MODLEN: int
                public static MAX_MODLEN: int
                public static MAX_MODLEN_RESTRICT_EXP: int
                public static MAX_RESTRICTED_EXPLEN: int
                public constructor()
                public static toRSAKey(arg0: java.security.Key): java.security.interfaces.RSAKey
                public static checkKeyLengths(arg0: int, arg1: java.math.BigInteger, arg2: int, arg3: int): void
                protected engineTranslateKey(arg0: java.security.Key): java.security.Key
                protected engineGeneratePublic(arg0: java.security.spec.KeySpec): java.security.PublicKey
                protected engineGeneratePrivate(arg0: java.security.spec.KeySpec): java.security.PrivateKey
                protected engineGetKeySpec<T extends java.security.spec.KeySpec>(arg0: java.security.Key, arg1: java.lang.Class<T>): T
                public static class: java.lang.Class<any>
            }
            class RSAKeyPairGenerator extends java.security.KeyPairGeneratorSpi {
                public constructor()
                public initialize(arg0: int, arg1: java.security.SecureRandom): void
                public initialize(arg0: java.security.spec.AlgorithmParameterSpec, arg1: java.security.SecureRandom): void
                public generateKeyPair(): java.security.KeyPair
                public static class: java.lang.Class<any>
            }
            class RSAPadding {
                public static PAD_BLOCKTYPE_1: int
                public static PAD_BLOCKTYPE_2: int
                public static PAD_NONE: int
                public static PAD_OAEP_MGF1: int
                public static getInstance(arg0: int, arg1: int): sun.security.rsa.RSAPadding
                public static getInstance(arg0: int, arg1: int, arg2: java.security.SecureRandom): sun.security.rsa.RSAPadding
                public static getInstance(arg0: int, arg1: int, arg2: java.security.SecureRandom, arg3: javax.crypto.spec.OAEPParameterSpec): sun.security.rsa.RSAPadding
                public getMaxDataSize(): int
                public pad(arg0: byte[], arg1: int, arg2: int): byte[]
                public pad(arg0: byte[]): byte[]
                public unpad(arg0: byte[], arg1: int, arg2: int): byte[]
                public unpad(arg0: byte[]): byte[]
                public static class: java.lang.Class<any>
            }
            class RSAPrivateCrtKeyImpl extends sun.security.pkcs.PKCS8Key implements java.security.interfaces.RSAPrivateCrtKey {
                public static newKey(arg0: byte[]): java.security.interfaces.RSAPrivateKey
                public getAlgorithm(): string
                public getModulus(): java.math.BigInteger
                public getPublicExponent(): java.math.BigInteger
                public getPrivateExponent(): java.math.BigInteger
                public getPrimeP(): java.math.BigInteger
                public getPrimeQ(): java.math.BigInteger
                public getPrimeExponentP(): java.math.BigInteger
                public getPrimeExponentQ(): java.math.BigInteger
                public getCrtCoefficient(): java.math.BigInteger
                protected parseKeyBits(): void
            }
            class RSAPrivateKeyImpl extends sun.security.pkcs.PKCS8Key implements java.security.interfaces.RSAPrivateKey {
                public getAlgorithm(): string
                public getModulus(): java.math.BigInteger
                public getPrivateExponent(): java.math.BigInteger
            }
            class RSAPublicKeyImpl extends sun.security.x509.X509Key implements java.security.interfaces.RSAPublicKey {
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger)
                public constructor(arg0: byte[])
                public getAlgorithm(): string
                public getModulus(): java.math.BigInteger
                public getPublicExponent(): java.math.BigInteger
                protected parseKeyBits(): void
                public toString(): string
                protected writeReplace(): java.lang.Object
            }
            abstract class RSASignature extends java.security.SignatureSpi {
                protected engineInitVerify(arg0: java.security.PublicKey): void
                protected engineInitSign(arg0: java.security.PrivateKey): void
                protected engineInitSign(arg0: java.security.PrivateKey, arg1: java.security.SecureRandom): void
                protected engineUpdate(arg0: byte): void
                protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
                protected engineUpdate(arg0: java.nio.ByteBuffer): void
                protected engineSign(): byte[]
                protected engineVerify(arg0: byte[]): boolean
                public static encodeSignature(arg0: sun.security.util.ObjectIdentifier, arg1: byte[]): byte[]
                public static decodeSignature(arg0: sun.security.util.ObjectIdentifier, arg1: byte[]): byte[]
                protected engineSetParameter(arg0: java.lang.String | string, arg1: java.lang.Object): void
                protected engineGetParameter(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class SunRsaSign extends java.security.Provider {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class SunRsaSignEntries {
                public static putEntries(arg0: java.util.Map<java.lang.Object, java.lang.Object>): void
                public static class: java.lang.Class<any>
            }
        }
        namespace ssl {
            class Authenticator {
                public static class: java.lang.Class<any>
            }
            abstract class BaseSSLSocketImpl extends javax.net.ssl.SSLSocket {
                public getChannel(): java.nio.channels.SocketChannel
                public bind(arg0: java.net.SocketAddress): void
                public getLocalSocketAddress(): java.net.SocketAddress
                public getRemoteSocketAddress(): java.net.SocketAddress
                public connect(arg0: java.net.SocketAddress): void
                public isConnected(): boolean
                public isBound(): boolean
                public shutdownInput(): void
                public shutdownOutput(): void
                public isInputShutdown(): boolean
                public isOutputShutdown(): boolean
                protected finalize(): void
                public getInetAddress(): java.net.InetAddress
                public getLocalAddress(): java.net.InetAddress
                public getPort(): int
                public getLocalPort(): int
                public setTcpNoDelay(arg0: boolean): void
                public getTcpNoDelay(): boolean
                public setSoLinger(arg0: boolean, arg1: int): void
                public getSoLinger(): int
                public sendUrgentData(arg0: int): void
                public setOOBInline(arg0: boolean): void
                public getOOBInline(): boolean
                public getSoTimeout(): int
                public setSendBufferSize(arg0: int): void
                public getSendBufferSize(): int
                public setReceiveBufferSize(arg0: int): void
                public getReceiveBufferSize(): int
                public setKeepAlive(arg0: boolean): void
                public getKeepAlive(): boolean
                public setTrafficClass(arg0: int): void
                public getTrafficClass(): int
                public setReuseAddress(arg0: boolean): void
                public getReuseAddress(): boolean
                public setPerformancePreferences(arg0: int, arg1: int, arg2: int): void
                public toString(): string
                public getInputStream(): java.io.InputStream
                public getOutputStream(): java.io.OutputStream
                public close(): void
                public setSoTimeout(arg0: int): void
                public static class: java.lang.Class<any>
            }
            class CipherSuite implements java.lang.Comparable<sun.security.ssl.CipherSuite> {
                public compareTo(arg0: sun.security.ssl.CipherSuite): int
                public toString(): string
                public compareTo(arg0: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            class DHClientKeyExchange extends sun.security.ssl.HandshakeMessage {
                public static class: java.lang.Class<any>
            }
            class ECDHClientKeyExchange extends sun.security.ssl.HandshakeMessage {
                public static class: java.lang.Class<any>
            }
            class EphemeralKeyManager {
                public static class: java.lang.Class<any>
            }
            class ExtendedMasterSecretExtension extends sun.security.ssl.HelloExtension {
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class HandshakeHash {
                public static class: java.lang.Class<any>
            }
            class HandshakeOutStream extends java.io.OutputStream {
                public write(arg0: byte[], arg1: int, arg2: int): void
                public write(arg0: int): void
                public flush(): void
                public putBytes16(arg0: byte[]): void
                public static class: java.lang.Class<any>
            }
            class InputRecord extends java.io.ByteArrayInputStream implements sun.security.ssl.Record {
                public close(): void
                public static class: java.lang.Class<any>
            }
            class JsseJce {
                public static class: java.lang.Class<any>
            }
            abstract class KeyManagerFactoryImpl extends javax.net.ssl.KeyManagerFactorySpi {
                protected engineGetKeyManagers(): javax.net.ssl.KeyManager[]
                public static class: java.lang.Class<any>
            }
            class OutputRecord extends java.io.ByteArrayOutputStream implements sun.security.ssl.Record {
                public reset(): void
                public static class: java.lang.Class<any>
            }
            class ProtocolVersion implements java.lang.Comparable<sun.security.ssl.ProtocolVersion> {
                public v: int
                public major: byte
                public minor: byte
                public static valueOf(arg0: int, arg1: int): sun.security.ssl.ProtocolVersion
                public toString(): string
                public compareTo(arg0: sun.security.ssl.ProtocolVersion): int
                public compareTo(arg0: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            class RSAClientKeyExchange extends sun.security.ssl.HandshakeMessage {
                public static class: java.lang.Class<any>
            }
            class RSASignature extends java.security.SignatureSpi {
                public constructor()
                protected engineInitVerify(arg0: java.security.PublicKey): void
                protected engineInitSign(arg0: java.security.PrivateKey): void
                protected engineInitSign(arg0: java.security.PrivateKey, arg1: java.security.SecureRandom): void
                protected engineUpdate(arg0: byte): void
                protected engineUpdate(arg0: byte[], arg1: int, arg2: int): void
                protected engineSign(): byte[]
                protected engineVerify(arg0: byte[]): boolean
                protected engineVerify(arg0: byte[], arg1: int, arg2: int): boolean
                protected engineSetParameter(arg0: java.lang.String | string, arg1: java.lang.Object): void
                protected engineGetParameter(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class RandomCookie {
                public static class: java.lang.Class<any>
            }
            interface Record {
                ct_change_cipher_spec: byte
                ct_alert: byte
                ct_handshake: byte
                ct_application_data: byte
                headerSize: int
                maxExpansion: int
                trailerSize: int
                maxDataSize: int
                maxPadding: int
                maxIVLength: int
                headerPlusMaxIVSize: int
                maxRecordSize: int
                enableCBCProtection: boolean
                maxDataSizeMinusOneByteRecord: int
                maxLargeRecordSize: int
                maxAlertRecordSize: int
                OVERFLOW_OF_INT08: int
                OVERFLOW_OF_INT16: int
                OVERFLOW_OF_INT24: int
            }
            class SSLAlgorithmConstraints implements java.security.AlgorithmConstraints {
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.AlgorithmParameters): boolean
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.security.Key): boolean
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.Key, arg3: java.security.AlgorithmParameters): boolean
                public static class: java.lang.Class<any>
            }
            class SSLAlgorithmDecomposer extends sun.security.util.AlgorithmDecomposer {
                public decompose(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                public static class: java.lang.Class<any>
            }
            abstract class SSLContextImpl extends javax.net.ssl.SSLContextSpi {
                protected engineInit(arg0: javax.net.ssl.KeyManager[], arg1: javax.net.ssl.TrustManager[], arg2: java.security.SecureRandom): void
                protected engineGetSocketFactory(): javax.net.ssl.SSLSocketFactory
                protected engineGetServerSocketFactory(): javax.net.ssl.SSLServerSocketFactory
                protected engineCreateSSLEngine(): javax.net.ssl.SSLEngine
                protected engineCreateSSLEngine(arg0: java.lang.String | string, arg1: int): javax.net.ssl.SSLEngine
                protected engineGetClientSessionContext(): javax.net.ssl.SSLSessionContext
                protected engineGetServerSessionContext(): javax.net.ssl.SSLSessionContext
                public static class: java.lang.Class<any>
            }
            class SSLEngineImpl extends javax.net.ssl.SSLEngine {
                public getHandshakeStatus(): javax.net.ssl.SSLEngineResult$HandshakeStatus
                public beginHandshake(): void
                public unwrap(arg0: java.nio.ByteBuffer, arg1: java.nio.ByteBuffer[], arg2: int, arg3: int): javax.net.ssl.SSLEngineResult
                public wrap(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int, arg3: java.nio.ByteBuffer): javax.net.ssl.SSLEngineResult
                public closeOutbound(): void
                public isOutboundDone(): boolean
                public closeInbound(): void
                public isInboundDone(): boolean
                public getSession(): javax.net.ssl.SSLSession
                public getHandshakeSession(): javax.net.ssl.SSLSession
                public getDelegatedTask(): java.lang.Runnable
                public setEnableSessionCreation(arg0: boolean): void
                public getEnableSessionCreation(): boolean
                public setNeedClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getWantClientAuth(): boolean
                public setUseClientMode(arg0: boolean): void
                public getUseClientMode(): boolean
                public getSupportedCipherSuites(): java.lang.String[]
                public setEnabledCipherSuites(arg0: java.lang.String[]): void
                public getEnabledCipherSuites(): java.lang.String[]
                public getSupportedProtocols(): java.lang.String[]
                public setEnabledProtocols(arg0: java.lang.String[]): void
                public getEnabledProtocols(): java.lang.String[]
                public getSSLParameters(): javax.net.ssl.SSLParameters
                public setSSLParameters(arg0: javax.net.ssl.SSLParameters): void
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SSLServerSocketFactoryImpl extends javax.net.ssl.SSLServerSocketFactory {
                public constructor()
                public createServerSocket(): java.net.ServerSocket
                public createServerSocket(arg0: int): java.net.ServerSocket
                public createServerSocket(arg0: int, arg1: int): java.net.ServerSocket
                public createServerSocket(arg0: int, arg1: int, arg2: java.net.InetAddress): java.net.ServerSocket
                public getDefaultCipherSuites(): java.lang.String[]
                public getSupportedCipherSuites(): java.lang.String[]
                public static class: java.lang.Class<any>
            }
            class SSLServerSocketImpl extends javax.net.ssl.SSLServerSocket {
                public getSupportedCipherSuites(): java.lang.String[]
                public getEnabledCipherSuites(): java.lang.String[]
                public setEnabledCipherSuites(arg0: java.lang.String[]): void
                public getSupportedProtocols(): java.lang.String[]
                public setEnabledProtocols(arg0: java.lang.String[]): void
                public getEnabledProtocols(): java.lang.String[]
                public setNeedClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getWantClientAuth(): boolean
                public setUseClientMode(arg0: boolean): void
                public getUseClientMode(): boolean
                public setEnableSessionCreation(arg0: boolean): void
                public getEnableSessionCreation(): boolean
                public getSSLParameters(): javax.net.ssl.SSLParameters
                public setSSLParameters(arg0: javax.net.ssl.SSLParameters): void
                public accept(): java.net.Socket
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SSLSessionContextImpl implements javax.net.ssl.SSLSessionContext {
                public getSession(arg0: byte[]): javax.net.ssl.SSLSession
                public getIds(): java.util.Enumeration<byte[]>
                public setSessionTimeout(arg0: int): void
                public getSessionTimeout(): int
                public setSessionCacheSize(arg0: int): void
                public getSessionCacheSize(): int
                public static class: java.lang.Class<any>
            }
            class SSLSessionImpl extends javax.net.ssl.ExtendedSSLSession {
                public isValid(): boolean
                public getId(): byte[]
                public getSessionContext(): javax.net.ssl.SSLSessionContext
                public getCipherSuite(): string
                public getProtocol(): string
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public getPeerCertificates(): java.security.cert.Certificate[]
                public getLocalCertificates(): java.security.cert.Certificate[]
                public getPeerCertificateChain(): javax.security.cert.X509Certificate[]
                public getCertificateChain(): java.security.cert.X509Certificate[]
                public getPeerPrincipal(): java.security.Principal
                public getLocalPrincipal(): java.security.Principal
                public getCreationTime(): long
                public getLastAccessedTime(): long
                public getPeerAddress(): java.net.InetAddress
                public getPeerHost(): string
                public getPeerPort(): int
                public invalidate(): void
                public putValue(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public getValue(arg0: java.lang.String | string): java.lang.Object
                public removeValue(arg0: java.lang.String | string): void
                public getValueNames(): java.lang.String[]
                protected expandBufferSizes(): void
                public getPacketBufferSize(): int
                public getApplicationBufferSize(): int
                public getLocalSupportedSignatureAlgorithms(): java.lang.String[]
                public getPeerSupportedSignatureAlgorithms(): java.lang.String[]
                public getRequestedServerNames(): java.util.List<javax.net.ssl.SNIServerName>
                public toString(): string
                protected finalize(): void
                public static class: java.lang.Class<any>
            }
            class SSLSocketFactoryImpl extends javax.net.ssl.SSLSocketFactory {
                public constructor()
                public createSocket(): java.net.Socket
                public createSocket(arg0: java.lang.String | string, arg1: int): java.net.Socket
                public createSocket(arg0: java.net.Socket, arg1: java.lang.String | string, arg2: int, arg3: boolean): java.net.Socket
                public createSocket(arg0: java.net.Socket, arg1: java.io.InputStream, arg2: boolean): java.net.Socket
                public createSocket(arg0: java.net.InetAddress, arg1: int): java.net.Socket
                public createSocket(arg0: java.lang.String | string, arg1: int, arg2: java.net.InetAddress, arg3: int): java.net.Socket
                public createSocket(arg0: java.net.InetAddress, arg1: int, arg2: java.net.InetAddress, arg3: int): java.net.Socket
                public getDefaultCipherSuites(): java.lang.String[]
                public getSupportedCipherSuites(): java.lang.String[]
                public static class: java.lang.Class<any>
            }
            class SSLSocketImpl extends sun.security.ssl.BaseSSLSocketImpl {
                public connect(arg0: java.net.SocketAddress, arg1: int): void
                public startHandshake(): void
                public isClosed(): boolean
                protected closeSocket(): void
                public close(): void
                public setHost(arg0: java.lang.String | string): void
                public getInputStream(): java.io.InputStream
                public getOutputStream(): java.io.OutputStream
                public getSession(): javax.net.ssl.SSLSession
                public getHandshakeSession(): javax.net.ssl.SSLSession
                public setEnableSessionCreation(arg0: boolean): void
                public getEnableSessionCreation(): boolean
                public setNeedClientAuth(arg0: boolean): void
                public getNeedClientAuth(): boolean
                public setWantClientAuth(arg0: boolean): void
                public getWantClientAuth(): boolean
                public setUseClientMode(arg0: boolean): void
                public getUseClientMode(): boolean
                public getSupportedCipherSuites(): java.lang.String[]
                public setEnabledCipherSuites(arg0: java.lang.String[]): void
                public getEnabledCipherSuites(): java.lang.String[]
                public getSupportedProtocols(): java.lang.String[]
                public setEnabledProtocols(arg0: java.lang.String[]): void
                public getEnabledProtocols(): java.lang.String[]
                public setSoTimeout(arg0: int): void
                public addHandshakeCompletedListener(arg0: javax.net.ssl.HandshakeCompletedListener): void
                public removeHandshakeCompletedListener(arg0: javax.net.ssl.HandshakeCompletedListener): void
                public getSSLParameters(): javax.net.ssl.SSLParameters
                public setSSLParameters(arg0: javax.net.ssl.SSLParameters): void
                public toString(): string
                public setPerformancePreferences(arg0: int, arg1: int, arg2: int): void
                public getRemoteSocketAddress(): java.net.SocketAddress
                public getLocalSocketAddress(): java.net.SocketAddress
                public bind(arg0: java.net.SocketAddress): void
                public static class: java.lang.Class<any>
            }
            class ServerNameExtension extends sun.security.ssl.HelloExtension {
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class SessionId {
                public toString(): string
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public static class: java.lang.Class<any>
            }
            class SignatureAlgorithmsExtension extends sun.security.ssl.HelloExtension {
                public toString(): string
                public static class: java.lang.Class<any>
            }
            abstract class SunJSSE extends java.security.Provider {
                protected static isFIPS(): boolean
                protected constructor()
                protected constructor(arg0: java.security.Provider)
                protected constructor(arg0: java.lang.String | string)
                protected finalize(): void
                public static class: java.lang.Class<any>
            }
            class SunX509KeyManagerImpl extends javax.net.ssl.X509ExtendedKeyManager {
                public getCertificateChain(arg0: java.lang.String | string): java.security.cert.X509Certificate[]
                public getPrivateKey(arg0: java.lang.String | string): java.security.PrivateKey
                public chooseClientAlias(arg0: java.lang.String[], arg1: java.security.Principal[], arg2: java.net.Socket): string
                public chooseEngineClientAlias(arg0: java.lang.String[], arg1: java.security.Principal[], arg2: javax.net.ssl.SSLEngine): string
                public chooseServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: java.net.Socket): string
                public chooseEngineServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: javax.net.ssl.SSLEngine): string
                public getClientAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                public getServerAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                public static class: java.lang.Class<any>
            }
            abstract class TrustManagerFactoryImpl extends javax.net.ssl.TrustManagerFactorySpi {
                protected engineInit(arg0: java.security.KeyStore): void
                protected engineInit(arg0: javax.net.ssl.ManagerFactoryParameters): void
                protected engineGetTrustManagers(): javax.net.ssl.TrustManager[]
                public static class: java.lang.Class<any>
            }
            class Utilities {
                public static class: java.lang.Class<any>
            }
            class X509KeyManagerImpl extends javax.net.ssl.X509ExtendedKeyManager implements javax.net.ssl.X509KeyManager {
                public getCertificateChain(arg0: java.lang.String | string): java.security.cert.X509Certificate[]
                public getPrivateKey(arg0: java.lang.String | string): java.security.PrivateKey
                public chooseClientAlias(arg0: java.lang.String[], arg1: java.security.Principal[], arg2: java.net.Socket): string
                public chooseEngineClientAlias(arg0: java.lang.String[], arg1: java.security.Principal[], arg2: javax.net.ssl.SSLEngine): string
                public chooseServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: java.net.Socket): string
                public chooseEngineServerAlias(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: javax.net.ssl.SSLEngine): string
                public getClientAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                public getServerAliases(arg0: java.lang.String | string, arg1: java.security.Principal[]): java.lang.String[]
                public getAliases(arg0: java.lang.String | string, arg1: java.security.Principal[], arg2: sun.security.ssl.X509KeyManagerImpl$CheckType, arg3: java.security.AlgorithmConstraints): java.lang.String[]
                public static class: java.lang.Class<any>
            }
            class X509TrustManagerImpl extends javax.net.ssl.X509ExtendedTrustManager implements javax.net.ssl.X509TrustManager {
                public checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string): void
                public checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string): void
                public getAcceptedIssuers(): java.security.cert.X509Certificate[]
                public checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: java.net.Socket): void
                public checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: java.net.Socket): void
                public checkClientTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: javax.net.ssl.SSLEngine): void
                public checkServerTrusted(arg0: java.security.cert.X509Certificate[], arg1: java.lang.String | string, arg2: javax.net.ssl.SSLEngine): void
                public static class: java.lang.Class<any>
            }
        }
        namespace timestamp {
            class HttpTimestamper implements sun.security.timestamp.Timestamper {
                public constructor(arg0: java.net.URI)
                public generateTimestamp(arg0: sun.security.timestamp.TSRequest): sun.security.timestamp.TSResponse
                public static class: java.lang.Class<any>
            }
            class HttpTimestamper$$Lambda implements sun.security.timestamp.Timestamper {
                public constructor(arg0: java.net.URI)
            }
            class TSRequest {
                public constructor(arg0: java.lang.String | string, arg1: byte[], arg2: java.security.MessageDigest)
                public getHashedMessage(): byte[]
                public setVersion(arg0: int): void
                public setPolicyId(arg0: java.lang.String | string): void
                public setNonce(arg0: java.math.BigInteger): void
                public requestCertificate(arg0: boolean): void
                public setExtensions(arg0: java.security.cert.X509Extension[]): void
                public encode(): byte[]
                public static class: java.lang.Class<any>
            }
            class TSResponse {
                public static GRANTED: int
                public static GRANTED_WITH_MODS: int
                public static REJECTION: int
                public static WAITING: int
                public static REVOCATION_WARNING: int
                public static REVOCATION_NOTIFICATION: int
                public static BAD_ALG: int
                public static BAD_REQUEST: int
                public static BAD_DATA_FORMAT: int
                public static TIME_NOT_AVAILABLE: int
                public static UNACCEPTED_POLICY: int
                public static UNACCEPTED_EXTENSION: int
                public static ADD_INFO_NOT_AVAILABLE: int
                public static SYSTEM_FAILURE: int
                public getStatusCode(): int
                public getStatusMessages(): java.lang.String[]
                public getFailureInfo(): boolean[]
                public getStatusCodeAsText(): string
                public getFailureCodeAsText(): string
                public getToken(): sun.security.pkcs.PKCS7
                public getTimestampToken(): sun.security.timestamp.TimestampToken
                public getEncodedToken(): byte[]
                public static class: java.lang.Class<any>
            }
            class TimestampToken {
                public constructor(arg0: byte[])
                public getDate(): java.util.Date
                public getHashAlgorithm(): sun.security.x509.AlgorithmId
                public getHashedMessage(): byte[]
                public getNonce(): java.math.BigInteger
                public getPolicyID(): string
                public getSerialNumber(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            interface Timestamper {
                generateTimestamp(arg0: sun.security.timestamp.TSRequest): sun.security.timestamp.TSResponse
            }
            interface Timestamper$$Lambda {
                (arg0: sun.security.timestamp.TSRequest): sun.security.timestamp.TSResponse
            }
        }
        namespace tools {
            namespace keytool {
                class CertAndKeyGen {
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                    public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string)
                    public setRandom(arg0: java.security.SecureRandom): void
                    public generate(arg0: int): void
                    public getPublicKey(): sun.security.x509.X509Key
                    public getPublicKeyAnyway(): java.security.PublicKey
                    public getPrivateKey(): java.security.PrivateKey
                    public getSelfCertificate(arg0: sun.security.x509.X500Name, arg1: java.util.Date, arg2: long): java.security.cert.X509Certificate
                    public getSelfCertificate(arg0: sun.security.x509.X500Name, arg1: java.util.Date, arg2: long, arg3: sun.security.x509.CertificateExtensions): java.security.cert.X509Certificate
                    public getSelfCertificate(arg0: sun.security.x509.X500Name, arg1: long): java.security.cert.X509Certificate
                    public getCertRequest(arg0: sun.security.x509.X500Name): sun.security.pkcs10.PKCS10
                    public static class: java.lang.Class<any>
                }
                class Main {
                    public static main(arg0: java.lang.String[]): void
                    public static loadCRLs(arg0: java.lang.String | string): java.util.Collection<java.security.cert.CRL>
                    public static readCRLsFromCert(arg0: java.security.cert.X509Certificate): java.util.List<java.security.cert.CRL>
                    public static class: java.lang.Class<any>
                }
                class Resources extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_de extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_es extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_fr extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_it extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_ja extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_ko extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_pt_BR extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_sv extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_zh_CN extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_zh_HK extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
                class Resources_zh_TW extends java.util.ListResourceBundle {
                    public constructor()
                    public getContents(): java.lang.Object[][]
                    public static class: java.lang.Class<any>
                }
            }
            class KeyStoreUtil {
                public static isWindowsKeyStore(arg0: java.lang.String | string): boolean
                public static niceStoreTypeName(arg0: java.lang.String | string): string
                public static getCacertsKeyStore(): java.security.KeyStore
                public static getPassWithModifier(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.util.ResourceBundle): char[]
                public static class: java.lang.Class<any>
            }
            class PathList {
                public constructor()
                public static appendPath(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                public static pathToURLs(arg0: java.lang.String | string): java.net.URL[]
                public static class: java.lang.Class<any>
            }
        }
        namespace util {
            abstract class AbstractAlgorithmConstraints implements java.security.AlgorithmConstraints {
                protected decomposer: sun.security.util.AlgorithmDecomposer
                protected constructor(arg0: sun.security.util.AlgorithmDecomposer)
                public static class: java.lang.Class<any>
            }
            class AlgorithmDecomposer {
                public constructor()
                public decompose(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                public static getAliases(arg0: java.lang.String | string): java.util.Collection<java.lang.String>
                public static decomposeOneHash(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                public static hashName(arg0: java.lang.String | string): string
                public static class: java.lang.Class<any>
            }
            class AnchorCertificates {
                public static contains(arg0: java.security.cert.X509Certificate): boolean
                public static class: java.lang.Class<any>
            }
            class AuthResources extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_de extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_es extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_fr extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_it extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_ja extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_ko extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_pt_BR extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_sv extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_zh_CN extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class AuthResources_zh_TW extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class BitArray {
                public constructor(arg0: int)
                public constructor(arg0: int, arg1: byte[])
                public constructor(arg0: boolean[])
                public get(arg0: int): boolean
                public set(arg0: int, arg1: boolean): void
                public length(): int
                public toByteArray(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public toBooleanArray(): boolean[]
                public hashCode(): int
                public clone(): java.lang.Object
                public toString(): string
                public truncate(): sun.security.util.BitArray
                public static class: java.lang.Class<any>
            }
            class ByteArrayLexOrder implements java.util.Comparator<byte[]> {
                public constructor()
                public compare(arg0: byte[], arg1: byte[]): int
                public compare(arg0: java.lang.Object, arg1: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            class ByteArrayTagOrder implements java.util.Comparator<byte[]> {
                public constructor()
                public compare(arg0: byte[], arg1: byte[]): int
                public compare(arg0: java.lang.Object, arg1: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            abstract class Cache<K, V> {
                protected constructor()
                public size(): int
                public clear(): void
                public put(arg0: K, arg1: V): void
                public get(arg0: java.lang.Object): V
                public remove(arg0: java.lang.Object): void
                public setCapacity(arg0: int): void
                public setTimeout(arg0: int): void
                public accept(arg0: sun.security.util.Cache$CacheVisitor<K, V>): void
                public static newSoftMemoryCache<K, V>(arg0: int): sun.security.util.Cache<K, V>
                public static newSoftMemoryCache<K, V>(arg0: int, arg1: int): sun.security.util.Cache<K, V>
                public static newHardMemoryCache<K, V>(arg0: int): sun.security.util.Cache<K, V>
                public static newNullCache<K, V>(): sun.security.util.Cache<K, V>
                public static newHardMemoryCache<K, V>(arg0: int, arg1: int): sun.security.util.Cache<K, V>
                public static class: java.lang.Class<any>
            }
            class ConstraintsParameters {
                public constructor(arg0: java.security.cert.X509Certificate, arg1: boolean, arg2: java.util.Date, arg3: java.security.Timestamp, arg4: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.security.AlgorithmParameters, arg2: java.security.Key, arg3: java.lang.String | string)
                public constructor(arg0: java.security.cert.X509Certificate)
                public constructor(arg0: java.security.Timestamp)
                public getAlgorithm(): string
                public getAlgParams(): java.security.AlgorithmParameters
                public getPublicKey(): java.security.Key
                public isTrustedMatch(): boolean
                public getCertificate(): java.security.cert.X509Certificate
                public getPKIXParamDate(): java.util.Date
                public getJARTimestamp(): java.security.Timestamp
                public getVariant(): string
                public static class: java.lang.Class<any>
            }
            class Debug {
                public constructor()
                public static Help(): void
                public static getInstance(arg0: java.lang.String | string): sun.security.util.Debug
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.security.util.Debug
                public static isOn(arg0: java.lang.String | string): boolean
                public println(arg0: java.lang.String | string): void
                public println(): void
                public static println(arg0: java.lang.String | string, arg1: java.lang.String | string): void
                public static toHexString(arg0: java.math.BigInteger): string
                public static toString(arg0: byte[]): string
                public static class: java.lang.Class<any>
            }
            interface DerEncoder {
                derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
            }
            interface DerEncoder$$Lambda {
                (arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
            }
            class DerIndefLenConverter {
                public static class: java.lang.Class<any>
            }
            class DerInputBuffer extends java.io.ByteArrayInputStream implements java.lang.Cloneable {
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getInteger(arg0: int): int
                public getBitString(arg0: int): byte[]
                public getUTCTime(arg0: int): java.util.Date
                public getGeneralizedTime(arg0: int): java.util.Date
                public static class: java.lang.Class<any>
            }
            class DerInputStream {
                public tag: byte
                public constructor(arg0: byte[])
                public constructor(arg0: byte[], arg1: int, arg2: int, arg3: boolean)
                public constructor(arg0: byte[], arg1: int, arg2: int)
                public subStream(arg0: int, arg1: boolean): sun.security.util.DerInputStream
                public toByteArray(): byte[]
                public getInteger(): int
                public getBigInteger(): java.math.BigInteger
                public getPositiveBigInteger(): java.math.BigInteger
                public getEnumerated(): int
                public getBitString(): byte[]
                public getUnalignedBitString(): sun.security.util.BitArray
                public getOctetString(): byte[]
                public getBytes(arg0: byte[]): void
                public getNull(): void
                public getOID(): sun.security.util.ObjectIdentifier
                public getSequence(arg0: int): sun.security.util.DerValue[]
                public getSet(arg0: int): sun.security.util.DerValue[]
                public getSet(arg0: int, arg1: boolean): sun.security.util.DerValue[]
                protected readVector(arg0: int): sun.security.util.DerValue[]
                public getDerValue(): sun.security.util.DerValue
                public getUTF8String(): string
                public getPrintableString(): string
                public getT61String(): string
                public getIA5String(): string
                public getBMPString(): string
                public getGeneralString(): string
                public getUTCTime(): java.util.Date
                public getGeneralizedTime(): java.util.Date
                public peekByte(): int
                public mark(arg0: int): void
                public reset(): void
                public available(): int
                public static class: java.lang.Class<any>
            }
            class DerOutputStream extends java.io.ByteArrayOutputStream implements sun.security.util.DerEncoder {
                public constructor(arg0: int)
                public constructor()
                public write(arg0: byte, arg1: byte[]): void
                public write(arg0: byte, arg1: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public writeImplicit(arg0: byte, arg1: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public putDerValue(arg0: sun.security.util.DerValue): void
                public putBoolean(arg0: boolean): void
                public putEnumerated(arg0: int): void
                public putInteger(arg0: java.math.BigInteger): void
                public putInteger(arg0: java.lang.Integer): void
                public putInteger(arg0: int): void
                public putBitString(arg0: byte[]): void
                public putUnalignedBitString(arg0: sun.security.util.BitArray): void
                public putTruncatedUnalignedBitString(arg0: sun.security.util.BitArray): void
                public putOctetString(arg0: byte[]): void
                public putNull(): void
                public putOID(arg0: sun.security.util.ObjectIdentifier): void
                public putSequence(arg0: sun.security.util.DerValue[]): void
                public putSet(arg0: sun.security.util.DerValue[]): void
                public putOrderedSetOf(arg0: byte, arg1: sun.security.util.DerEncoder[]): void
                public putOrderedSet(arg0: byte, arg1: sun.security.util.DerEncoder[]): void
                public putUTF8String(arg0: java.lang.String | string): void
                public putPrintableString(arg0: java.lang.String | string): void
                public putT61String(arg0: java.lang.String | string): void
                public putIA5String(arg0: java.lang.String | string): void
                public putBMPString(arg0: java.lang.String | string): void
                public putGeneralString(arg0: java.lang.String | string): void
                public putUTCTime(arg0: java.util.Date): void
                public putGeneralizedTime(arg0: java.util.Date): void
                public putLength(arg0: int): void
                public putTag(arg0: byte, arg1: boolean, arg2: byte): void
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class DerOutputStream$$Lambda extends java.io.ByteArrayOutputStream implements sun.security.util.DerEncoder {
                public constructor(arg0: int)
            }
            class DerValue {
                public static TAG_UNIVERSAL: byte
                public static TAG_APPLICATION: byte
                public static TAG_CONTEXT: byte
                public static TAG_PRIVATE: byte
                public tag: byte
                protected buffer: sun.security.util.DerInputBuffer
                public data: sun.security.util.DerInputStream
                public static tag_Boolean: byte
                public static tag_Integer: byte
                public static tag_BitString: byte
                public static tag_OctetString: byte
                public static tag_Null: byte
                public static tag_ObjectId: byte
                public static tag_Enumerated: byte
                public static tag_UTF8String: byte
                public static tag_PrintableString: byte
                public static tag_T61String: byte
                public static tag_IA5String: byte
                public static tag_UtcTime: byte
                public static tag_GeneralizedTime: byte
                public static tag_GeneralString: byte
                public static tag_UniversalString: byte
                public static tag_BMPString: byte
                public static tag_Sequence: byte
                public static tag_SequenceOf: byte
                public static tag_Set: byte
                public static tag_SetOf: byte
                public isUniversal(): boolean
                public isApplication(): boolean
                public isContextSpecific(): boolean
                public isContextSpecific(arg0: byte): boolean
                public isConstructed(): boolean
                public isConstructed(arg0: byte): boolean
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: byte, arg1: java.lang.String | string)
                public constructor(arg0: byte, arg1: byte[])
                public constructor(arg0: byte[])
                public constructor(arg0: byte[], arg1: int, arg2: int)
                public constructor(arg0: java.io.InputStream)
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getData(): sun.security.util.DerInputStream
                public getTag(): byte
                public getBoolean(): boolean
                public getOID(): sun.security.util.ObjectIdentifier
                public getOctetString(): byte[]
                public getInteger(): int
                public getBigInteger(): java.math.BigInteger
                public getPositiveBigInteger(): java.math.BigInteger
                public getEnumerated(): int
                public getBitString(): byte[]
                public getUnalignedBitString(): sun.security.util.BitArray
                public getAsString(): string
                public getBitString(arg0: boolean): byte[]
                public getUnalignedBitString(arg0: boolean): sun.security.util.BitArray
                public getDataBytes(): byte[]
                public getPrintableString(): string
                public getT61String(): string
                public getIA5String(): string
                public getBMPString(): string
                public getUTF8String(): string
                public getGeneralString(): string
                public getUTCTime(): java.util.Date
                public getGeneralizedTime(): java.util.Date
                public equals(arg0: java.lang.Object): boolean
                public equals(arg0: sun.security.util.DerValue): boolean
                public toString(): string
                public toByteArray(): byte[]
                public toDerInputStream(): sun.security.util.DerInputStream
                public length(): int
                public static isPrintableStringChar(arg0: char): boolean
                public static createTag(arg0: byte, arg1: boolean, arg2: byte): byte
                public resetTag(arg0: byte): void
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class DisabledAlgorithmConstraints extends sun.security.util.AbstractAlgorithmConstraints {
                public static PROPERTY_CERTPATH_DISABLED_ALGS: string
                public static PROPERTY_TLS_DISABLED_ALGS: string
                public static PROPERTY_JAR_DISABLED_ALGS: string
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: sun.security.util.AlgorithmDecomposer)
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.AlgorithmParameters): boolean
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.security.Key): boolean
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.Key, arg3: java.security.AlgorithmParameters): boolean
                public permits(arg0: sun.security.util.ConstraintsParameters): void
                public permits(arg0: java.lang.String | string, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, arg3: java.lang.String | string): void
                public permits(arg0: java.lang.String | string, arg1: sun.security.util.ConstraintsParameters): void
                public checkProperty(arg0: java.lang.String | string): boolean
                public static class: java.lang.Class<any>
            }
            class ECKeySizeParameterSpec implements java.security.spec.AlgorithmParameterSpec {
                public constructor(arg0: int)
                public getKeySize(): int
                public static class: java.lang.Class<any>
            }
            class ECUtil {
                public static decodePoint(arg0: byte[], arg1: java.security.spec.EllipticCurve): java.security.spec.ECPoint
                public static encodePoint(arg0: java.security.spec.ECPoint, arg1: java.security.spec.EllipticCurve): byte[]
                public static trimZeroes(arg0: byte[]): byte[]
                public static encodeECParameterSpec(arg0: java.security.Provider, arg1: java.security.spec.ECParameterSpec): byte[]
                public static getECParameterSpec(arg0: java.security.Provider, arg1: java.security.spec.ECParameterSpec): java.security.spec.ECParameterSpec
                public static getECParameterSpec(arg0: java.security.Provider, arg1: byte[]): java.security.spec.ECParameterSpec
                public static getECParameterSpec(arg0: java.security.Provider, arg1: java.lang.String | string): java.security.spec.ECParameterSpec
                public static getECParameterSpec(arg0: java.security.Provider, arg1: int): java.security.spec.ECParameterSpec
                public static getCurveName(arg0: java.security.Provider, arg1: java.security.spec.ECParameterSpec): string
                public static class: java.lang.Class<any>
            }
            class HostnameChecker {
                public static TYPE_TLS: byte
                public static TYPE_LDAP: byte
                public static getInstance(arg0: byte): sun.security.util.HostnameChecker
                public match(arg0: java.lang.String | string, arg1: java.security.cert.X509Certificate): void
                public static match(arg0: java.lang.String | string, arg1: java.security.Principal): boolean
                public static getServerName(arg0: java.security.Principal): string
                public static getSubjectX500Name(arg0: java.security.cert.X509Certificate): sun.security.x509.X500Name
                public static class: java.lang.Class<any>
            }
            class KeyUtil {
                public constructor()
                public static getKeySize(arg0: java.security.Key): int
                public static getKeySize(arg0: java.security.AlgorithmParameters): int
                public static validate(arg0: java.security.Key): void
                public static validate(arg0: java.security.spec.KeySpec): void
                public static isOracleJCEProvider(arg0: java.lang.String | string): boolean
                public static checkTlsPreMasterSecretKey(arg0: int, arg1: int, arg2: java.security.SecureRandom, arg3: byte[], arg4: boolean): byte[]
                public static trimZeroes(arg0: byte[]): byte[]
                public static class: java.lang.Class<any>
            }
            class LegacyAlgorithmConstraints extends sun.security.util.AbstractAlgorithmConstraints {
                public static PROPERTY_TLS_LEGACY_ALGS: string
                public constructor(arg0: java.lang.String | string, arg1: sun.security.util.AlgorithmDecomposer)
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.AlgorithmParameters): boolean
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.security.Key): boolean
                public permits(arg0: java.util.Set<java.security.CryptoPrimitive>, arg1: java.lang.String | string, arg2: java.security.Key, arg3: java.security.AlgorithmParameters): boolean
                public static class: java.lang.Class<any>
            }
            interface Length {
                length(): int
            }
            interface Length$$Lambda {
                (): int
            }
            class ManifestDigester {
                public static MF_MAIN_ATTRS: string
                public constructor(arg0: byte[])
                public get(arg0: java.lang.String | string, arg1: boolean): sun.security.util.ManifestDigester$Entry
                public manifestDigest(arg0: java.security.MessageDigest): byte[]
                public static class: java.lang.Class<any>
            }
            class ManifestEntryVerifier {
                public constructor(arg0: java.util.jar.Manifest)
                public setEntry(arg0: java.lang.String | string, arg1: java.util.jar.JarEntry): void
                public update(arg0: byte): void
                public update(arg0: byte[], arg1: int, arg2: int): void
                public getEntry(): java.util.jar.JarEntry
                public verify(arg0: java.util.Hashtable<java.lang.String, java.security.CodeSigner[]>, arg1: java.util.Hashtable<java.lang.String, java.security.CodeSigner[]>): java.security.CodeSigner[]
                public static class: java.lang.Class<any>
            }
            class ObjectIdentifier implements java.io.Serializable {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: int[])
                public constructor(arg0: sun.security.util.DerInputStream)
                public static newInternal(arg0: int[]): sun.security.util.ObjectIdentifier
                public equals(arg0: sun.security.util.ObjectIdentifier): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class Password {
                public constructor()
                public static readPassword(arg0: java.io.InputStream): char[]
                public static readPassword(arg0: java.io.InputStream, arg1: boolean): char[]
                public static class: java.lang.Class<any>
            }
            class Pem {
                public constructor()
                public static decode(arg0: java.lang.String | string): byte[]
                public static class: java.lang.Class<any>
            }
            class PendingException extends java.lang.RuntimeException {
                public constructor()
                public constructor(arg0: java.lang.String | string)
                public static class: java.lang.Class<any>
            }
            interface PermissionFactory<T extends java.security.Permission> {
                newPermission(arg0: java.lang.String | string): T
            }
            class PolicyUtil {
                public constructor()
                public static getInputStream(arg0: java.net.URL): java.io.InputStream
                public static getKeyStore(arg0: java.net.URL, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: sun.security.util.Debug): java.security.KeyStore
                public static class: java.lang.Class<any>
            }
            class PropertyExpander {
                public constructor()
                public static expand(arg0: java.lang.String | string): string
                public static expand(arg0: java.lang.String | string, arg1: boolean): string
                public static class: java.lang.Class<any>
            }
            class Resources extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class ResourcesMgr {
                public constructor()
                public static getString(arg0: java.lang.String | string): string
                public static getString(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                public static class: java.lang.Class<any>
            }
            class Resources_de extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_es extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_fr extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_it extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_ja extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_ko extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_pt_BR extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_sv extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_zh_CN extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class Resources_zh_TW extends java.util.ListResourceBundle {
                public constructor()
                public getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class SecurityConstants {
                public static FILE_DELETE_ACTION: string
                public static FILE_EXECUTE_ACTION: string
                public static FILE_READ_ACTION: string
                public static FILE_WRITE_ACTION: string
                public static FILE_READLINK_ACTION: string
                public static SOCKET_RESOLVE_ACTION: string
                public static SOCKET_CONNECT_ACTION: string
                public static SOCKET_LISTEN_ACTION: string
                public static SOCKET_ACCEPT_ACTION: string
                public static SOCKET_CONNECT_ACCEPT_ACTION: string
                public static PROPERTY_RW_ACTION: string
                public static PROPERTY_READ_ACTION: string
                public static PROPERTY_WRITE_ACTION: string
                public static ALL_PERMISSION: java.security.AllPermission
                public static SPECIFY_HANDLER_PERMISSION: java.net.NetPermission
                public static SET_PROXYSELECTOR_PERMISSION: java.net.NetPermission
                public static GET_PROXYSELECTOR_PERMISSION: java.net.NetPermission
                public static SET_COOKIEHANDLER_PERMISSION: java.net.NetPermission
                public static GET_COOKIEHANDLER_PERMISSION: java.net.NetPermission
                public static SET_RESPONSECACHE_PERMISSION: java.net.NetPermission
                public static GET_RESPONSECACHE_PERMISSION: java.net.NetPermission
                public static CREATE_CLASSLOADER_PERMISSION: java.lang.RuntimePermission
                public static CHECK_MEMBER_ACCESS_PERMISSION: java.lang.RuntimePermission
                public static MODIFY_THREAD_PERMISSION: java.lang.RuntimePermission
                public static MODIFY_THREADGROUP_PERMISSION: java.lang.RuntimePermission
                public static GET_PD_PERMISSION: java.lang.RuntimePermission
                public static GET_CLASSLOADER_PERMISSION: java.lang.RuntimePermission
                public static STOP_THREAD_PERMISSION: java.lang.RuntimePermission
                public static GET_STACK_TRACE_PERMISSION: java.lang.RuntimePermission
                public static CREATE_ACC_PERMISSION: java.security.SecurityPermission
                public static GET_COMBINER_PERMISSION: java.security.SecurityPermission
                public static GET_POLICY_PERMISSION: java.security.SecurityPermission
                public static LOCAL_LISTEN_PERMISSION: java.net.SocketPermission
                public static class: java.lang.Class<any>
            }
            class SecurityProviderConstants {
                public static DEF_DSA_KEY_SIZE: int
                public static DEF_RSA_KEY_SIZE: int
                public static DEF_DH_KEY_SIZE: int
                public static DEF_EC_KEY_SIZE: int
                public static getDefDSASubprimeSize(arg0: int): int
                public static class: java.lang.Class<any>
            }
            class SignatureFileVerifier {
                public constructor(arg0: java.util.ArrayList<java.security.CodeSigner[]>, arg1: sun.security.util.ManifestDigester, arg2: java.lang.String | string, arg3: byte[])
                public needSignatureFileBytes(): boolean
                public needSignatureFile(arg0: java.lang.String | string): boolean
                public setSignatureFile(arg0: byte[]): void
                public static isBlockOrSF(arg0: java.lang.String | string): boolean
                public static isSigningRelated(arg0: java.lang.String | string): boolean
                public process(arg0: java.util.Hashtable<java.lang.String, java.security.CodeSigner[]>, arg1: java.util.List<java.lang.Object>): void
                public static class: java.lang.Class<any>
            }
            class UntrustedCertificates {
                public static isUntrusted(arg0: java.security.cert.X509Certificate): boolean
                public static class: java.lang.Class<any>
            }
        }
        namespace validator {
            class EndEntityChecker {
                public static class: java.lang.Class<any>
            }
            class PKIXValidator extends sun.security.validator.Validator {
                public getTrustedCertificates(): java.util.Collection<java.security.cert.X509Certificate>
                public getCertPathLength(): int
                public getParameters(): java.security.cert.PKIXBuilderParameters
                public static class: java.lang.Class<any>
            }
            class SimpleValidator extends sun.security.validator.Validator {
                public getTrustedCertificates(): java.util.Collection<java.security.cert.X509Certificate>
                public static class: java.lang.Class<any>
            }
            abstract class Validator {
                public static TYPE_SIMPLE: string
                public static TYPE_PKIX: string
                public static VAR_GENERIC: string
                public static VAR_CODE_SIGNING: string
                public static VAR_JCE_SIGNING: string
                public static VAR_TLS_CLIENT: string
                public static VAR_TLS_SERVER: string
                public static VAR_TSA_SERVER: string
                public static VAR_PLUGIN_CODE_SIGNING: string
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.security.KeyStore): sun.security.validator.Validator
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.util.Collection<java.security.cert.X509Certificate>): sun.security.validator.Validator
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.security.cert.PKIXBuilderParameters): sun.security.validator.Validator
                public validate(arg0: java.security.cert.X509Certificate[]): java.security.cert.X509Certificate[]
                public validate(arg0: java.security.cert.X509Certificate[], arg1: java.util.Collection<java.security.cert.X509Certificate>): java.security.cert.X509Certificate[]
                public validate(arg0: java.security.cert.X509Certificate[], arg1: java.util.Collection<java.security.cert.X509Certificate>, arg2: java.lang.Object): java.security.cert.X509Certificate[]
                public validate(arg0: java.security.cert.X509Certificate[], arg1: java.util.Collection<java.security.cert.X509Certificate>, arg2: java.security.AlgorithmConstraints, arg3: java.lang.Object): java.security.cert.X509Certificate[]
                public getTrustedCertificates(): java.util.Collection<java.security.cert.X509Certificate>
                public setValidationDate(arg0: java.util.Date): void
                public static class: java.lang.Class<any>
            }
            class ValidatorException extends java.security.cert.CertificateException {
                public static T_NO_TRUST_ANCHOR: java.lang.Object
                public static T_EE_EXTENSIONS: java.lang.Object
                public static T_CA_EXTENSIONS: java.lang.Object
                public static T_CERT_EXPIRED: java.lang.Object
                public static T_SIGNATURE_ERROR: java.lang.Object
                public static T_NAME_CHAINING: java.lang.Object
                public static T_ALGORITHM_DISABLED: java.lang.Object
                public static T_UNTRUSTED_CERT: java.lang.Object
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Throwable)
                public constructor(arg0: java.lang.Object)
                public constructor(arg0: java.lang.Object, arg1: java.security.cert.X509Certificate)
                public constructor(arg0: java.lang.Object, arg1: java.security.cert.X509Certificate, arg2: java.lang.Throwable)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Object, arg2: java.security.cert.X509Certificate)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.Object, arg2: java.security.cert.X509Certificate, arg3: java.lang.Throwable)
                public getErrorType(): java.lang.Object
                public getErrorCertificate(): java.security.cert.X509Certificate
                public static class: java.lang.Class<any>
            }
        }
        namespace x509 {
            class AVA implements sun.security.util.DerEncoder {
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: sun.security.util.DerValue)
                public getObjectIdentifier(): sun.security.util.ObjectIdentifier
                public getDerValue(): sun.security.util.DerValue
                public getValueString(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public toString(): string
                public toRFC1779String(): string
                public toRFC1779String(arg0: java.util.Map<java.lang.String, java.lang.String>): string
                public toRFC2253String(): string
                public toRFC2253String(arg0: java.util.Map<java.lang.String, java.lang.String>): string
                public toRFC2253CanonicalString(): string
                public static class: java.lang.Class<any>
            }
            class AVA$$Lambda implements sun.security.util.DerEncoder {
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: sun.security.util.DerValue)
            }
            class AccessDescription {
                public static Ad_OCSP_Id: sun.security.util.ObjectIdentifier
                public static Ad_CAISSUERS_Id: sun.security.util.ObjectIdentifier
                public static Ad_TIMESTAMPING_Id: sun.security.util.ObjectIdentifier
                public static Ad_CAREPOSITORY_Id: sun.security.util.ObjectIdentifier
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: sun.security.x509.GeneralName)
                public constructor(arg0: sun.security.util.DerValue)
                public getAccessMethod(): sun.security.util.ObjectIdentifier
                public getAccessLocation(): sun.security.x509.GeneralName
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class AlgIdDSA extends sun.security.x509.AlgorithmId implements java.security.interfaces.DSAParams {
                public getP(): java.math.BigInteger
                public getQ(): java.math.BigInteger
                public getG(): java.math.BigInteger
                public constructor()
                public constructor(arg0: byte[])
                public constructor(arg0: byte[], arg1: byte[], arg2: byte[])
                public constructor(arg0: java.math.BigInteger, arg1: java.math.BigInteger, arg2: java.math.BigInteger)
                public getName(): string
                protected decodeParams(): void
                public toString(): string
                protected paramsToString(): string
            }
            class AlgorithmId implements java.io.Serializable , sun.security.util.DerEncoder {
                protected params: sun.security.util.DerValue
                public static MD2_oid: sun.security.util.ObjectIdentifier
                public static MD5_oid: sun.security.util.ObjectIdentifier
                public static SHA_oid: sun.security.util.ObjectIdentifier
                public static SHA224_oid: sun.security.util.ObjectIdentifier
                public static SHA256_oid: sun.security.util.ObjectIdentifier
                public static SHA384_oid: sun.security.util.ObjectIdentifier
                public static SHA512_oid: sun.security.util.ObjectIdentifier
                public static DH_oid: sun.security.util.ObjectIdentifier
                public static DH_PKIX_oid: sun.security.util.ObjectIdentifier
                public static DSA_oid: sun.security.util.ObjectIdentifier
                public static DSA_OIW_oid: sun.security.util.ObjectIdentifier
                public static EC_oid: sun.security.util.ObjectIdentifier
                public static ECDH_oid: sun.security.util.ObjectIdentifier
                public static RSA_oid: sun.security.util.ObjectIdentifier
                public static RSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static AES_oid: sun.security.util.ObjectIdentifier
                public static md2WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static md5WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static sha1WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static sha1WithRSAEncryption_OIW_oid: sun.security.util.ObjectIdentifier
                public static sha224WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static sha256WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static sha384WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static sha512WithRSAEncryption_oid: sun.security.util.ObjectIdentifier
                public static shaWithDSA_OIW_oid: sun.security.util.ObjectIdentifier
                public static sha1WithDSA_OIW_oid: sun.security.util.ObjectIdentifier
                public static sha1WithDSA_oid: sun.security.util.ObjectIdentifier
                public static sha224WithDSA_oid: sun.security.util.ObjectIdentifier
                public static sha256WithDSA_oid: sun.security.util.ObjectIdentifier
                public static sha1WithECDSA_oid: sun.security.util.ObjectIdentifier
                public static sha224WithECDSA_oid: sun.security.util.ObjectIdentifier
                public static sha256WithECDSA_oid: sun.security.util.ObjectIdentifier
                public static sha384WithECDSA_oid: sun.security.util.ObjectIdentifier
                public static sha512WithECDSA_oid: sun.security.util.ObjectIdentifier
                public static specifiedWithECDSA_oid: sun.security.util.ObjectIdentifier
                public static pbeWithMD5AndDES_oid: sun.security.util.ObjectIdentifier
                public static pbeWithMD5AndRC2_oid: sun.security.util.ObjectIdentifier
                public static pbeWithSHA1AndDES_oid: sun.security.util.ObjectIdentifier
                public static pbeWithSHA1AndRC2_oid: sun.security.util.ObjectIdentifier
                public static pbeWithSHA1AndDESede_oid: sun.security.util.ObjectIdentifier
                public static pbeWithSHA1AndRC2_40_oid: sun.security.util.ObjectIdentifier
                public constructor()
                public constructor(arg0: sun.security.util.ObjectIdentifier)
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: java.security.AlgorithmParameters)
                protected decodeParams(): void
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public encode(): byte[]
                public getOID(): sun.security.util.ObjectIdentifier
                public getName(): string
                public getParameters(): java.security.AlgorithmParameters
                public getEncodedParams(): byte[]
                public equals(arg0: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda): boolean
                public equals(arg0: java.lang.Object): boolean
                public equals(arg0: sun.security.util.ObjectIdentifier): boolean
                public hashCode(): int
                protected paramsToString(): string
                public toString(): string
                public static parse(arg0: sun.security.util.DerValue): sun.security.x509.AlgorithmId
                public static getAlgorithmId(arg0: java.lang.String | string): sun.security.x509.AlgorithmId
                public static get(arg0: java.lang.String | string): sun.security.x509.AlgorithmId
                public static get(arg0: java.security.AlgorithmParameters): sun.security.x509.AlgorithmId
                public static makeSigAlg(arg0: java.lang.String | string, arg1: java.lang.String | string): string
                public static getEncAlgFromSigAlg(arg0: java.lang.String | string): string
                public static getDigAlgFromSigAlg(arg0: java.lang.String | string): string
                public static class: java.lang.Class<any>
            }
            class AlgorithmId$$Lambda implements java.io.Serializable , sun.security.util.DerEncoder {
                protected params: sun.security.util.DerValue
            }
            class AttributeNameEnumeration extends java.util.Vector<java.lang.String> {
                public constructor()
                public static class: java.lang.Class<any>
            }
            class AuthorityInfoAccessExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static DESCRIPTIONS: string
                public constructor(arg0: java.util.List<sun.security.x509.AccessDescription>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public getAccessDescriptions(): java.util.List<sun.security.x509.AccessDescription>
                public getName(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.List<sun.security.x509.AccessDescription>
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public toString(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class AuthorityKeyIdentifierExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static KEY_ID: string
                public static AUTH_NAME: string
                public static SERIAL_NUMBER: string
                public constructor(arg0: sun.security.x509.KeyIdentifier, arg1: sun.security.x509.GeneralNames, arg2: sun.security.x509.SerialNumber)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public getEncodedKeyIdentifier(): byte[]
                public static class: java.lang.Class<any>
            }
            class BasicConstraintsExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static IS_CA: string
                public static PATH_LEN: string
                public constructor(arg0: boolean, arg1: int)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: boolean, arg2: int)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public static class: java.lang.Class<any>
            }
            class CRLDistributionPointsExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static POINTS: string
                public constructor(arg0: java.util.List<sun.security.x509.DistributionPoint>)
                public constructor(arg0: boolean, arg1: java.util.List<sun.security.x509.DistributionPoint>)
                protected constructor(arg0: sun.security.util.ObjectIdentifier, arg1: boolean, arg2: java.util.List<sun.security.x509.DistributionPoint>, arg3: java.lang.String | string)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                protected constructor(arg0: sun.security.util.ObjectIdentifier, arg1: java.lang.Boolean | boolean, arg2: java.lang.Object, arg3: java.lang.String | string)
                public getName(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                protected encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: sun.security.util.ObjectIdentifier, arg2: boolean): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.List<sun.security.x509.DistributionPoint>
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public toString(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CRLExtensions {
                public constructor()
                public constructor(arg0: sun.security.util.DerInputStream)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean): void
                public get(arg0: java.lang.String | string): sun.security.x509.Extension
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<sun.security.x509.Extension>
                public getAllExtensions(): java.util.Collection<sun.security.x509.Extension>
                public hasUnsupportedCriticalExtension(): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class CRLNumberExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static NAME: string
                public static NUMBER: string
                public constructor(arg0: int)
                public constructor(arg0: java.math.BigInteger)
                protected constructor(arg0: sun.security.util.ObjectIdentifier, arg1: boolean, arg2: java.math.BigInteger, arg3: java.lang.String | string, arg4: java.lang.String | string)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                protected constructor(arg0: sun.security.util.ObjectIdentifier, arg1: java.lang.Boolean | boolean, arg2: java.lang.Object, arg3: java.lang.String | string, arg4: java.lang.String | string)
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.math.BigInteger
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                protected encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: sun.security.util.ObjectIdentifier, arg2: boolean): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CRLReasonCodeExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static NAME: string
                public static REASON: string
                public constructor(arg0: int)
                public constructor(arg0: boolean, arg1: int)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Integer
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public getReasonCode(): java.security.cert.CRLReason
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            interface CertAttrSet<T> {
                toString(): string
                encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                get(arg0: java.lang.String | string): java.lang.Object
                delete(arg0: java.lang.String | string): void
                getElements(): java.util.Enumeration<T>
                getName(): string
            }
            class CertException extends java.lang.SecurityException {
                public static verf_INVALID_SIG: int
                public static verf_INVALID_REVOKED: int
                public static verf_INVALID_NOTBEFORE: int
                public static verf_INVALID_EXPIRED: int
                public static verf_CA_UNTRUSTED: int
                public static verf_CHAIN_LENGTH: int
                public static verf_PARSE_ERROR: int
                public static err_CONSTRUCTION: int
                public static err_INVALID_PUBLIC_KEY: int
                public static err_INVALID_VERSION: int
                public static err_INVALID_FORMAT: int
                public static err_ENCODING: int
                public constructor(arg0: int, arg1: java.lang.String | string)
                public constructor(arg0: int)
                public getVerfCode(): int
                public getMoreData(): string
                public getVerfDescription(): string
                public toString(): string
                public getMessage(): string
                public static class: java.lang.Class<any>
            }
            class CertParseError extends sun.security.x509.CertException {
                public static class: java.lang.Class<any>
            }
            class CertificateAlgorithmId implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static ALGORITHM: string
                public constructor(arg0: sun.security.x509.AlgorithmId | sun.security.x509.AlgorithmId$$Lambda)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: java.io.InputStream)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.AlgorithmId
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateExtensions implements sun.security.x509.CertAttrSet<sun.security.x509.Extension> {
                public static IDENT: string
                public static NAME: string
                public constructor()
                public constructor(arg0: sun.security.util.DerInputStream)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda, arg1: boolean): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.Extension
                public delete(arg0: java.lang.String | string): void
                public getNameByOid(arg0: sun.security.util.ObjectIdentifier): string
                public getElements(): java.util.Enumeration<sun.security.x509.Extension>
                public getAllExtensions(): java.util.Collection<sun.security.x509.Extension>
                public getUnparseableExtensions(): java.util.Map<java.lang.String, sun.security.x509.Extension>
                public getName(): string
                public hasUnsupportedCriticalExtension(): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateIssuerExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static NAME: string
                public static ISSUER: string
                public constructor(arg0: sun.security.x509.GeneralNames)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.GeneralNames
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateIssuerName implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static DN_NAME: string
                public static DN_PRINCIPAL: string
                public constructor(arg0: sun.security.x509.X500Name)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: java.io.InputStream)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public static class: java.lang.Class<any>
            }
            class CertificatePoliciesExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static POLICIES: string
                public constructor(arg0: java.util.List<sun.security.x509.PolicyInformation>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.util.List<sun.security.x509.PolicyInformation>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.List<sun.security.x509.PolicyInformation>
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificatePolicyId {
                public constructor(arg0: sun.security.util.ObjectIdentifier)
                public constructor(arg0: sun.security.util.DerValue)
                public getIdentifier(): sun.security.util.ObjectIdentifier
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class CertificatePolicyMap {
                public constructor(arg0: sun.security.x509.CertificatePolicyId, arg1: sun.security.x509.CertificatePolicyId)
                public constructor(arg0: sun.security.util.DerValue)
                public getIssuerIdentifier(): sun.security.x509.CertificatePolicyId
                public getSubjectIdentifier(): sun.security.x509.CertificatePolicyId
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class CertificatePolicySet {
                public constructor(arg0: java.util.Vector<sun.security.x509.CertificatePolicyId>)
                public constructor(arg0: sun.security.util.DerInputStream)
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getCertPolicyIds(): java.util.List<sun.security.x509.CertificatePolicyId>
                public static class: java.lang.Class<any>
            }
            class CertificateSerialNumber implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static NUMBER: string
                public constructor(arg0: java.math.BigInteger)
                public constructor(arg0: int)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: sun.security.util.DerValue)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.SerialNumber
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateSubjectName implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static DN_NAME: string
                public static DN_PRINCIPAL: string
                public constructor(arg0: sun.security.x509.X500Name)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: java.io.InputStream)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public static class: java.lang.Class<any>
            }
            class CertificateValidity implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static NOT_BEFORE: string
                public static NOT_AFTER: string
                public constructor()
                public constructor(arg0: java.util.Date, arg1: java.util.Date)
                public constructor(arg0: sun.security.util.DerInputStream)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.Date
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public valid(): void
                public valid(arg0: java.util.Date): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateVersion implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static V1: int
                public static V2: int
                public static V3: int
                public static IDENT: string
                public static NAME: string
                public static VERSION: string
                public constructor()
                public constructor(arg0: int)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: sun.security.util.DerValue)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Integer
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public compare(arg0: int): int
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class CertificateX509Key implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static KEY: string
                public constructor(arg0: java.security.PublicKey)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: java.io.InputStream)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.security.PublicKey
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class DNSName implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: java.lang.String | string)
                public getType(): int
                public getName(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class DeltaCRLIndicatorExtension extends sun.security.x509.CRLNumberExtension {
                public static NAME: string
                public constructor(arg0: int)
                public constructor(arg0: java.math.BigInteger)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class DistributionPoint {
                public static KEY_COMPROMISE: int
                public static CA_COMPROMISE: int
                public static AFFILIATION_CHANGED: int
                public static SUPERSEDED: int
                public static CESSATION_OF_OPERATION: int
                public static CERTIFICATE_HOLD: int
                public static PRIVILEGE_WITHDRAWN: int
                public static AA_COMPROMISE: int
                public constructor(arg0: sun.security.x509.GeneralNames, arg1: boolean[], arg2: sun.security.x509.GeneralNames)
                public constructor(arg0: sun.security.x509.RDN, arg1: boolean[], arg2: sun.security.x509.GeneralNames)
                public constructor(arg0: sun.security.util.DerValue)
                public getFullName(): sun.security.x509.GeneralNames
                public getRelativeName(): sun.security.x509.RDN
                public getReasonFlags(): boolean[]
                public getCRLIssuer(): sun.security.x509.GeneralNames
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class DistributionPointName {
                public constructor(arg0: sun.security.x509.GeneralNames)
                public constructor(arg0: sun.security.x509.RDN)
                public constructor(arg0: sun.security.util.DerValue)
                public getFullName(): sun.security.x509.GeneralNames
                public getRelativeName(): sun.security.x509.RDN
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class EDIPartyName implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: sun.security.util.DerValue)
                public getType(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getAssignerName(): string
                public getPartyName(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class ExtendedKeyUsageExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static USAGES: string
                public constructor(arg0: java.util.Vector<sun.security.util.ObjectIdentifier>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.util.Vector<sun.security.util.ObjectIdentifier>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.Vector<sun.security.util.ObjectIdentifier>
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public getExtendedKeyUsage(): java.util.List<java.lang.String>
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class Extension implements java.security.cert.Extension {
                protected extensionId: sun.security.util.ObjectIdentifier
                protected critical: boolean
                protected extensionValue: byte[]
                public constructor()
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: boolean, arg2: byte[])
                public constructor(arg0: sun.security.x509.Extension)
                public static newExtension(arg0: sun.security.util.ObjectIdentifier, arg1: boolean, arg2: byte[]): sun.security.x509.Extension
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public isCritical(): boolean
                public getExtensionId(): sun.security.util.ObjectIdentifier
                public getValue(): byte[]
                public getExtensionValue(): byte[]
                public getId(): string
                public toString(): string
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public static class: java.lang.Class<any>
            }
            class FreshestCRLExtension extends sun.security.x509.CRLDistributionPointsExtension {
                public static NAME: string
                public constructor(arg0: java.util.List<sun.security.x509.DistributionPoint>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class GeneralName {
                public constructor(arg0: sun.security.x509.GeneralNameInterface)
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: sun.security.util.DerValue, arg1: boolean)
                public getType(): int
                public getName(): sun.security.x509.GeneralNameInterface
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            interface GeneralNameInterface {
                NAME_ANY: int
                NAME_RFC822: int
                NAME_DNS: int
                NAME_X400: int
                NAME_DIRECTORY: int
                NAME_EDI: int
                NAME_URI: int
                NAME_IP: int
                NAME_OID: int
                NAME_DIFF_TYPE: int
                NAME_MATCH: int
                NAME_NARROWS: int
                NAME_WIDENS: int
                NAME_SAME_TYPE: int
                getType(): int
                encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                constrains(arg0: sun.security.x509.GeneralNameInterface): int
                subtreeDepth(): int
            }
            class GeneralNames {
                public constructor(arg0: sun.security.util.DerValue)
                public constructor()
                public add(arg0: sun.security.x509.GeneralName): sun.security.x509.GeneralNames
                public get(arg0: int): sun.security.x509.GeneralName
                public isEmpty(): boolean
                public size(): int
                public iterator(): java.util.Iterator<sun.security.x509.GeneralName>
                public names(): java.util.List<sun.security.x509.GeneralName>
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class GeneralSubtree {
                public constructor(arg0: sun.security.x509.GeneralName, arg1: int, arg2: int)
                public constructor(arg0: sun.security.util.DerValue)
                public getName(): sun.security.x509.GeneralName
                public getMinimum(): int
                public getMaximum(): int
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class GeneralSubtrees implements java.lang.Cloneable {
                public constructor()
                public constructor(arg0: sun.security.util.DerValue)
                public get(arg0: int): sun.security.x509.GeneralSubtree
                public remove(arg0: int): void
                public add(arg0: sun.security.x509.GeneralSubtree): void
                public contains(arg0: sun.security.x509.GeneralSubtree): boolean
                public size(): int
                public iterator(): java.util.Iterator<sun.security.x509.GeneralSubtree>
                public trees(): java.util.List<sun.security.x509.GeneralSubtree>
                public clone(): java.lang.Object
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public intersect(arg0: sun.security.x509.GeneralSubtrees): sun.security.x509.GeneralSubtrees
                public union(arg0: sun.security.x509.GeneralSubtrees): void
                public reduce(arg0: sun.security.x509.GeneralSubtrees): void
                public static class: java.lang.Class<any>
            }
            class IPAddressName implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: byte[])
                public constructor(arg0: java.lang.String | string)
                public getType(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public toString(): string
                public getName(): string
                public getBytes(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class InhibitAnyPolicyExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static AnyPolicy_Id: sun.security.util.ObjectIdentifier
                public static NAME: string
                public static SKIP_CERTS: string
                public constructor(arg0: int)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Integer
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class InvalidityDateExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static NAME: string
                public static DATE: string
                public constructor(arg0: java.util.Date)
                public constructor(arg0: boolean, arg1: java.util.Date)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.Date
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public static toImpl(arg0: java.security.cert.Extension): sun.security.x509.InvalidityDateExtension
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class IssuerAlternativeNameExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static ISSUER_NAME: string
                public constructor(arg0: sun.security.x509.GeneralNames)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: sun.security.x509.GeneralNames)
                public constructor()
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.GeneralNames
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class IssuingDistributionPointExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static POINT: string
                public static REASONS: string
                public static ONLY_USER_CERTS: string
                public static ONLY_CA_CERTS: string
                public static ONLY_ATTRIBUTE_CERTS: string
                public static INDIRECT_CRL: string
                public constructor(arg0: sun.security.x509.DistributionPointName, arg1: sun.security.x509.ReasonFlags, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public getName(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class KeyIdentifier {
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: java.security.PublicKey)
                public getIdentifier(): byte[]
                public toString(): string
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public static class: java.lang.Class<any>
            }
            class KeyUsageExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static DIGITAL_SIGNATURE: string
                public static NON_REPUDIATION: string
                public static KEY_ENCIPHERMENT: string
                public static DATA_ENCIPHERMENT: string
                public static KEY_AGREEMENT: string
                public static KEY_CERTSIGN: string
                public static CRL_SIGN: string
                public static ENCIPHER_ONLY: string
                public static DECIPHER_ONLY: string
                public constructor(arg0: byte[])
                public constructor(arg0: boolean[])
                public constructor(arg0: sun.security.util.BitArray)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public constructor()
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): boolean
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getBits(): boolean[]
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class NameConstraintsExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> , java.lang.Cloneable {
                public static IDENT: string
                public static NAME: string
                public static PERMITTED_SUBTREES: string
                public static EXCLUDED_SUBTREES: string
                public constructor(arg0: sun.security.x509.GeneralSubtrees, arg1: sun.security.x509.GeneralSubtrees)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.GeneralSubtrees
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public merge(arg0: sun.security.x509.NameConstraintsExtension): void
                public verify(arg0: java.security.cert.X509Certificate): boolean
                public verify(arg0: sun.security.x509.GeneralNameInterface): boolean
                public clone(): java.lang.Object
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class NetscapeCertTypeExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static SSL_CLIENT: string
                public static SSL_SERVER: string
                public static S_MIME: string
                public static OBJECT_SIGNING: string
                public static SSL_CA: string
                public static S_MIME_CA: string
                public static OBJECT_SIGNING_CA: string
                public static NetscapeCertType_Id: sun.security.util.ObjectIdentifier
                public constructor(arg0: byte[])
                public constructor(arg0: boolean[])
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public constructor()
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): boolean
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public getKeyUsageMappedBits(): boolean[]
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class OCSPNoCheckExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public constructor()
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public static class: java.lang.Class<any>
            }
            class OIDMap {
                public static addAttribute(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.Class<any>): void
                public static getName(arg0: sun.security.util.ObjectIdentifier): string
                public static getOID(arg0: java.lang.String | string): sun.security.util.ObjectIdentifier
                public static getClass(arg0: java.lang.String | string): java.lang.Class<any>
                public static getClass(arg0: sun.security.util.ObjectIdentifier): java.lang.Class<any>
                public static class: java.lang.Class<any>
            }
            class OIDName implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: sun.security.util.ObjectIdentifier)
                public constructor(arg0: java.lang.String | string)
                public getType(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public toString(): string
                public getOID(): sun.security.util.ObjectIdentifier
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class OtherName implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: sun.security.util.ObjectIdentifier, arg1: byte[])
                public constructor(arg0: sun.security.util.DerValue)
                public getOID(): sun.security.util.ObjectIdentifier
                public getNameValue(): byte[]
                public getType(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class PKIXExtensions {
                public static AuthorityKey_Id: sun.security.util.ObjectIdentifier
                public static SubjectKey_Id: sun.security.util.ObjectIdentifier
                public static KeyUsage_Id: sun.security.util.ObjectIdentifier
                public static PrivateKeyUsage_Id: sun.security.util.ObjectIdentifier
                public static CertificatePolicies_Id: sun.security.util.ObjectIdentifier
                public static PolicyMappings_Id: sun.security.util.ObjectIdentifier
                public static SubjectAlternativeName_Id: sun.security.util.ObjectIdentifier
                public static IssuerAlternativeName_Id: sun.security.util.ObjectIdentifier
                public static SubjectDirectoryAttributes_Id: sun.security.util.ObjectIdentifier
                public static BasicConstraints_Id: sun.security.util.ObjectIdentifier
                public static NameConstraints_Id: sun.security.util.ObjectIdentifier
                public static PolicyConstraints_Id: sun.security.util.ObjectIdentifier
                public static CRLDistributionPoints_Id: sun.security.util.ObjectIdentifier
                public static CRLNumber_Id: sun.security.util.ObjectIdentifier
                public static IssuingDistributionPoint_Id: sun.security.util.ObjectIdentifier
                public static DeltaCRLIndicator_Id: sun.security.util.ObjectIdentifier
                public static ReasonCode_Id: sun.security.util.ObjectIdentifier
                public static HoldInstructionCode_Id: sun.security.util.ObjectIdentifier
                public static InvalidityDate_Id: sun.security.util.ObjectIdentifier
                public static ExtendedKeyUsage_Id: sun.security.util.ObjectIdentifier
                public static InhibitAnyPolicy_Id: sun.security.util.ObjectIdentifier
                public static CertificateIssuer_Id: sun.security.util.ObjectIdentifier
                public static AuthInfoAccess_Id: sun.security.util.ObjectIdentifier
                public static SubjectInfoAccess_Id: sun.security.util.ObjectIdentifier
                public static FreshestCRL_Id: sun.security.util.ObjectIdentifier
                public static OCSPNoCheck_Id: sun.security.util.ObjectIdentifier
                public static OCSPNonce_Id: sun.security.util.ObjectIdentifier
                public constructor()
                public static class: java.lang.Class<any>
            }
            class PolicyConstraintsExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static REQUIRE: string
                public static INHIBIT: string
                public constructor(arg0: int, arg1: int)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: int, arg2: int)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Integer
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class PolicyInformation {
                public static NAME: string
                public static ID: string
                public static QUALIFIERS: string
                public constructor(arg0: sun.security.x509.CertificatePolicyId, arg1: java.util.Set<java.security.cert.PolicyQualifierInfo>)
                public constructor(arg0: sun.security.util.DerValue)
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public getPolicyIdentifier(): sun.security.x509.CertificatePolicyId
                public getPolicyQualifiers(): java.util.Set<java.security.cert.PolicyQualifierInfo>
                public get(arg0: java.lang.String | string): java.lang.Object
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class PolicyMappingsExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static MAP: string
                public constructor(arg0: java.util.List<sun.security.x509.CertificatePolicyMap>)
                public constructor()
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.List<sun.security.x509.CertificatePolicyMap>
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class PrivateKeyUsageExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static NOT_BEFORE: string
                public static NOT_AFTER: string
                public constructor(arg0: java.util.Date, arg1: java.util.Date)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public valid(): void
                public valid(arg0: java.util.Date): void
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.Date
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class RDN {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.util.Map<java.lang.String, java.lang.String>)
                public constructor(arg0: sun.security.x509.AVA | sun.security.x509.AVA$$Lambda)
                public constructor(arg0: sun.security.x509.AVA[])
                public avas(): java.util.List<sun.security.x509.AVA>
                public size(): int
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public toRFC1779String(): string
                public toRFC1779String(arg0: java.util.Map<java.lang.String, java.lang.String>): string
                public toRFC2253String(): string
                public toRFC2253String(arg0: java.util.Map<java.lang.String, java.lang.String>): string
                public toRFC2253String(arg0: boolean): string
                public static class: java.lang.Class<any>
            }
            class RFC822Name implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: java.lang.String | string)
                public parseName(arg0: java.lang.String | string): void
                public getType(): int
                public getName(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class ReasonFlags {
                public static UNUSED: string
                public static KEY_COMPROMISE: string
                public static CA_COMPROMISE: string
                public static AFFILIATION_CHANGED: string
                public static SUPERSEDED: string
                public static CESSATION_OF_OPERATION: string
                public static CERTIFICATE_HOLD: string
                public static PRIVILEGE_WITHDRAWN: string
                public static AA_COMPROMISE: string
                public constructor(arg0: byte[])
                public constructor(arg0: boolean[])
                public constructor(arg0: sun.security.util.BitArray)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerValue)
                public getFlags(): boolean[]
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public delete(arg0: java.lang.String | string): void
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public static class: java.lang.Class<any>
            }
            class SerialNumber {
                public constructor(arg0: java.math.BigInteger)
                public constructor(arg0: int)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: java.io.InputStream)
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getNumber(): java.math.BigInteger
                public static class: java.lang.Class<any>
            }
            class SubjectAlternativeNameExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static SUBJECT_NAME: string
                public constructor(arg0: sun.security.x509.GeneralNames)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: sun.security.x509.GeneralNames)
                public constructor()
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.GeneralNames
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class SubjectInfoAccessExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static DESCRIPTIONS: string
                public constructor(arg0: java.util.List<sun.security.x509.AccessDescription>)
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public getAccessDescriptions(): java.util.List<sun.security.x509.AccessDescription>
                public getName(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): java.util.List<sun.security.x509.AccessDescription>
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public toString(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class SubjectKeyIdentifierExtension extends sun.security.x509.Extension implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static KEY_ID: string
                public constructor(arg0: byte[])
                public constructor(arg0: java.lang.Boolean | boolean, arg1: java.lang.Object)
                public toString(): string
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public get(arg0: java.lang.String | string): sun.security.x509.KeyIdentifier
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class URIName implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: java.lang.String | string)
                public static nameConstraint(arg0: sun.security.util.DerValue): sun.security.x509.URIName
                public getType(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public toString(): string
                public equals(arg0: java.lang.Object): boolean
                public getURI(): java.net.URI
                public getName(): string
                public getScheme(): string
                public getHost(): string
                public getHostObject(): java.lang.Object
                public hashCode(): int
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class UniqueIdentity {
                public constructor(arg0: sun.security.util.BitArray)
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: sun.security.util.DerValue)
                public toString(): string
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda, arg1: byte): void
                public getId(): boolean[]
                public static class: java.lang.Class<any>
            }
            class X400Address implements sun.security.x509.GeneralNameInterface {
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerValue)
                public getType(): int
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public toString(): string
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public static class: java.lang.Class<any>
            }
            class X500Name implements sun.security.x509.GeneralNameInterface , java.security.Principal {
                public static commonName_oid: sun.security.util.ObjectIdentifier
                public static countryName_oid: sun.security.util.ObjectIdentifier
                public static localityName_oid: sun.security.util.ObjectIdentifier
                public static orgName_oid: sun.security.util.ObjectIdentifier
                public static orgUnitName_oid: sun.security.util.ObjectIdentifier
                public static stateName_oid: sun.security.util.ObjectIdentifier
                public static streetAddress_oid: sun.security.util.ObjectIdentifier
                public static title_oid: sun.security.util.ObjectIdentifier
                public static DNQUALIFIER_OID: sun.security.util.ObjectIdentifier
                public static SURNAME_OID: sun.security.util.ObjectIdentifier
                public static GIVENNAME_OID: sun.security.util.ObjectIdentifier
                public static INITIALS_OID: sun.security.util.ObjectIdentifier
                public static GENERATIONQUALIFIER_OID: sun.security.util.ObjectIdentifier
                public static ipAddress_oid: sun.security.util.ObjectIdentifier
                public static DOMAIN_COMPONENT_OID: sun.security.util.ObjectIdentifier
                public static userid_oid: sun.security.util.ObjectIdentifier
                public static SERIALNUMBER_OID: sun.security.util.ObjectIdentifier
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.util.Map<java.lang.String, java.lang.String>)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string, arg4: java.lang.String | string, arg5: java.lang.String | string)
                public constructor(arg0: sun.security.x509.RDN[])
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: sun.security.util.DerInputStream)
                public constructor(arg0: byte[])
                public rdns(): java.util.List<sun.security.x509.RDN>
                public size(): int
                public allAvas(): java.util.List<sun.security.x509.AVA>
                public avaSize(): int
                public isEmpty(): boolean
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public getType(): int
                public getCountry(): string
                public getOrganization(): string
                public getOrganizationalUnit(): string
                public getCommonName(): string
                public getLocality(): string
                public getState(): string
                public getDomain(): string
                public getDNQualifier(): string
                public getSurname(): string
                public getGivenName(): string
                public getInitials(): string
                public getGeneration(): string
                public getIP(): string
                public toString(): string
                public getRFC1779Name(): string
                public getRFC1779Name(arg0: java.util.Map<java.lang.String, java.lang.String>): string
                public getRFC2253Name(): string
                public getRFC2253Name(arg0: java.util.Map<java.lang.String, java.lang.String>): string
                public getRFC2253CanonicalName(): string
                public getName(): string
                public findMostSpecificAttribute(arg0: sun.security.util.ObjectIdentifier): sun.security.util.DerValue
                public emit(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getEncodedInternal(): byte[]
                public getEncoded(): byte[]
                public constrains(arg0: sun.security.x509.GeneralNameInterface): int
                public subtreeDepth(): int
                public commonAncestor(arg0: sun.security.x509.X500Name): sun.security.x509.X500Name
                public asX500Principal(): javax.security.auth.x500.X500Principal
                public static asX500Name(arg0: javax.security.auth.x500.X500Principal): sun.security.x509.X500Name
                public static class: java.lang.Class<any>
            }
            class X509AttributeName {
                public constructor(arg0: java.lang.String | string)
                public getPrefix(): string
                public getSuffix(): string
                public static class: java.lang.Class<any>
            }
            class X509CRLEntryImpl extends java.security.cert.X509CRLEntry implements java.lang.Comparable<sun.security.x509.X509CRLEntryImpl> {
                public constructor(arg0: java.math.BigInteger, arg1: java.util.Date)
                public constructor(arg0: java.math.BigInteger, arg1: java.util.Date, arg2: sun.security.x509.CRLExtensions)
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerValue)
                public hasExtensions(): boolean
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getEncoded(): byte[]
                public getCertificateIssuer(): javax.security.auth.x500.X500Principal
                public getSerialNumber(): java.math.BigInteger
                public getRevocationDate(): java.util.Date
                public getRevocationReason(): java.security.cert.CRLReason
                public static getRevocationReason(arg0: java.security.cert.X509CRLEntry): java.security.cert.CRLReason
                public getReasonCode(): java.lang.Integer
                public toString(): string
                public hasUnsupportedCriticalExtension(): boolean
                public getCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                public getNonCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                public getExtensionValue(arg0: java.lang.String | string): byte[]
                public getExtension(arg0: sun.security.util.ObjectIdentifier): sun.security.x509.Extension
                public static toImpl(arg0: java.security.cert.X509CRLEntry): sun.security.x509.X509CRLEntryImpl
                public getExtensions(): java.util.Map<java.lang.String, java.security.cert.Extension>
                public compareTo(arg0: sun.security.x509.X509CRLEntryImpl): int
                public compareTo(arg0: java.lang.Object): int
                public static class: java.lang.Class<any>
            }
            class X509CRLImpl extends java.security.cert.X509CRL implements sun.security.util.DerEncoder {
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerValue)
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: sun.security.x509.X500Name, arg1: java.util.Date, arg2: java.util.Date)
                public constructor(arg0: sun.security.x509.X500Name, arg1: java.util.Date, arg2: java.util.Date, arg3: java.security.cert.X509CRLEntry[])
                public constructor(arg0: sun.security.x509.X500Name, arg1: java.util.Date, arg2: java.util.Date, arg3: java.security.cert.X509CRLEntry[], arg4: sun.security.x509.CRLExtensions)
                public getEncodedInternal(): byte[]
                public getEncoded(): byte[]
                public encodeInfo(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public verify(arg0: java.security.PublicKey): void
                public verify(arg0: java.security.PublicKey, arg1: java.lang.String | string): void
                public verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void
                public static verify(arg0: java.security.cert.X509CRL, arg1: java.security.PublicKey, arg2: java.security.Provider): void
                public sign(arg0: java.security.PrivateKey, arg1: java.lang.String | string): void
                public sign(arg0: java.security.PrivateKey, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                public toString(): string
                public toStringWithAlgName(arg0: java.lang.String | string): string
                public isRevoked(arg0: java.security.cert.Certificate): boolean
                public getVersion(): int
                public getIssuerDN(): java.security.Principal
                public getIssuerX500Principal(): javax.security.auth.x500.X500Principal
                public getThisUpdate(): java.util.Date
                public getNextUpdate(): java.util.Date
                public getRevokedCertificate(arg0: java.math.BigInteger): java.security.cert.X509CRLEntry
                public getRevokedCertificate(arg0: java.security.cert.X509Certificate): java.security.cert.X509CRLEntry
                public getRevokedCertificates(): java.util.Set<java.security.cert.X509CRLEntry>
                public getTBSCertList(): byte[]
                public getSignature(): byte[]
                public getSigAlgName(): string
                public getSigAlgOID(): string
                public getSigAlgParams(): byte[]
                public getSigAlgId(): sun.security.x509.AlgorithmId
                public getAuthKeyId(): sun.security.x509.KeyIdentifier
                public getAuthKeyIdExtension(): sun.security.x509.AuthorityKeyIdentifierExtension
                public getCRLNumberExtension(): sun.security.x509.CRLNumberExtension
                public getCRLNumber(): java.math.BigInteger
                public getDeltaCRLIndicatorExtension(): sun.security.x509.DeltaCRLIndicatorExtension
                public getBaseCRLNumber(): java.math.BigInteger
                public getIssuerAltNameExtension(): sun.security.x509.IssuerAlternativeNameExtension
                public getIssuingDistributionPointExtension(): sun.security.x509.IssuingDistributionPointExtension
                public hasUnsupportedCriticalExtension(): boolean
                public getCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                public getNonCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                public getExtensionValue(arg0: java.lang.String | string): byte[]
                public getExtension(arg0: sun.security.util.ObjectIdentifier): java.lang.Object
                public static getIssuerX500Principal(arg0: java.security.cert.X509CRL): javax.security.auth.x500.X500Principal
                public static getEncodedInternal(arg0: java.security.cert.X509CRL): byte[]
                public static toImpl(arg0: java.security.cert.X509CRL): sun.security.x509.X509CRLImpl
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public static class: java.lang.Class<any>
            }
            class X509CRLImpl$$Lambda extends java.security.cert.X509CRL implements sun.security.util.DerEncoder {
                public constructor(arg0: byte[])
            }
            class X509CertImpl extends java.security.cert.X509Certificate implements sun.security.util.DerEncoder {
                public static NAME: string
                public static INFO: string
                public static ALG_ID: string
                public static SIGNATURE: string
                public static SIGNED_CERT: string
                public static SUBJECT_DN: string
                public static ISSUER_DN: string
                public static SERIAL_ID: string
                public static PUBLIC_KEY: string
                public static VERSION: string
                public static SIG_ALG: string
                public static SIG: string
                protected info: sun.security.x509.X509CertInfo
                protected algId: sun.security.x509.AlgorithmId
                protected signature: byte[]
                public constructor()
                public constructor(arg0: byte[])
                public constructor(arg0: java.io.InputStream)
                public constructor(arg0: sun.security.x509.X509CertInfo)
                public constructor(arg0: sun.security.util.DerValue)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public derEncode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getEncoded(): byte[]
                public getEncodedInternal(): byte[]
                public verify(arg0: java.security.PublicKey): void
                public verify(arg0: java.security.PublicKey, arg1: java.lang.String | string): void
                public verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void
                public static verify(arg0: java.security.cert.X509Certificate, arg1: java.security.PublicKey, arg2: java.security.Provider): void
                public sign(arg0: java.security.PrivateKey, arg1: java.lang.String | string): void
                public sign(arg0: java.security.PrivateKey, arg1: java.lang.String | string, arg2: java.lang.String | string): void
                public checkValidity(): void
                public checkValidity(arg0: java.util.Date): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public delete(arg0: java.lang.String | string): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public toString(): string
                public getPublicKey(): java.security.PublicKey
                public getVersion(): int
                public getSerialNumber(): java.math.BigInteger
                public getSerialNumberObject(): sun.security.x509.SerialNumber
                public getSubjectDN(): java.security.Principal
                public getSubjectX500Principal(): javax.security.auth.x500.X500Principal
                public getIssuerDN(): java.security.Principal
                public getIssuerX500Principal(): javax.security.auth.x500.X500Principal
                public getNotBefore(): java.util.Date
                public getNotAfter(): java.util.Date
                public getTBSCertificate(): byte[]
                public getSignature(): byte[]
                public getSigAlgName(): string
                public getSigAlgOID(): string
                public getSigAlgParams(): byte[]
                public getIssuerUniqueID(): boolean[]
                public getSubjectUniqueID(): boolean[]
                public getAuthKeyId(): sun.security.x509.KeyIdentifier
                public getSubjectKeyId(): sun.security.x509.KeyIdentifier
                public getAuthorityKeyIdentifierExtension(): sun.security.x509.AuthorityKeyIdentifierExtension
                public getBasicConstraintsExtension(): sun.security.x509.BasicConstraintsExtension
                public getCertificatePoliciesExtension(): sun.security.x509.CertificatePoliciesExtension
                public getExtendedKeyUsageExtension(): sun.security.x509.ExtendedKeyUsageExtension
                public getIssuerAlternativeNameExtension(): sun.security.x509.IssuerAlternativeNameExtension
                public getNameConstraintsExtension(): sun.security.x509.NameConstraintsExtension
                public getPolicyConstraintsExtension(): sun.security.x509.PolicyConstraintsExtension
                public getPolicyMappingsExtension(): sun.security.x509.PolicyMappingsExtension
                public getPrivateKeyUsageExtension(): sun.security.x509.PrivateKeyUsageExtension
                public getSubjectAlternativeNameExtension(): sun.security.x509.SubjectAlternativeNameExtension
                public getSubjectKeyIdentifierExtension(): sun.security.x509.SubjectKeyIdentifierExtension
                public getCRLDistributionPointsExtension(): sun.security.x509.CRLDistributionPointsExtension
                public hasUnsupportedCriticalExtension(): boolean
                public getCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                public getNonCriticalExtensionOIDs(): java.util.Set<java.lang.String>
                public getExtension(arg0: sun.security.util.ObjectIdentifier): sun.security.x509.Extension
                public getUnparseableExtension(arg0: sun.security.util.ObjectIdentifier): sun.security.x509.Extension
                public getExtensionValue(arg0: java.lang.String | string): byte[]
                public getKeyUsage(): boolean[]
                public getExtendedKeyUsage(): java.util.List<java.lang.String>
                public static getExtendedKeyUsage(arg0: java.security.cert.X509Certificate): java.util.List<java.lang.String>
                public getBasicConstraints(): int
                public getSubjectAlternativeNames(): java.util.Collection<java.util.List<any>>
                public static getSubjectAlternativeNames(arg0: java.security.cert.X509Certificate): java.util.Collection<java.util.List<any>>
                public getIssuerAlternativeNames(): java.util.Collection<java.util.List<any>>
                public static getIssuerAlternativeNames(arg0: java.security.cert.X509Certificate): java.util.Collection<java.util.List<any>>
                public getAuthorityInfoAccessExtension(): sun.security.x509.AuthorityInfoAccessExtension
                public static getSubjectX500Principal(arg0: java.security.cert.X509Certificate): javax.security.auth.x500.X500Principal
                public static getIssuerX500Principal(arg0: java.security.cert.X509Certificate): javax.security.auth.x500.X500Principal
                public static getEncodedInternal(arg0: java.security.cert.Certificate): byte[]
                public static toImpl(arg0: java.security.cert.X509Certificate): sun.security.x509.X509CertImpl
                public static isSelfIssued(arg0: java.security.cert.X509Certificate): boolean
                public static isSelfSigned(arg0: java.security.cert.X509Certificate, arg1: java.lang.String | string): boolean
                public getFingerprint(arg0: java.lang.String | string): string
                public static getFingerprint(arg0: java.lang.String | string, arg1: java.security.cert.X509Certificate): string
                public static class: java.lang.Class<any>
            }
            class X509CertImpl$$Lambda extends java.security.cert.X509Certificate implements sun.security.util.DerEncoder {
                public static NAME: string
            }
            class X509CertInfo implements sun.security.x509.CertAttrSet<java.lang.String> {
                public static IDENT: string
                public static NAME: string
                public static DN_NAME: string
                public static VERSION: string
                public static SERIAL_NUMBER: string
                public static ALGORITHM_ID: string
                public static ISSUER: string
                public static SUBJECT: string
                public static VALIDITY: string
                public static KEY: string
                public static ISSUER_ID: string
                public static SUBJECT_ID: string
                public static EXTENSIONS: string
                protected version: sun.security.x509.CertificateVersion
                protected serialNum: sun.security.x509.CertificateSerialNumber
                protected algId: sun.security.x509.CertificateAlgorithmId
                protected issuer: sun.security.x509.X500Name
                protected subject: sun.security.x509.X500Name
                protected interval: sun.security.x509.CertificateValidity
                protected pubKey: sun.security.x509.CertificateX509Key
                protected issuerUniqueId: sun.security.x509.UniqueIdentity
                protected subjectUniqueId: sun.security.x509.UniqueIdentity
                protected extensions: sun.security.x509.CertificateExtensions
                public constructor()
                public constructor(arg0: byte[])
                public constructor(arg0: sun.security.util.DerValue)
                public encode(arg0: java.io.OutputStream | java.io.OutputStream$$Lambda): void
                public getElements(): java.util.Enumeration<java.lang.String>
                public getName(): string
                public getEncodedInfo(): byte[]
                public equals(arg0: java.lang.Object): boolean
                public equals(arg0: sun.security.x509.X509CertInfo): boolean
                public hashCode(): int
                public toString(): string
                public set(arg0: java.lang.String | string, arg1: java.lang.Object): void
                public delete(arg0: java.lang.String | string): void
                public get(arg0: java.lang.String | string): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class X509Key implements java.security.PublicKey {
                protected algid: sun.security.x509.AlgorithmId
                protected key: byte[]
                protected encodedKey: byte[]
                public constructor()
                protected setKey(arg0: sun.security.util.BitArray): void
                protected getKey(): sun.security.util.BitArray
                public static parse(arg0: sun.security.util.DerValue): java.security.PublicKey
                protected parseKeyBits(): void
                public getAlgorithm(): string
                public getAlgorithmId(): sun.security.x509.AlgorithmId
                public encode(arg0: sun.security.util.DerOutputStream | sun.security.util.DerOutputStream$$Lambda): void
                public getEncoded(): byte[]
                public getEncodedInternal(): byte[]
                public getFormat(): string
                public encode(): byte[]
                public toString(): string
                public decode(arg0: java.io.InputStream): void
                public decode(arg0: byte[]): void
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
        }
    }
    namespace text {
        namespace bidi {
            class BidiBase {
                public static INTERNAL_LEVEL_DEFAULT_LTR: byte
                public static INTERNAL_LEVEL_DEFAULT_RTL: byte
                public static MAX_EXPLICIT_LEVEL: byte
                public static INTERNAL_LEVEL_OVERRIDE: byte
                public static MAP_NOWHERE: int
                public static MIXED: byte
                public static DO_MIRRORING: short
                public length: int
                public verifyValidPara(): void
                public verifyValidParaOrLine(): void
                public verifyRange(arg0: int, arg1: int, arg2: int): void
                public verifyIndex(arg0: int, arg1: int, arg2: int): void
                public constructor(arg0: int, arg1: int)
                public setPara(arg0: char[], arg1: byte, arg2: byte[]): void
                public setPara(arg0: java.text.AttributedCharacterIterator): void
                public getLength(): int
                public getParaLevel(): byte
                public getParagraphIndex(arg0: int): int
                public setLine(arg0: java.text.Bidi, arg1: sun.text.bidi.BidiBase, arg2: java.text.Bidi, arg3: sun.text.bidi.BidiBase, arg4: int, arg5: int): java.text.Bidi
                public getLevelAt(arg0: int): byte
                public countRuns(): int
                public constructor(arg0: char[], arg1: int, arg2: byte[], arg3: int, arg4: int, arg5: int)
                public isMixed(): boolean
                public isLeftToRight(): boolean
                public isRightToLeft(): boolean
                public baseIsLeftToRight(): boolean
                public getBaseLevel(): int
                public getRunLevel(arg0: int): int
                public getRunStart(arg0: int): int
                public getRunLimit(arg0: int): int
                public static requiresBidi(arg0: char[], arg1: int, arg2: int): boolean
                public static reorderVisually(arg0: byte[], arg1: int, arg2: java.lang.Object[], arg3: int, arg4: int): void
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class BidiLine {
                public constructor()
                public static setLine(arg0: java.text.Bidi, arg1: sun.text.bidi.BidiBase, arg2: java.text.Bidi, arg3: sun.text.bidi.BidiBase, arg4: int, arg5: int): java.text.Bidi
                public static class: java.lang.Class<any>
            }
            class BidiRun {
                public getEmbeddingLevel(): byte
                public static class: java.lang.Class<any>
            }
        }
        namespace normalizer {
            class CharTrie extends sun.text.normalizer.Trie {
                public constructor(arg0: java.io.InputStream, arg1: sun.text.normalizer.Trie$DataManipulate)
                public constructor(arg0: int, arg1: int, arg2: sun.text.normalizer.Trie$DataManipulate)
                public putIndexData(arg0: sun.text.normalizer.UCharacterProperty): void
                public getCodePointValue(arg0: int): char
                public getLeadValue(arg0: char): char
                public getSurrogateValue(arg0: char, arg1: char): char
                public getTrailValue(arg0: int, arg1: char): char
                protected unserialize(arg0: java.io.InputStream): void
                protected getSurrogateOffset(arg0: char, arg1: char): int
                protected getValue(arg0: int): int
                protected getInitialValue(): int
                public static class: java.lang.Class<any>
            }
            class CharacterIteratorWrapper extends sun.text.normalizer.UCharacterIterator {
                public constructor(arg0: java.text.CharacterIterator)
                public current(): int
                public getLength(): int
                public getIndex(): int
                public next(): int
                public previous(): int
                public setIndex(arg0: int): void
                public getText(arg0: char[], arg1: int): int
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class ICUBinary {
                public constructor()
                public static readHeader(arg0: java.io.InputStream, arg1: byte[], arg2: sun.text.normalizer.ICUBinary$Authenticate): byte[]
                public static class: java.lang.Class<any>
            }
            class NormalizerBase implements java.lang.Cloneable {
                public static UNICODE_3_2: int
                public static DONE: int
                public static NONE: sun.text.normalizer.NormalizerBase$Mode
                public static NFD: sun.text.normalizer.NormalizerBase$Mode
                public static NFKD: sun.text.normalizer.NormalizerBase$Mode
                public static NFC: sun.text.normalizer.NormalizerBase$Mode
                public static NFKC: sun.text.normalizer.NormalizerBase$Mode
                public static NO: sun.text.normalizer.NormalizerBase$QuickCheckResult
                public static YES: sun.text.normalizer.NormalizerBase$QuickCheckResult
                public static MAYBE: sun.text.normalizer.NormalizerBase$QuickCheckResult
                public static UNICODE_3_2_0_ORIGINAL: int
                public static UNICODE_LATEST: int
                public constructor(arg0: java.lang.String | string, arg1: sun.text.normalizer.NormalizerBase$Mode, arg2: int)
                public constructor(arg0: java.text.CharacterIterator, arg1: sun.text.normalizer.NormalizerBase$Mode)
                public constructor(arg0: java.text.CharacterIterator, arg1: sun.text.normalizer.NormalizerBase$Mode, arg2: int)
                public clone(): java.lang.Object
                public static compose(arg0: java.lang.String | string, arg1: boolean, arg2: int): string
                public static decompose(arg0: java.lang.String | string, arg1: boolean): string
                public static decompose(arg0: java.lang.String | string, arg1: boolean, arg2: int): string
                public static normalize(arg0: char[], arg1: int, arg2: int, arg3: char[], arg4: int, arg5: int, arg6: sun.text.normalizer.NormalizerBase$Mode, arg7: int): int
                public current(): int
                public next(): int
                public previous(): int
                public reset(): void
                public setIndexOnly(arg0: int): void
                public setIndex(arg0: int): int
                public getBeginIndex(): int
                public getEndIndex(): int
                public getIndex(): int
                public endIndex(): int
                public setMode(arg0: sun.text.normalizer.NormalizerBase$Mode): void
                public getMode(): sun.text.normalizer.NormalizerBase$Mode
                public setText(arg0: java.lang.String | string): void
                public setText(arg0: java.text.CharacterIterator): void
                public static isNFSkippable(arg0: int, arg1: sun.text.normalizer.NormalizerBase$Mode): boolean
                public constructor(arg0: java.lang.String | string, arg1: sun.text.normalizer.NormalizerBase$Mode)
                public static normalize(arg0: java.lang.String | string, arg1: java.text.Normalizer$Form): string
                public static normalize(arg0: java.lang.String | string, arg1: java.text.Normalizer$Form, arg2: int): string
                public static isNormalized(arg0: java.lang.String | string, arg1: java.text.Normalizer$Form): boolean
                public static isNormalized(arg0: java.lang.String | string, arg1: java.text.Normalizer$Form, arg2: int): boolean
                public static class: java.lang.Class<any>
            }
            class NormalizerImpl {
                public static QC_NFC: int
                public static QC_NFKC: int
                public static QC_NFD: int
                public static QC_NFKD: int
                public static QC_ANY_NO: int
                public static QC_MAYBE: int
                public static QC_ANY_MAYBE: int
                public static QC_MASK: int
                public static COMBINES_ANY: int
                public static CC_MASK: int
                public static INDEX_MIN_NFC_NO_MAYBE: int
                public static INDEX_MIN_NFKC_NO_MAYBE: int
                public static INDEX_MIN_NFD_NO_MAYBE: int
                public static INDEX_MIN_NFKD_NO_MAYBE: int
                public static MIN_WITH_LEAD_CC: int
                public static JAMO_L_BASE: int
                public static JAMO_V_BASE: int
                public static JAMO_T_BASE: int
                public static HANGUL_BASE: int
                public static JAMO_L_COUNT: int
                public static JAMO_V_COUNT: int
                public static JAMO_T_COUNT: int
                public static HANGUL_COUNT: int
                public static OPTIONS_SETS_MASK: int
                public static BEFORE_PRI_29: int
                public static OPTIONS_COMPAT: int
                public static OPTIONS_COMPOSE_CONTIGUOUS: int
                public static WITHOUT_CORRIGENDUM4_CORRECTIONS: int
                public static getFromIndexesArr(arg0: int): int
                public static getNorm32(arg0: char): long
                public static getNorm32FromSurrogatePair(arg0: long, arg1: char): long
                public static getUnicodeVersion(): sun.text.normalizer.VersionInfo
                public static getFCD16(arg0: char): char
                public static getFCD16FromSurrogatePair(arg0: char, arg1: char): char
                public static getFCD16(arg0: int): int
                public static isNFDSafe(arg0: long, arg1: int, arg2: int): boolean
                public static isTrueStarter(arg0: long, arg1: int, arg2: int): boolean
                public static quickCheck(arg0: char[], arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: boolean, arg7: sun.text.normalizer.UnicodeSet): sun.text.normalizer.NormalizerBase$QuickCheckResult
                public static decompose(arg0: char[], arg1: int, arg2: int, arg3: char[], arg4: int, arg5: int, arg6: boolean, arg7: int[], arg8: sun.text.normalizer.UnicodeSet): int
                public static compose(arg0: char[], arg1: int, arg2: int, arg3: char[], arg4: int, arg5: int, arg6: int, arg7: sun.text.normalizer.UnicodeSet): int
                public static getCombiningClass(arg0: int): int
                public static isFullCompositionExclusion(arg0: int): boolean
                public static isCanonSafeStart(arg0: int): boolean
                public static isNFSkippable(arg0: int, arg1: sun.text.normalizer.NormalizerBase$Mode, arg2: long): boolean
                public static addPropertyStarts(arg0: sun.text.normalizer.UnicodeSet): sun.text.normalizer.UnicodeSet
                public static quickCheck(arg0: int, arg1: int): int
                public static getNX(arg0: int): sun.text.normalizer.UnicodeSet
                public static getDecompose(arg0: int[], arg1: java.lang.String[]): int
                public static canonicalDecomposeWithSingleQuotation(arg0: java.lang.String | string): string
                public static convert(arg0: java.lang.String | string): string
                public static class: java.lang.Class<any>
            }
            interface Replaceable {
                length(): int
                charAt(arg0: int): char
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void
            }
            class ReplaceableString implements sun.text.normalizer.Replaceable {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.StringBuffer)
                public length(): int
                public charAt(arg0: int): char
                public getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void
                public static class: java.lang.Class<any>
            }
            class ReplaceableUCharacterIterator extends sun.text.normalizer.UCharacterIterator {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.StringBuffer)
                public clone(): java.lang.Object
                public current(): int
                public getLength(): int
                public getIndex(): int
                public next(): int
                public previous(): int
                public setIndex(arg0: int): void
                public getText(arg0: char[], arg1: int): int
                public static class: java.lang.Class<any>
            }
            abstract class Trie {
                protected static LEAD_INDEX_OFFSET_: int
                protected static INDEX_STAGE_1_SHIFT_: int
                protected static INDEX_STAGE_2_SHIFT_: int
                protected static DATA_BLOCK_LENGTH: int
                protected static INDEX_STAGE_3_MASK_: int
                protected static SURROGATE_BLOCK_BITS: int
                protected static SURROGATE_BLOCK_COUNT: int
                protected static BMP_INDEX_LENGTH: int
                protected static SURROGATE_MASK_: int
                protected m_index_: char[]
                protected m_dataManipulate_: sun.text.normalizer.Trie$DataManipulate
                protected m_dataOffset_: int
                protected m_dataLength_: int
                protected static HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_: int
                protected static HEADER_SIGNATURE_: int
                protected static HEADER_OPTIONS_INDEX_SHIFT_: int
                protected static HEADER_OPTIONS_DATA_IS_32_BIT_: int
                protected constructor(arg0: java.io.InputStream, arg1: sun.text.normalizer.Trie$DataManipulate)
                protected constructor(arg0: char[], arg1: int, arg2: sun.text.normalizer.Trie$DataManipulate)
                protected getSurrogateOffset(arg0: char, arg1: char): int
                protected getValue(arg0: int): int
                protected getInitialValue(): int
                protected getRawOffset(arg0: int, arg1: char): int
                protected getBMPOffset(arg0: char): int
                protected getLeadOffset(arg0: char): int
                protected getCodePointOffset(arg0: int): int
                protected unserialize(arg0: java.io.InputStream): void
                protected isIntTrie(): boolean
                protected isCharTrie(): boolean
                public static class: java.lang.Class<any>
            }
            class UBiDiProps {
                public constructor()
                public static getSingleton(): sun.text.normalizer.UBiDiProps
                public static getDummy(): sun.text.normalizer.UBiDiProps
                public getClass(arg0: int): int
                public static class: java.lang.Class<any>
            }
            class UCharacter {
                public static MIN_VALUE: int
                public static MAX_VALUE: int
                public static SUPPLEMENTARY_MIN_VALUE: int
                public constructor()
                public static digit(arg0: int, arg1: int): int
                public static getDirection(arg0: int): int
                public static getCodePoint(arg0: char, arg1: char): int
                public static getAge(arg0: int): sun.text.normalizer.VersionInfo
                public static class: java.lang.Class<any>
            }
            abstract class UCharacterIterator implements java.lang.Cloneable {
                public static DONE: int
                protected constructor()
                public static getInstance(arg0: java.lang.String | string): sun.text.normalizer.UCharacterIterator
                public static getInstance(arg0: java.lang.StringBuffer): sun.text.normalizer.UCharacterIterator
                public static getInstance(arg0: java.text.CharacterIterator): sun.text.normalizer.UCharacterIterator
                public current(): int
                public getLength(): int
                public getIndex(): int
                public next(): int
                public nextCodePoint(): int
                public previous(): int
                public setIndex(arg0: int): void
                public getText(arg0: char[], arg1: int): int
                public getText(arg0: char[]): int
                public getText(): string
                public moveIndex(arg0: int): int
                public clone(): java.lang.Object
                public static class: java.lang.Class<any>
            }
            class UCharacterProperty {
                public m_trie_: sun.text.normalizer.CharTrie
                public m_trieIndex_: char[]
                public m_trieData_: char[]
                public m_trieInitialValue_: int
                public m_unicodeVersion_: sun.text.normalizer.VersionInfo
                public static SRC_PROPSVEC: int
                public static SRC_COUNT: int
                public setIndexData(arg0: sun.text.normalizer.CharTrie$FriendAgent): void
                public getProperty(arg0: int): int
                public static getUnsignedValue(arg0: int): int
                public getAdditional(arg0: int, arg1: int): int
                public getAge(arg0: int): sun.text.normalizer.VersionInfo
                public static getRawSupplementary(arg0: char, arg1: char): int
                public static getInstance(): sun.text.normalizer.UCharacterProperty
                public static isRuleWhiteSpace(arg0: int): boolean
                public upropsvec_addPropertyStarts(arg0: sun.text.normalizer.UnicodeSet): void
                public static class: java.lang.Class<any>
            }
            class UTF16 {
                public static CODEPOINT_MIN_VALUE: int
                public static CODEPOINT_MAX_VALUE: int
                public static SUPPLEMENTARY_MIN_VALUE: int
                public static LEAD_SURROGATE_MIN_VALUE: int
                public static TRAIL_SURROGATE_MIN_VALUE: int
                public static LEAD_SURROGATE_MAX_VALUE: int
                public static TRAIL_SURROGATE_MAX_VALUE: int
                public static SURROGATE_MIN_VALUE: int
                public constructor()
                public static charAt(arg0: java.lang.String | string, arg1: int): int
                public static charAt(arg0: char[], arg1: int, arg2: int, arg3: int): int
                public static getCharCount(arg0: int): int
                public static isSurrogate(arg0: char): boolean
                public static isTrailSurrogate(arg0: char): boolean
                public static isLeadSurrogate(arg0: char): boolean
                public static getLeadSurrogate(arg0: int): char
                public static getTrailSurrogate(arg0: int): char
                public static valueOf(arg0: int): string
                public static append(arg0: java.lang.StringBuffer, arg1: int): java.lang.StringBuffer
                public static moveCodePointOffset(arg0: char[], arg1: int, arg2: int, arg3: int, arg4: int): int
                public static class: java.lang.Class<any>
            }
            class UnicodeSet implements sun.text.normalizer.UnicodeMatcher {
                public static MIN_VALUE: int
                public static MAX_VALUE: int
                public static IGNORE_SPACE: int
                public constructor()
                public constructor(arg0: int, arg1: int)
                public constructor(arg0: java.lang.String | string)
                public set(arg0: sun.text.normalizer.UnicodeSet): sun.text.normalizer.UnicodeSet
                public applyPattern(arg0: java.lang.String | string): sun.text.normalizer.UnicodeSet
                public _generatePattern(arg0: java.lang.StringBuffer, arg1: boolean, arg2: boolean): java.lang.StringBuffer
                public add(arg0: int): sun.text.normalizer.UnicodeSet
                public add(arg0: java.lang.String | string): sun.text.normalizer.UnicodeSet
                public complement(arg0: int, arg1: int): sun.text.normalizer.UnicodeSet
                public complement(): sun.text.normalizer.UnicodeSet
                public contains(arg0: int): boolean
                public addAll(arg0: sun.text.normalizer.UnicodeSet): sun.text.normalizer.UnicodeSet
                public retainAll(arg0: sun.text.normalizer.UnicodeSet): sun.text.normalizer.UnicodeSet
                public removeAll(arg0: sun.text.normalizer.UnicodeSet): sun.text.normalizer.UnicodeSet
                public clear(): sun.text.normalizer.UnicodeSet
                public getRangeCount(): int
                public getRangeStart(arg0: int): int
                public getRangeEnd(arg0: int): int
                public applyPropertyAlias(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: sun.text.normalizer.SymbolTable): sun.text.normalizer.UnicodeSet
                public static class: java.lang.Class<any>
            }
            class Utility {
                public constructor()
                public static arrayRegionMatches(arg0: char[], arg1: int, arg2: char[], arg3: int, arg4: int): boolean
                public static escape(arg0: java.lang.String | string): string
                public static unescapeAt(arg0: java.lang.String | string, arg1: int[]): int
                public static hex(arg0: int, arg1: int, arg2: java.lang.StringBuffer): java.lang.StringBuffer
                public static hex(arg0: int, arg1: int): string
                public static skipWhitespace(arg0: java.lang.String | string, arg1: int): int
                public static appendNumber(arg0: java.lang.StringBuffer, arg1: int, arg2: int, arg3: int): java.lang.StringBuffer
                public static isUnprintable(arg0: int): boolean
                public static escapeUnprintable(arg0: java.lang.StringBuffer, arg1: int): boolean
                public static getChars(arg0: java.lang.StringBuffer, arg1: int, arg2: int, arg3: char[], arg4: int): void
                public static class: java.lang.Class<any>
            }
            class VersionInfo {
                public static getInstance(arg0: java.lang.String | string): sun.text.normalizer.VersionInfo
                public static getInstance(arg0: int, arg1: int, arg2: int, arg3: int): sun.text.normalizer.VersionInfo
                public compareTo(arg0: sun.text.normalizer.VersionInfo): int
                public static class: java.lang.Class<any>
            }
        }
        namespace resources {
            class BreakIteratorInfo extends java.util.ListResourceBundle {
                public constructor()
                protected getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class CollationData extends java.util.ListResourceBundle {
                public constructor()
                protected getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class FormatData extends sun.util.resources.ParallelListResourceBundle {
                public constructor()
                protected getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            class JavaTimeSupplementary extends sun.util.resources.OpenListResourceBundle {
                public constructor()
                protected getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
        }
        class CollatorUtilities {
            public constructor()
            public static toLegacyMode(arg0: sun.text.normalizer.NormalizerBase$Mode): int
            public static toNormalizerMode(arg0: int): sun.text.normalizer.NormalizerBase$Mode
            public static class: java.lang.Class<any>
        }
        class CompactByteArray implements java.lang.Cloneable {
            public static UNICODECOUNT: int
            public constructor(arg0: byte)
            public constructor(arg0: short[], arg1: byte[])
            public elementAt(arg0: char): byte
            public setElementAt(arg0: char, arg1: byte): void
            public setElementAt(arg0: char, arg1: char, arg2: byte): void
            public compact(): void
            public getIndexArray(): short[]
            public getStringArray(): byte[]
            public clone(): java.lang.Object
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public static class: java.lang.Class<any>
        }
        class ComposedCharIter {
            public static DONE: int
            public constructor()
            public next(): int
            public decomposition(): string
            public static class: java.lang.Class<any>
        }
        class IntHashtable {
            public constructor()
            public constructor(arg0: int)
            public size(): int
            public isEmpty(): boolean
            public put(arg0: int, arg1: int): void
            public get(arg0: int): int
            public remove(arg0: int): void
            public getDefaultValue(): int
            public setDefaultValue(arg0: int): void
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public clone(): java.lang.Object
            public putInternal(arg0: int, arg1: int): void
            public static class: java.lang.Class<any>
        }
        class Normalizer {
            public static UNICODE_3_2: int
            public static normalize(arg0: java.lang.CharSequence, arg1: java.text.Normalizer$Form, arg2: int): string
            public static isNormalized(arg0: java.lang.CharSequence, arg1: java.text.Normalizer$Form, arg2: int): boolean
            public static getCombiningClass(arg0: int): int
            public static class: java.lang.Class<any>
        }
        class SupplementaryCharacterData implements java.lang.Cloneable {
            public constructor(arg0: int[])
            public getValue(arg0: int): int
            public getArray(): int[]
            public static class: java.lang.Class<any>
        }
        class UCompactIntArray implements java.lang.Cloneable {
            public constructor()
            public constructor(arg0: int)
            public elementAt(arg0: int): int
            public setElementAt(arg0: int, arg1: int): void
            public compact(): void
            public getKSize(): int
            public static class: java.lang.Class<any>
        }
    }
    namespace util {
        namespace calendar {
            abstract class AbstractCalendar extends sun.util.calendar.CalendarSystem {
                protected constructor()
                public getEra(arg0: java.lang.String | string): sun.util.calendar.Era
                public getEras(): sun.util.calendar.Era[]
                public setEra(arg0: sun.util.calendar.CalendarDate, arg1: java.lang.String | string): void
                protected setEras(arg0: sun.util.calendar.Era[]): void
                public getCalendarDate(): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public getTime(arg0: sun.util.calendar.CalendarDate): long
                protected getTimeOfDay(arg0: sun.util.calendar.CalendarDate): long
                public getTimeOfDayValue(arg0: sun.util.calendar.CalendarDate): long
                public setTimeOfDay(arg0: sun.util.calendar.CalendarDate, arg1: int): sun.util.calendar.CalendarDate
                public getWeekLength(): int
                protected isLeapYear(arg0: sun.util.calendar.CalendarDate): boolean
                public getNthDayOfWeek(arg0: int, arg1: int, arg2: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public static getDayOfWeekDateOnOrBefore(arg0: long, arg1: int): long
                protected getFixedDate(arg0: sun.util.calendar.CalendarDate): long
                protected getCalendarDateFromFixedDate(arg0: sun.util.calendar.CalendarDate, arg1: long): void
                public validateTime(arg0: sun.util.calendar.CalendarDate): boolean
                public static class: java.lang.Class<any>
            }
            abstract class BaseCalendar extends sun.util.calendar.AbstractCalendar {
                public static JANUARY: int
                public static FEBRUARY: int
                public static MARCH: int
                public static APRIL: int
                public static MAY: int
                public static JUNE: int
                public static JULY: int
                public static AUGUST: int
                public static SEPTEMBER: int
                public static OCTOBER: int
                public static NOVEMBER: int
                public static DECEMBER: int
                public static SUNDAY: int
                public static MONDAY: int
                public static TUESDAY: int
                public static WEDNESDAY: int
                public static THURSDAY: int
                public static FRIDAY: int
                public static SATURDAY: int
                public constructor()
                public validate(arg0: sun.util.calendar.CalendarDate): boolean
                public normalize(arg0: sun.util.calendar.CalendarDate): boolean
                public getYearLength(arg0: sun.util.calendar.CalendarDate): int
                public getYearLengthInMonths(arg0: sun.util.calendar.CalendarDate): int
                public getMonthLength(arg0: sun.util.calendar.CalendarDate): int
                public getDayOfYear(arg0: sun.util.calendar.CalendarDate): long
                public getFixedDate(arg0: sun.util.calendar.CalendarDate): long
                public getFixedDate(arg0: int, arg1: int, arg2: int, arg3: sun.util.calendar.BaseCalendar$Date): long
                public getCalendarDateFromFixedDate(arg0: sun.util.calendar.CalendarDate, arg1: long): void
                public getDayOfWeek(arg0: sun.util.calendar.CalendarDate): int
                public static getDayOfWeekFromFixedDate(arg0: long): int
                public getYearFromFixedDate(arg0: long): int
                protected isLeapYear(arg0: sun.util.calendar.CalendarDate): boolean
                public static class: java.lang.Class<any>
            }
            abstract class CalendarDate implements java.lang.Cloneable {
                public static FIELD_UNDEFINED: int
                public static TIME_UNDEFINED: long
                protected constructor()
                protected constructor(arg0: java.util.TimeZone)
                public getEra(): sun.util.calendar.Era
                public setEra(arg0: sun.util.calendar.Era): sun.util.calendar.CalendarDate
                public getYear(): int
                public setYear(arg0: int): sun.util.calendar.CalendarDate
                public addYear(arg0: int): sun.util.calendar.CalendarDate
                public isLeapYear(): boolean
                public getMonth(): int
                public setMonth(arg0: int): sun.util.calendar.CalendarDate
                public addMonth(arg0: int): sun.util.calendar.CalendarDate
                public getDayOfMonth(): int
                public setDayOfMonth(arg0: int): sun.util.calendar.CalendarDate
                public addDayOfMonth(arg0: int): sun.util.calendar.CalendarDate
                public getDayOfWeek(): int
                public getHours(): int
                public setHours(arg0: int): sun.util.calendar.CalendarDate
                public addHours(arg0: int): sun.util.calendar.CalendarDate
                public getMinutes(): int
                public setMinutes(arg0: int): sun.util.calendar.CalendarDate
                public addMinutes(arg0: int): sun.util.calendar.CalendarDate
                public getSeconds(): int
                public setSeconds(arg0: int): sun.util.calendar.CalendarDate
                public addSeconds(arg0: int): sun.util.calendar.CalendarDate
                public getMillis(): int
                public setMillis(arg0: int): sun.util.calendar.CalendarDate
                public addMillis(arg0: int): sun.util.calendar.CalendarDate
                public getTimeOfDay(): long
                public setDate(arg0: int, arg1: int, arg2: int): sun.util.calendar.CalendarDate
                public addDate(arg0: int, arg1: int, arg2: int): sun.util.calendar.CalendarDate
                public setTimeOfDay(arg0: int, arg1: int, arg2: int, arg3: int): sun.util.calendar.CalendarDate
                public addTimeOfDay(arg0: int, arg1: int, arg2: int, arg3: int): sun.util.calendar.CalendarDate
                protected setTimeOfDay(arg0: long): void
                public isNormalized(): boolean
                public isStandardTime(): boolean
                public setStandardTime(arg0: boolean): void
                public isDaylightTime(): boolean
                protected setLocale(arg0: java.util.Locale): void
                public getZone(): java.util.TimeZone
                public setZone(arg0: java.util.TimeZone): sun.util.calendar.CalendarDate
                public isSameDate(arg0: sun.util.calendar.CalendarDate): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public clone(): java.lang.Object
                public toString(): string
                protected setDayOfWeek(arg0: int): void
                protected setNormalized(arg0: boolean): void
                public getZoneOffset(): int
                protected setZoneOffset(arg0: int): void
                public getDaylightSaving(): int
                protected setDaylightSaving(arg0: int): void
                public static class: java.lang.Class<any>
            }
            abstract class CalendarSystem {
                public constructor()
                public static getGregorianCalendar(): sun.util.calendar.Gregorian
                public static forName(arg0: java.lang.String | string): sun.util.calendar.CalendarSystem
                public static getCalendarProperties(): java.util.Properties
                public getName(): string
                public getCalendarDate(): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.CalendarDate
                public newCalendarDate(): sun.util.calendar.CalendarDate
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.CalendarDate
                public getTime(arg0: sun.util.calendar.CalendarDate): long
                public getYearLength(arg0: sun.util.calendar.CalendarDate): int
                public getYearLengthInMonths(arg0: sun.util.calendar.CalendarDate): int
                public getMonthLength(arg0: sun.util.calendar.CalendarDate): int
                public getWeekLength(): int
                public getEra(arg0: java.lang.String | string): sun.util.calendar.Era
                public getEras(): sun.util.calendar.Era[]
                public setEra(arg0: sun.util.calendar.CalendarDate, arg1: java.lang.String | string): void
                public getNthDayOfWeek(arg0: int, arg1: int, arg2: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public setTimeOfDay(arg0: sun.util.calendar.CalendarDate, arg1: int): sun.util.calendar.CalendarDate
                public validate(arg0: sun.util.calendar.CalendarDate): boolean
                public normalize(arg0: sun.util.calendar.CalendarDate): boolean
                public static class: java.lang.Class<any>
            }
            class CalendarUtils {
                public constructor()
                public static isGregorianLeapYear(arg0: int): boolean
                public static isJulianLeapYear(arg0: int): boolean
                public static floorDivide(arg0: long, arg1: long): long
                public static floorDivide(arg0: int, arg1: int): int
                public static floorDivide(arg0: int, arg1: int, arg2: int[]): int
                public static floorDivide(arg0: long, arg1: int, arg2: int[]): int
                public static mod(arg0: long, arg1: long): long
                public static mod(arg0: int, arg1: int): int
                public static amod(arg0: int, arg1: int): int
                public static amod(arg0: long, arg1: long): long
                public static sprintf0d(arg0: java.lang.StringBuilder, arg1: int, arg2: int): java.lang.StringBuilder
                public static sprintf0d(arg0: java.lang.StringBuffer, arg1: int, arg2: int): java.lang.StringBuffer
                public static class: java.lang.Class<any>
            }
            class Era {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: long, arg3: boolean)
                public getName(): string
                public getDisplayName(arg0: java.util.Locale): string
                public getAbbreviation(): string
                public getDiaplayAbbreviation(arg0: java.util.Locale): string
                public getSince(arg0: java.util.TimeZone): long
                public getSinceDate(): sun.util.calendar.CalendarDate
                public isLocalTime(): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class Gregorian extends sun.util.calendar.BaseCalendar {
                public getName(): string
                public getCalendarDate(): sun.util.calendar.Gregorian$Date
                public getCalendarDate(arg0: long): sun.util.calendar.Gregorian$Date
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.Gregorian$Date
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.Gregorian$Date
                public newCalendarDate(): sun.util.calendar.Gregorian$Date
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.Gregorian$Date
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long): sun.util.calendar.CalendarDate
                public getCalendarDate(): sun.util.calendar.CalendarDate
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.CalendarDate
                public newCalendarDate(): sun.util.calendar.CalendarDate
                public static class: java.lang.Class<any>
            }
            class ImmutableGregorianDate extends sun.util.calendar.BaseCalendar$Date {
                public getEra(): sun.util.calendar.Era
                public setEra(arg0: sun.util.calendar.Era): sun.util.calendar.CalendarDate
                public getYear(): int
                public setYear(arg0: int): sun.util.calendar.CalendarDate
                public addYear(arg0: int): sun.util.calendar.CalendarDate
                public isLeapYear(): boolean
                public getMonth(): int
                public setMonth(arg0: int): sun.util.calendar.CalendarDate
                public addMonth(arg0: int): sun.util.calendar.CalendarDate
                public getDayOfMonth(): int
                public setDayOfMonth(arg0: int): sun.util.calendar.CalendarDate
                public addDayOfMonth(arg0: int): sun.util.calendar.CalendarDate
                public getDayOfWeek(): int
                public getHours(): int
                public setHours(arg0: int): sun.util.calendar.CalendarDate
                public addHours(arg0: int): sun.util.calendar.CalendarDate
                public getMinutes(): int
                public setMinutes(arg0: int): sun.util.calendar.CalendarDate
                public addMinutes(arg0: int): sun.util.calendar.CalendarDate
                public getSeconds(): int
                public setSeconds(arg0: int): sun.util.calendar.CalendarDate
                public addSeconds(arg0: int): sun.util.calendar.CalendarDate
                public getMillis(): int
                public setMillis(arg0: int): sun.util.calendar.CalendarDate
                public addMillis(arg0: int): sun.util.calendar.CalendarDate
                public getTimeOfDay(): long
                public setDate(arg0: int, arg1: int, arg2: int): sun.util.calendar.CalendarDate
                public addDate(arg0: int, arg1: int, arg2: int): sun.util.calendar.CalendarDate
                public setTimeOfDay(arg0: int, arg1: int, arg2: int, arg3: int): sun.util.calendar.CalendarDate
                public addTimeOfDay(arg0: int, arg1: int, arg2: int, arg3: int): sun.util.calendar.CalendarDate
                protected setTimeOfDay(arg0: long): void
                public isNormalized(): boolean
                public isStandardTime(): boolean
                public setStandardTime(arg0: boolean): void
                public isDaylightTime(): boolean
                protected setLocale(arg0: java.util.Locale): void
                public getZone(): java.util.TimeZone
                public setZone(arg0: java.util.TimeZone): sun.util.calendar.CalendarDate
                public isSameDate(arg0: sun.util.calendar.CalendarDate): boolean
                public equals(arg0: java.lang.Object): boolean
                public hashCode(): int
                public clone(): java.lang.Object
                public toString(): string
                protected setDayOfWeek(arg0: int): void
                protected setNormalized(arg0: boolean): void
                public getZoneOffset(): int
                protected setZoneOffset(arg0: int): void
                public getDaylightSaving(): int
                protected setDaylightSaving(arg0: int): void
                public getNormalizedYear(): int
                public setNormalizedYear(arg0: int): void
                public static class: java.lang.Class<any>
            }
            class JulianCalendar extends sun.util.calendar.BaseCalendar {
                public getName(): string
                public getCalendarDate(): sun.util.calendar.JulianCalendar$Date
                public getCalendarDate(arg0: long): sun.util.calendar.JulianCalendar$Date
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.JulianCalendar$Date
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.JulianCalendar$Date
                public newCalendarDate(): sun.util.calendar.JulianCalendar$Date
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.JulianCalendar$Date
                public getFixedDate(arg0: int, arg1: int, arg2: int, arg3: sun.util.calendar.BaseCalendar$Date): long
                public getCalendarDateFromFixedDate(arg0: sun.util.calendar.CalendarDate, arg1: long): void
                public getYearFromFixedDate(arg0: long): int
                public getDayOfWeek(arg0: sun.util.calendar.CalendarDate): int
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long): sun.util.calendar.CalendarDate
                public getCalendarDate(): sun.util.calendar.CalendarDate
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.CalendarDate
                public newCalendarDate(): sun.util.calendar.CalendarDate
                public static class: java.lang.Class<any>
            }
            class LocalGregorianCalendar extends sun.util.calendar.BaseCalendar {
                public getName(): string
                public getCalendarDate(): sun.util.calendar.LocalGregorianCalendar$Date
                public getCalendarDate(arg0: long): sun.util.calendar.LocalGregorianCalendar$Date
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.LocalGregorianCalendar$Date
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.LocalGregorianCalendar$Date
                public newCalendarDate(): sun.util.calendar.LocalGregorianCalendar$Date
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.LocalGregorianCalendar$Date
                public validate(arg0: sun.util.calendar.CalendarDate): boolean
                public normalize(arg0: sun.util.calendar.CalendarDate): boolean
                public isLeapYear(arg0: int): boolean
                public isLeapYear(arg0: sun.util.calendar.Era, arg1: int): boolean
                public getCalendarDateFromFixedDate(arg0: sun.util.calendar.CalendarDate, arg1: long): void
                public getCalendarDate(arg0: long, arg1: sun.util.calendar.CalendarDate): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long, arg1: java.util.TimeZone): sun.util.calendar.CalendarDate
                public getCalendarDate(arg0: long): sun.util.calendar.CalendarDate
                public getCalendarDate(): sun.util.calendar.CalendarDate
                public newCalendarDate(arg0: java.util.TimeZone): sun.util.calendar.CalendarDate
                public newCalendarDate(): sun.util.calendar.CalendarDate
                public static class: java.lang.Class<any>
            }
            class ZoneInfo extends java.util.TimeZone {
                public constructor()
                public constructor(arg0: java.lang.String | string, arg1: int)
                public getOffset(arg0: long): int
                public getOffsets(arg0: long, arg1: int[]): int
                public getOffsetsByStandard(arg0: long, arg1: int[]): int
                public getOffsetsByWall(arg0: long, arg1: int[]): int
                public getOffset(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): int
                public setRawOffset(arg0: int): void
                public getRawOffset(): int
                public isDirty(): boolean
                public useDaylightTime(): boolean
                public observesDaylightTime(): boolean
                public inDaylightTime(arg0: java.util.Date): boolean
                public getDSTSavings(): int
                public toString(): string
                public static getAvailableIDs(): java.lang.String[]
                public static getAvailableIDs(arg0: int): java.lang.String[]
                public static getTimeZone(arg0: java.lang.String | string): java.util.TimeZone
                public getLastRuleInstance(): java.util.SimpleTimeZone
                public clone(): java.lang.Object
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public hasSameRules(arg0: java.util.TimeZone): boolean
                public static getAliasTable(): java.util.Map<java.lang.String, java.lang.String>
                public static class: java.lang.Class<any>
            }
            class ZoneInfoFile {
                public static getZoneIds(): java.lang.String[]
                public static getZoneIds(arg0: int): java.lang.String[]
                public static getZoneInfo(arg0: java.lang.String | string): sun.util.calendar.ZoneInfo
                public static getAliasMap(): java.util.Map<java.lang.String, java.lang.String>
                public static getVersion(): string
                public static getCustomTimeZone(arg0: java.lang.String | string, arg1: int): sun.util.calendar.ZoneInfo
                public static toCustomID(arg0: int): string
                public static useOldMapping(): boolean
                public static getZoneInfo(arg0: java.io.DataInput, arg1: java.lang.String | string): sun.util.calendar.ZoneInfo
                public static readOffset(arg0: java.io.DataInput): int
                public static class: java.lang.Class<any>
            }
        }
        namespace cldr {
            class CLDRLocaleProviderAdapter extends sun.util.locale.provider.JRELocaleProviderAdapter {
                public constructor()
                public getAdapterType(): sun.util.locale.provider.LocaleProviderAdapter$Type
                public getBreakIteratorProvider(): java.text.spi.BreakIteratorProvider
                public getCollatorProvider(): java.text.spi.CollatorProvider
                public getAvailableLocales(): java.util.Locale[]
                protected createLanguageTagSet(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                public static class: java.lang.Class<any>
            }
        }
        namespace locale {
            namespace provider {
                abstract class AuxLocaleProviderAdapter extends sun.util.locale.provider.LocaleProviderAdapter {
                    public constructor()
                    public getLocaleServiceProvider<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.Class<P>): P
                    protected findInstalledProvider<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.Class<P>): P
                    public getBreakIteratorProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.BreakIteratorProvider
                    public getCollatorProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.CollatorProvider
                    public getDateFormatProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.DateFormatProvider
                    public getDateFormatSymbolsProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.DateFormatSymbolsProvider
                    public getDecimalFormatSymbolsProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.DecimalFormatSymbolsProvider
                    public getNumberFormatProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.NumberFormatProvider
                    public getCurrencyNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.CurrencyNameProvider
                    public getLocaleNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.LocaleNameProvider
                    public getTimeZoneNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.TimeZoneNameProvider
                    public getCalendarDataProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.CalendarDataProvider
                    public getCalendarNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.CalendarNameProvider
                    public getCalendarProvider<P extends java.util.spi.LocaleServiceProvider>(): sun.util.spi.CalendarProvider
                    public getLocaleResources<P extends java.util.spi.LocaleServiceProvider>(arg0: java.util.Locale): sun.util.locale.provider.LocaleResources
                    public getAvailableLocales<P extends java.util.spi.LocaleServiceProvider>(): java.util.Locale[]
                    public static class: java.lang.Class<any>
                }
                interface AvailableLanguageTags {
                    getAvailableLanguageTags(): java.util.Set<java.lang.String>
                }
                interface AvailableLanguageTags$$Lambda {
                    (): java.util.Set<java.lang.String>
                }
                class BreakIteratorProviderImpl extends java.text.spi.BreakIteratorProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public getWordInstance(arg0: java.util.Locale): java.text.BreakIterator
                    public getLineInstance(arg0: java.util.Locale): java.text.BreakIterator
                    public getCharacterInstance(arg0: java.util.Locale): java.text.BreakIterator
                    public getSentenceInstance(arg0: java.util.Locale): java.text.BreakIterator
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public static class: java.lang.Class<any>
                }
                class BreakIteratorProviderImpl$$Lambda extends java.text.spi.BreakIteratorProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class CalendarDataProviderImpl extends java.util.spi.CalendarDataProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getFirstDayOfWeek(arg0: java.util.Locale): int
                    public getMinimalDaysInFirstWeek(arg0: java.util.Locale): int
                    public getAvailableLocales(): java.util.Locale[]
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class CalendarDataProviderImpl$$Lambda extends java.util.spi.CalendarDataProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class CalendarDataUtility {
                    public static FIRST_DAY_OF_WEEK: string
                    public static MINIMAL_DAYS_IN_FIRST_WEEK: string
                    public static retrieveFirstDayOfWeek(arg0: java.util.Locale): int
                    public static retrieveMinimalDaysInFirstWeek(arg0: java.util.Locale): int
                    public static retrieveFieldValueName(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int, arg4: java.util.Locale): string
                    public static retrieveJavaTimeFieldValueName(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int, arg4: java.util.Locale): string
                    public static retrieveFieldValueNames(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
                    public static retrieveJavaTimeFieldValueNames(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
                    public static class: java.lang.Class<any>
                }
                class CalendarNameProviderImpl extends java.util.spi.CalendarNameProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getDisplayName(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int, arg4: java.util.Locale): string
                    public getJavaTimeDisplayName(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int, arg4: java.util.Locale): string
                    public getDisplayNameImpl(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: int, arg4: java.util.Locale, arg5: boolean): string
                    public getDisplayNames(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
                    public getJavaTimeDisplayNames(arg0: java.lang.String | string, arg1: int, arg2: int, arg3: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class CalendarNameProviderImpl$$Lambda extends java.util.spi.CalendarNameProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class CalendarProviderImpl extends sun.util.spi.CalendarProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getInstance(arg0: java.util.TimeZone, arg1: java.util.Locale): java.util.Calendar
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class CalendarProviderImpl$$Lambda extends sun.util.spi.CalendarProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class CollationRules {
                    public static class: java.lang.Class<any>
                }
                class CollatorProviderImpl extends java.text.spi.CollatorProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getInstance(arg0: java.util.Locale): java.text.Collator
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class CollatorProviderImpl$$Lambda extends java.text.spi.CollatorProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class CurrencyNameProviderImpl extends java.util.spi.CurrencyNameProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public getAvailableLocales(): java.util.Locale[]
                    public getSymbol(arg0: java.lang.String | string, arg1: java.util.Locale): string
                    public getDisplayName(arg0: java.lang.String | string, arg1: java.util.Locale): string
                    public static class: java.lang.Class<any>
                }
                class CurrencyNameProviderImpl$$Lambda extends java.util.spi.CurrencyNameProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class DateFormatProviderImpl extends java.text.spi.DateFormatProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getTimeInstance(arg0: int, arg1: java.util.Locale): java.text.DateFormat
                    public getDateInstance(arg0: int, arg1: java.util.Locale): java.text.DateFormat
                    public getDateTimeInstance(arg0: int, arg1: int, arg2: java.util.Locale): java.text.DateFormat
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class DateFormatProviderImpl$$Lambda extends java.text.spi.DateFormatProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class DateFormatSymbolsProviderImpl extends java.text.spi.DateFormatSymbolsProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getInstance(arg0: java.util.Locale): java.text.DateFormatSymbols
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class DateFormatSymbolsProviderImpl$$Lambda extends java.text.spi.DateFormatSymbolsProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class DecimalFormatSymbolsProviderImpl extends java.text.spi.DecimalFormatSymbolsProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getInstance(arg0: java.util.Locale): java.text.DecimalFormatSymbols
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class DecimalFormatSymbolsProviderImpl$$Lambda extends java.text.spi.DecimalFormatSymbolsProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                class FallbackLocaleProviderAdapter extends sun.util.locale.provider.JRELocaleProviderAdapter {
                    public constructor()
                    public getAdapterType(): sun.util.locale.provider.LocaleProviderAdapter$Type
                    public getLocaleResources(arg0: java.util.Locale): sun.util.locale.provider.LocaleResources
                    protected createLanguageTagSet(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class HostLocaleProviderAdapter extends sun.util.locale.provider.AuxLocaleProviderAdapter {
                    public constructor()
                    public getAdapterType(): sun.util.locale.provider.LocaleProviderAdapter$Type
                    protected findInstalledProvider<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.Class<P>): P
                    public static class: java.lang.Class<any>
                }
                class JRELocaleConstants {
                    public static JA_JP_JP: java.util.Locale
                    public static NO_NO_NY: java.util.Locale
                    public static TH_TH: java.util.Locale
                    public static TH_TH_TH: java.util.Locale
                    public static class: java.lang.Class<any>
                }
                class JRELocaleProviderAdapter extends sun.util.locale.provider.LocaleProviderAdapter implements sun.util.locale.provider.ResourceBundleBasedAdapter {
                    public constructor()
                    public getAdapterType(): sun.util.locale.provider.LocaleProviderAdapter$Type
                    public getLocaleServiceProvider<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.Class<P>): P
                    public getBreakIteratorProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.BreakIteratorProvider
                    public getCollatorProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.CollatorProvider
                    public getDateFormatProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.DateFormatProvider
                    public getDateFormatSymbolsProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.DateFormatSymbolsProvider
                    public getDecimalFormatSymbolsProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.DecimalFormatSymbolsProvider
                    public getNumberFormatProvider<P extends java.util.spi.LocaleServiceProvider>(): java.text.spi.NumberFormatProvider
                    public getCurrencyNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.CurrencyNameProvider
                    public getLocaleNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.LocaleNameProvider
                    public getTimeZoneNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.TimeZoneNameProvider
                    public getCalendarDataProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.CalendarDataProvider
                    public getCalendarNameProvider<P extends java.util.spi.LocaleServiceProvider>(): java.util.spi.CalendarNameProvider
                    public getCalendarProvider<P extends java.util.spi.LocaleServiceProvider>(): sun.util.spi.CalendarProvider
                    public getLocaleResources<P extends java.util.spi.LocaleServiceProvider>(arg0: java.util.Locale): sun.util.locale.provider.LocaleResources
                    public getLocaleData<P extends java.util.spi.LocaleServiceProvider>(): sun.util.resources.LocaleData
                    public getAvailableLocales<P extends java.util.spi.LocaleServiceProvider>(): java.util.Locale[]
                    public getLanguageTagSet<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                    protected createLanguageTagSet<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.String | string): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class JRELocaleProviderAdapter$$Lambda extends sun.util.locale.provider.LocaleProviderAdapter implements sun.util.locale.provider.ResourceBundleBasedAdapter {
                    public constructor()
                }
                class LocaleDataMetaInfo {
                    public constructor()
                    public static getSupportedLocaleString(arg0: java.lang.String | string): string
                    public static class: java.lang.Class<any>
                }
                class LocaleNameProviderImpl extends java.util.spi.LocaleNameProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getDisplayLanguage(arg0: java.lang.String | string, arg1: java.util.Locale): string
                    public getDisplayScript(arg0: java.lang.String | string, arg1: java.util.Locale): string
                    public getDisplayCountry(arg0: java.lang.String | string, arg1: java.util.Locale): string
                    public getDisplayVariant(arg0: java.lang.String | string, arg1: java.util.Locale): string
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class LocaleNameProviderImpl$$Lambda extends java.util.spi.LocaleNameProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                abstract class LocaleProviderAdapter {
                    public constructor()
                    public static forType(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type): sun.util.locale.provider.LocaleProviderAdapter
                    public static forJRE(): sun.util.locale.provider.LocaleProviderAdapter
                    public static getResourceBundleBased(): sun.util.locale.provider.LocaleProviderAdapter
                    public static getAdapterPreference(): java.util.List<sun.util.locale.provider.LocaleProviderAdapter$Type>
                    public static getAdapter(arg0: java.lang.Class<java.util.spi.LocaleServiceProvider>, arg1: java.util.Locale): sun.util.locale.provider.LocaleProviderAdapter
                    public static isSupportedLocale(arg0: java.util.Locale, arg1: sun.util.locale.provider.LocaleProviderAdapter$Type, arg2: java.util.Set<java.lang.String>): boolean
                    public static toLocaleArray(arg0: java.util.Set<java.lang.String>): java.util.Locale[]
                    public getAdapterType(): sun.util.locale.provider.LocaleProviderAdapter$Type
                    public getLocaleServiceProvider<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.Class<P>): P
                    public getBreakIteratorProvider(): java.text.spi.BreakIteratorProvider
                    public getCollatorProvider(): java.text.spi.CollatorProvider
                    public getDateFormatProvider(): java.text.spi.DateFormatProvider
                    public getDateFormatSymbolsProvider(): java.text.spi.DateFormatSymbolsProvider
                    public getDecimalFormatSymbolsProvider(): java.text.spi.DecimalFormatSymbolsProvider
                    public getNumberFormatProvider(): java.text.spi.NumberFormatProvider
                    public getCurrencyNameProvider(): java.util.spi.CurrencyNameProvider
                    public getLocaleNameProvider(): java.util.spi.LocaleNameProvider
                    public getTimeZoneNameProvider(): java.util.spi.TimeZoneNameProvider
                    public getCalendarDataProvider(): java.util.spi.CalendarDataProvider
                    public getCalendarNameProvider(): java.util.spi.CalendarNameProvider
                    public getCalendarProvider(): sun.util.spi.CalendarProvider
                    public getLocaleResources(arg0: java.util.Locale): sun.util.locale.provider.LocaleResources
                    public getAvailableLocales(): java.util.Locale[]
                    public static class: java.lang.Class<any>
                }
                class LocaleResources {
                    public getCollationData(): string
                    public getDecimalFormatSymbolsData(): java.lang.Object[]
                    public getCurrencyName(arg0: java.lang.String | string): string
                    public getLocaleName(arg0: java.lang.String | string): string
                    public getDateTimePattern(arg0: int, arg1: int, arg2: java.util.Calendar): string
                    public getJavaTimeDateTimePattern(arg0: int, arg1: int, arg2: java.lang.String | string): string
                    public getNumberPatterns(): java.lang.String[]
                    public getJavaTimeFormatData(): java.util.ResourceBundle
                    public static class: java.lang.Class<any>
                }
                class LocaleServiceProviderPool {
                    public static getPool(arg0: java.lang.Class<java.util.spi.LocaleServiceProvider>): sun.util.locale.provider.LocaleServiceProviderPool
                    public static getAllAvailableLocales(): java.util.Locale[]
                    public getAvailableLocales(): java.util.Locale[]
                    public getLocalizedObject<P extends java.util.spi.LocaleServiceProvider, S>(arg0: sun.util.locale.provider.LocaleServiceProviderPool$LocalizedObjectGetter<P, S>, arg1: java.util.Locale, ...arg2: java.lang.Object[]): S
                    public getLocalizedObject<P extends java.util.spi.LocaleServiceProvider, S>(arg0: sun.util.locale.provider.LocaleServiceProviderPool$LocalizedObjectGetter<P, S>, arg1: java.util.Locale, arg2: java.lang.String | string, ...arg3: java.lang.Object[]): S
                    public static class: java.lang.Class<any>
                }
                class NumberFormatProviderImpl extends java.text.spi.NumberFormatProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getCurrencyInstance(arg0: java.util.Locale): java.text.NumberFormat
                    public getIntegerInstance(arg0: java.util.Locale): java.text.NumberFormat
                    public getNumberInstance(arg0: java.util.Locale): java.text.NumberFormat
                    public getPercentInstance(arg0: java.util.Locale): java.text.NumberFormat
                    public getAvailableLanguageTags(): java.util.Set<java.lang.String>
                    public static class: java.lang.Class<any>
                }
                class NumberFormatProviderImpl$$Lambda extends java.text.spi.NumberFormatProvider implements sun.util.locale.provider.AvailableLanguageTags {
                    public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type, arg1: java.util.Set<java.lang.String>)
                }
                interface ResourceBundleBasedAdapter {
                    getLocaleData(): sun.util.resources.LocaleData
                }
                interface ResourceBundleBasedAdapter$$Lambda {
                    (): sun.util.resources.LocaleData
                }
                class SPILocaleProviderAdapter extends sun.util.locale.provider.AuxLocaleProviderAdapter {
                    public constructor()
                    public getAdapterType(): sun.util.locale.provider.LocaleProviderAdapter$Type
                    protected findInstalledProvider<P extends java.util.spi.LocaleServiceProvider>(arg0: java.lang.Class<P>): P
                    public static class: java.lang.Class<any>
                }
                class TimeZoneNameProviderImpl extends java.util.spi.TimeZoneNameProvider {
                    public getAvailableLocales(): java.util.Locale[]
                    public isSupportedLocale(arg0: java.util.Locale): boolean
                    public getDisplayName(arg0: java.lang.String | string, arg1: boolean, arg2: int, arg3: java.util.Locale): string
                    public getGenericDisplayName(arg0: java.lang.String | string, arg1: int, arg2: java.util.Locale): string
                    public static class: java.lang.Class<any>
                }
                class TimeZoneNameUtility {
                    public static getZoneStrings(arg0: java.util.Locale): java.lang.String[][]
                    public static retrieveDisplayNames(arg0: java.lang.String | string, arg1: java.util.Locale): java.lang.String[]
                    public static retrieveGenericDisplayName(arg0: java.lang.String | string, arg1: int, arg2: java.util.Locale): string
                    public static retrieveDisplayName(arg0: java.lang.String | string, arg1: boolean, arg2: int, arg3: java.util.Locale): string
                    public static class: java.lang.Class<any>
                }
            }
            class BaseLocale {
                public static SEP: string
                public static createInstance(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.util.locale.BaseLocale
                public static getInstance(arg0: java.lang.String | string, arg1: java.lang.String | string, arg2: java.lang.String | string, arg3: java.lang.String | string): sun.util.locale.BaseLocale
                public getLanguage(): string
                public getScript(): string
                public getRegion(): string
                public getVariant(): string
                public equals(arg0: java.lang.Object): boolean
                public toString(): string
                public hashCode(): int
                public static class: java.lang.Class<any>
            }
            class Extension {
                protected constructor(arg0: char)
                protected setValue(arg0: java.lang.String | string): void
                public getKey(): char
                public getValue(): string
                public getID(): string
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class InternalLocaleBuilder {
                public constructor()
                public setLanguage(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setScript(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setRegion(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setVariant(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public addUnicodeLocaleAttribute(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public removeUnicodeLocaleAttribute(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setUnicodeLocaleKeyword(arg0: java.lang.String | string, arg1: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setExtension(arg0: char, arg1: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setExtensions(arg0: java.lang.String | string): sun.util.locale.InternalLocaleBuilder
                public setLanguageTag(arg0: sun.util.locale.LanguageTag): sun.util.locale.InternalLocaleBuilder
                public setLocale(arg0: sun.util.locale.BaseLocale, arg1: sun.util.locale.LocaleExtensions): sun.util.locale.InternalLocaleBuilder
                public clear(): sun.util.locale.InternalLocaleBuilder
                public clearExtensions(): sun.util.locale.InternalLocaleBuilder
                public getBaseLocale(): sun.util.locale.BaseLocale
                public getLocaleExtensions(): sun.util.locale.LocaleExtensions
                public static class: java.lang.Class<any>
            }
            class LanguageTag {
                public static SEP: string
                public static PRIVATEUSE: string
                public static UNDETERMINED: string
                public static PRIVUSE_VARIANT_PREFIX: string
                public static parse(arg0: java.lang.String | string, arg1: sun.util.locale.ParseStatus): sun.util.locale.LanguageTag
                public static parseLocale(arg0: sun.util.locale.BaseLocale, arg1: sun.util.locale.LocaleExtensions): sun.util.locale.LanguageTag
                public getLanguage(): string
                public getExtlangs(): java.util.List<java.lang.String>
                public getScript(): string
                public getRegion(): string
                public getVariants(): java.util.List<java.lang.String>
                public getExtensions(): java.util.List<java.lang.String>
                public getPrivateuse(): string
                public static isLanguage(arg0: java.lang.String | string): boolean
                public static isExtlang(arg0: java.lang.String | string): boolean
                public static isScript(arg0: java.lang.String | string): boolean
                public static isRegion(arg0: java.lang.String | string): boolean
                public static isVariant(arg0: java.lang.String | string): boolean
                public static isExtensionSingleton(arg0: java.lang.String | string): boolean
                public static isExtensionSingletonChar(arg0: char): boolean
                public static isExtensionSubtag(arg0: java.lang.String | string): boolean
                public static isPrivateusePrefix(arg0: java.lang.String | string): boolean
                public static isPrivateusePrefixChar(arg0: char): boolean
                public static isPrivateuseSubtag(arg0: java.lang.String | string): boolean
                public static canonicalizeLanguage(arg0: java.lang.String | string): string
                public static canonicalizeExtlang(arg0: java.lang.String | string): string
                public static canonicalizeScript(arg0: java.lang.String | string): string
                public static canonicalizeRegion(arg0: java.lang.String | string): string
                public static canonicalizeVariant(arg0: java.lang.String | string): string
                public static canonicalizeExtension(arg0: java.lang.String | string): string
                public static canonicalizeExtensionSingleton(arg0: java.lang.String | string): string
                public static canonicalizeExtensionSubtag(arg0: java.lang.String | string): string
                public static canonicalizePrivateuse(arg0: java.lang.String | string): string
                public static canonicalizePrivateuseSubtag(arg0: java.lang.String | string): string
                public toString(): string
                public static class: java.lang.Class<any>
            }
            class LocaleExtensions {
                public static CALENDAR_JAPANESE: sun.util.locale.LocaleExtensions
                public static NUMBER_THAI: sun.util.locale.LocaleExtensions
                public getKeys(): java.util.Set<java.lang.Character>
                public getExtension(arg0: java.lang.Character): sun.util.locale.Extension
                public getExtensionValue(arg0: java.lang.Character): string
                public getUnicodeLocaleAttributes(): java.util.Set<java.lang.String>
                public getUnicodeLocaleKeys(): java.util.Set<java.lang.String>
                public getUnicodeLocaleType(arg0: java.lang.String | string): string
                public isEmpty(): boolean
                public static isValidKey(arg0: char): boolean
                public static isValidUnicodeLocaleKey(arg0: java.lang.String | string): boolean
                public toString(): string
                public getID(): string
                public hashCode(): int
                public equals(arg0: java.lang.Object): boolean
                public static class: java.lang.Class<any>
            }
            class LocaleMatcher {
                public static filter(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.util.Locale>, arg2: java.util.Locale$FilteringMode): java.util.List<java.util.Locale>
                public static filterTags(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.lang.String>, arg2: java.util.Locale$FilteringMode): java.util.List<java.lang.String>
                public static lookup(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.util.Locale>): java.util.Locale
                public static lookupTag(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Collection<java.lang.String>): string
                public static parse(arg0: java.lang.String | string): java.util.List<java.util.Locale$LanguageRange>
                public static mapEquivalents(arg0: java.util.List<java.util.Locale$LanguageRange>, arg1: java.util.Map<java.lang.String, java.util.List<java.lang.String>>): java.util.List<java.util.Locale$LanguageRange>
                public static class: java.lang.Class<any>
            }
            abstract class LocaleObjectCache<K, V> {
                public constructor()
                public constructor(arg0: int, arg1: float, arg2: int)
                public get(arg0: K): V
                protected put(arg0: K, arg1: V): V
                protected createObject(arg0: K): V
                protected normalizeKey(arg0: K): K
                public static class: java.lang.Class<any>
            }
            class LocaleSyntaxException extends java.lang.Exception {
                public constructor(arg0: java.lang.String | string)
                public constructor(arg0: java.lang.String | string, arg1: int)
                public getErrorIndex(): int
                public static class: java.lang.Class<any>
            }
            class LocaleUtils {
                public static caseIgnoreMatch(arg0: java.lang.String | string, arg1: java.lang.String | string): boolean
                public static toLowerString(arg0: java.lang.String | string): string
                public static isAlphaNumericString(arg0: java.lang.String | string): boolean
                public static class: java.lang.Class<any>
            }
            class ParseStatus {
                public constructor()
                public reset(): void
                public isError(): boolean
                public getErrorIndex(): int
                public getParseLength(): int
                public getErrorMessage(): string
                public static class: java.lang.Class<any>
            }
            class StringTokenIterator {
                public constructor(arg0: java.lang.String | string, arg1: java.lang.String | string)
                public first(): string
                public current(): string
                public currentStart(): int
                public currentEnd(): int
                public isDone(): boolean
                public next(): string
                public hasNext(): boolean
                public setStart(arg0: int): sun.util.locale.StringTokenIterator
                public setText(arg0: java.lang.String | string): sun.util.locale.StringTokenIterator
                public static class: java.lang.Class<any>
            }
            class UnicodeLocaleExtension extends sun.util.locale.Extension {
                public static SINGLETON: char
                public static CA_JAPANESE: sun.util.locale.UnicodeLocaleExtension
                public static NU_THAI: sun.util.locale.UnicodeLocaleExtension
                public getUnicodeLocaleAttributes(): java.util.Set<java.lang.String>
                public getUnicodeLocaleKeys(): java.util.Set<java.lang.String>
                public getUnicodeLocaleType(arg0: java.lang.String | string): string
                public static isSingletonChar(arg0: char): boolean
                public static isAttribute(arg0: java.lang.String | string): boolean
                public static isKey(arg0: java.lang.String | string): boolean
                public static isTypeSubtag(arg0: java.lang.String | string): boolean
                public toString(): string
                public getID(): string
                public getValue(): string
                public getKey(): char
                public static class: java.lang.Class<any>
            }
        }
        namespace logging {
            class PlatformLogger {
                public static getLogger(arg0: java.lang.String | string): sun.util.logging.PlatformLogger
                public static redirectPlatformLoggers(): void
                public isEnabled(): boolean
                public getName(): string
                public isLoggable(arg0: sun.util.logging.PlatformLogger$Level): boolean
                public level(): sun.util.logging.PlatformLogger$Level
                public setLevel(arg0: sun.util.logging.PlatformLogger$Level): void
                public severe(arg0: java.lang.String | string): void
                public severe(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public severe(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public warning(arg0: java.lang.String | string): void
                public warning(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public warning(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public info(arg0: java.lang.String | string): void
                public info(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public info(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public config(arg0: java.lang.String | string): void
                public config(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public config(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public fine(arg0: java.lang.String | string): void
                public fine(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public fine(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public finer(arg0: java.lang.String | string): void
                public finer(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public finer(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public finest(arg0: java.lang.String | string): void
                public finest(arg0: java.lang.String | string, arg1: java.lang.Throwable): void
                public finest(arg0: java.lang.String | string, ...arg1: java.lang.Object[]): void
                public static class: java.lang.Class<any>
            }
        }
        namespace resources {
            class LocaleData {
                public constructor(arg0: sun.util.locale.provider.LocaleProviderAdapter$Type)
                public getCalendarData(arg0: java.util.Locale): java.util.ResourceBundle
                public getCurrencyNames(arg0: java.util.Locale): sun.util.resources.OpenListResourceBundle
                public getLocaleNames(arg0: java.util.Locale): sun.util.resources.OpenListResourceBundle
                public getTimeZoneNames(arg0: java.util.Locale): sun.util.resources.TimeZoneNamesBundle
                public getBreakIteratorInfo(arg0: java.util.Locale): java.util.ResourceBundle
                public getCollationData(arg0: java.util.Locale): java.util.ResourceBundle
                public getDateFormatData(arg0: java.util.Locale): java.util.ResourceBundle
                public setSupplementary(arg0: sun.util.resources.ParallelListResourceBundle): void
                public getNumberFormatData(arg0: java.util.Locale): java.util.ResourceBundle
                public static getBundle(arg0: java.lang.String | string, arg1: java.util.Locale): java.util.ResourceBundle
                public static class: java.lang.Class<any>
            }
            abstract class LocaleNamesBundle extends sun.util.resources.OpenListResourceBundle {
                protected constructor()
                public static class: java.lang.Class<any>
            }
            abstract class OpenListResourceBundle extends java.util.ResourceBundle {
                protected constructor()
                protected handleGetObject(arg0: java.lang.String | string): java.lang.Object
                public getKeys(): java.util.Enumeration<java.lang.String>
                protected handleKeySet(): java.util.Set<java.lang.String>
                public keySet(): java.util.Set<java.lang.String>
                protected getContents(): java.lang.Object[][]
                protected createMap<K, V>(arg0: int): java.util.Map<K, V>
                protected createSet<E>(): java.util.Set<E>
                public static class: java.lang.Class<any>
            }
            abstract class ParallelListResourceBundle extends java.util.ResourceBundle {
                protected constructor()
                protected getContents(): java.lang.Object[][]
                public setParallelContents(arg0: sun.util.resources.OpenListResourceBundle): void
                protected handleGetObject(arg0: java.lang.String | string): java.lang.Object
                public getKeys(): java.util.Enumeration<java.lang.String>
                public containsKey(arg0: java.lang.String | string): boolean
                protected handleKeySet(): java.util.Set<java.lang.String>
                public keySet(): java.util.Set<java.lang.String>
                public static class: java.lang.Class<any>
            }
            class TimeZoneNames extends sun.util.resources.TimeZoneNamesBundle {
                public constructor()
                protected getContents(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
            abstract class TimeZoneNamesBundle extends sun.util.resources.OpenListResourceBundle {
                public constructor()
                public handleGetObject(arg0: java.lang.String | string): java.lang.Object
                protected createMap<K, V>(arg0: int): java.util.Map<K, V>
                protected createSet<E>(): java.util.Set<E>
                protected getContents<E>(): java.lang.Object[][]
                public static class: java.lang.Class<any>
            }
        }
        namespace spi {
            abstract class CalendarProvider extends java.util.spi.LocaleServiceProvider {
                protected constructor()
                public getInstance(arg0: java.util.TimeZone, arg1: java.util.Locale): java.util.Calendar
                public static class: java.lang.Class<any>
            }
        }
        class BuddhistCalendar extends java.util.GregorianCalendar {
            public constructor()
            public constructor(arg0: java.util.TimeZone)
            public constructor(arg0: java.util.Locale)
            public constructor(arg0: java.util.TimeZone, arg1: java.util.Locale)
            public getCalendarType(): string
            public equals(arg0: java.lang.Object): boolean
            public hashCode(): int
            public get(arg0: int): int
            public set(arg0: int, arg1: int): void
            public add(arg0: int, arg1: int): void
            public roll(arg0: int, arg1: int): void
            public getDisplayName(arg0: int, arg1: int, arg2: java.util.Locale): string
            public getDisplayNames(arg0: int, arg1: int, arg2: java.util.Locale): java.util.Map<java.lang.String, java.lang.Integer>
            public getActualMaximum(arg0: int): int
            public toString(): string
            public static class: java.lang.Class<any>
        }
        abstract class PreHashedMap<V> extends java.util.AbstractMap<java.lang.String, V> {
            protected constructor(arg0: int, arg1: int, arg2: int, arg3: int)
            protected init(arg0: java.lang.Object[]): void
            public get(arg0: java.lang.Object): V
            public put(arg0: java.lang.String | string, arg1: V): V
            public keySet(): java.util.Set<java.lang.String>
            public entrySet(): java.util.Set<java.util.Map$Entry<java.lang.String, V>>
            public put(arg0: java.lang.Object, arg1: java.lang.Object): java.lang.Object
            public static class: java.lang.Class<any>
        }
        class ResourceBundleEnumeration implements java.util.Enumeration<java.lang.String> {
            public constructor(arg0: java.util.Set<java.lang.String>, arg1: java.util.Enumeration<java.lang.String>)
            public hasMoreElements(): boolean
            public nextElement(): string
            public nextElement(): java.lang.Object
            public static class: java.lang.Class<any>
        }
    }
}
